<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>博客</title>

  
  <meta name="author" content="403 Forbidden">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="博客"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="博客" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">博客</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2018/07/12/流水账记录下 Centos 7 配置 frp 服务端与客户端的全过程/"><span>流水账记录下 Centos 7 配置 frp 服务端与客户端的全过程</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/07/12/流水账记录下 Centos 7 配置 frp 服务端与客户端的全过程/" rel="bookmark">
        <time class="entry-date published" datetime="2018-07-12T00:51:43.000Z">
          2018-07-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>下载 frp：<a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">https://github.com/fatedier/frp/releases</a></p>
<p><strong>服务端：</strong><br>编辑四个文件：<br>/usr/local/frp/frps_full.ini（配置文件，视情况编辑）</p>
<p>/usr/lib/systemd/system/frps.service<br>`<br>[Unit]<br>Description=frps<br>After=network.target</p>
<p>[Service]<br>Type=forking<br>ExecStart=/etc/cron.hourly/frps<br>ExecReload=/usr/bin/frpsreload<br>ExecStop=/usr/bin/killall frps<br>PrivateTmp=true</p>
<p>[Install]<br>WantedBy=multi-user.target</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">/etc/cron.hourly/frps</span><br><span class="line">`</span><br><span class="line">#!/bin/sh</span><br><span class="line">echo $(date +&quot;%Y-%m-%d %H:%M:%S&quot;) &gt; /tmp/frpTimestamp</span><br><span class="line">ps aux | grep &quot;frps -c&quot; | grep -v grep</span><br><span class="line">if [ $? -ne 0 ];then</span><br><span class="line">    nohup /usr/local/frp/frps -c /usr/local/frp/frps_full.ini &gt;&gt; /root/frp.log 2&gt;&amp;1 &amp; echo $! &gt; /var/run/frp-server.pid</span><br><span class="line">fi;</span><br></pre></td></tr></table></figure>
<p>/usr/bin/frpsreload<br>`</p>
<p>#!/bin/sh<br>kill -9 $(cat /var/run/frp-server.pid)<br>nohup /usr/local/frp/frps -c /usr/local/frp/frps_full.ini &gt;&gt; /root/frp.log 2&gt;&amp;1 &amp; echo $! &gt; /var/run/frp-server.pid</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">然后执行：</span><br><span class="line">`</span><br><span class="line">systemctl frps enable</span><br><span class="line">service frps start</span><br></pre></td></tr></table></figure>
<p>最后是 nginx 反代设置：<br>/usr/local/nginx/conf/vhost/pi.imjs.0cdn.cn.conf<br>`<br>server {<br>    listen       80;<br>    server_name  pi.imjs.0cdn.cn *.pi.imjs.0cdn.cn;</p>
<pre><code>location / {
    proxy_pass        http://127.0.0.1:8080;
    proxy_set_header  X-Real-IP $remote_addr;
    proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header  Host $host:8080;
}
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">**客户端：**</span><br><span class="line">编辑四个文件：</span><br><span class="line">/usr/local/frp/frpc_full.ini（配置文件，视情况编辑）</span><br><span class="line"></span><br><span class="line">/usr/lib/systemd/system/frp.service</span><br><span class="line">`</span><br><span class="line">[Unit]</span><br><span class="line">Description=frp</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/etc/cron.hourly/frp</span><br><span class="line">ExecReload=/usr/bin/frpreload</span><br><span class="line">ExecStop=killall frp</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p>/etc/cron.hourly/frp<br>`</p>
<p>#!/bin/sh<br>echo $(date +”%Y-%m-%d %H:%M:%S”) &gt; /tmp/frpTimestamp<br>ps aux | grep “frp -c” | grep -v grep<br>if [ $? -ne 0 ];then<br>    ntpdate ntp1.aliyun.com &amp;&amp; (nohup /usr/local/frp/frpc -c /usr/local/frp/frpc_full.ini &gt;&gt; /root/frp.log 2&gt;&amp;1 &amp; echo $! &gt; /var/run/frp-client.pid)<br>fi;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">/usr/bin/frpreload</span><br><span class="line">`</span><br><span class="line">#!/bin/sh</span><br><span class="line">kill -9 $(cat /var/run/frp-client.pid)</span><br><span class="line">nohup /usr/local/frp/frpc -c /usr/local/frp/frpc_full.ini &gt;/dev/null 2&gt;&amp;1 &amp; echo $! &gt; /var/run/frp-client.pid</span><br></pre></td></tr></table></figure>
<p>最后执行：<br>`<br>systemctl frp enable<br>service frp start</p>
<p><code>`</code></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/VPS-技术/">VPS 技术</a>
    </span>
    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/11/19/清除windows访问Samba的访问记录/"><span>清除windows访问Samba的访问记录</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/11/19/清除windows访问Samba的访问记录/" rel="bookmark">
        <time class="entry-date published" datetime="2017-11-19T00:45:01.000Z">
          2017-11-19
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>在 windows 中访问 Samba 服务器后，windows 会存储访问记录，比如密码。当我们想清除密码，重新输入时，步骤如下：<br><strong>1. 获取访问记录</strong><br>`#在windows的命令行(cmd)中运行net use，可见访问Samba服务器的记录：<br>C:\Users\User&gt;net use<br>会记录新的网络连接。<br>状态       本地        远程                      网络</p>
<hr>
<p>OK                     \192.168.2.1\IPC$         Microsoft Windows Network<br>命令成功完成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">**2. 删除访问记录**</span><br><span class="line">`C:\Users\User&gt;net use \\192.168.2.1\IPC$ /del /y</span><br><span class="line"> \\192.168.2.1\IPC$ 已经删除。</span><br></pre></td></tr></table></figure></p>
<p><strong>3. 尝试重新登陆Samba</strong></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/openwrt/">openwrt</a>
    </span>
    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/11/04/斐讯 K3 流光金开箱与 TTL 刷 LEDE 教程（适用于 v21.5.39.260 系统）/"><span>斐讯 K3 流光金开箱与 TTL 刷 LEDE 教程（适用于 v21.5.39.260 系统）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/11/04/斐讯 K3 流光金开箱与 TTL 刷 LEDE 教程（适用于 v21.5.39.260 系统）/" rel="bookmark">
        <time class="entry-date published" datetime="2017-11-04T10:40:13.000Z">
          2017-11-04
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><strong>注意：V21.5.39.260 集成的 CFE 编译日期为 8月2日，斐讯封堵了 CFE 网页执行命令，而且固件采用公私钥验证，除了 TTL 手动执行命令基本无法刷入其他固件（<a href="http://www.right.com.cn/forum/thread-212725-1-1.html" target="_blank" rel="noopener">斐讯K3 官方固件root版本 安装插件 entware </a>）</strong></p>
<p><strong>本文分四段：开箱，拆机加 TTL，CFE 刷官改固件，网页刷 LEDE 固件</strong></p>
<p><strong>在刷入 LEDE 固件之前，不要给 k3 连网！避免自动升级！<br>在刷入 LEDE 固件之前，不要给 k3 连网！避免自动升级！<br>在刷入 LEDE 固件之前，不要给 k3 连网！避免自动升级！</strong></p>
<p>11 月 1 号 K3 流光金首发送贼快的闪迪 U 盘，趁活动入了两台：<br><a href="http://futa.ooo/wp-content/uploads/2017/11/QQ截图20171105012114.png"><img src="http://futa.ooo/wp-content/uploads/2017/11/QQ截图20171105012114.png" alt=""></a></p>
<p>先上购买链接：</p>
<ul>
<li>斐讯K3流光金 AC3150：<a href="http://t.cn/RWIdtzy" target="_blank" rel="noopener">https://item.jd.com/5428209.html</a></li>
</ul>
<ul>
<li>斐讯K3星空银 AC3150：<a href="http://t.cn/RO955lB" target="_blank" rel="noopener">https://item.jd.com/3959251.html</a></li>
</ul>
<p>到手开箱全家福：<br><a href="http://futa.ooo/wp-content/uploads/2017/11/20171102_120516.jpg"><img src="http://futa.ooo/wp-content/uploads/2017/11/20171102_120516-1024x768.jpg" alt=""></a></p>
<p>四网口 + USB 3.0：<br><a href="http://futa.ooo/wp-content/uploads/2017/11/20171102_120552.jpg"><img src="http://futa.ooo/wp-content/uploads/2017/11/20171102_120552-768x1024.jpg" alt=""></a></p>
<p>整机照：<br><a href="http://futa.ooo/wp-content/uploads/2017/11/20171102_121232.jpg"><img src="http://futa.ooo/wp-content/uploads/2017/11/20171102_121232-768x1024.jpg" alt=""></a></p>
<p>mmp 的系统版本 v21.5.39.260：<br><a href="http://futa.ooo/wp-content/uploads/2017/11/QQ截图20171102121540.png"><img src="http://futa.ooo/wp-content/uploads/2017/11/QQ截图20171102121540.png" alt=""></a></p>
<p>嗯废话说完，先给各位拆个机</p>
<p>第一步先扯下底部脚垫，卸下四个螺丝。注意这里有保修易碎贴，如果还要保修的话，拿电吹风吹下挑开：<br><a href="http://futa.ooo/wp-content/uploads/2017/11/20171104_154507.jpg"><img src="http://futa.ooo/wp-content/uploads/2017/11/20171104_154507-768x1024.jpg" alt=""></a></p>
<p>第二步从如图位置插入塑料卡片撬开两侧侧面面板。最好不要用美工刀、钢尺等锐利的物品操作，会留下撬痕：<br><a href="http://futa.ooo/wp-content/uploads/2017/11/20171104_155201.jpg"><img src="http://futa.ooo/wp-content/uploads/2017/11/20171104_155201-768x1024.jpg" alt=""></a></p>
<p>第三步拆开侧面面板，轻轻取下上方天线（注意侧面有卡扣，把塑料外壳往外掰一下就可以取出来了），取下后搁在上面就行，目的是为了卸螺丝。<br><a href="http://futa.ooo/wp-content/uploads/2017/11/20171104_155356.jpg"><img src="http://futa.ooo/wp-content/uploads/2017/11/20171104_155356-1024x768.jpg" alt=""></a></p>
<p>第四步卸下固定两块主板用的八颗螺丝（在螺丝边上上胶的家伙我谢谢你全家）：</p>
<p><a href="http://futa.ooo/wp-content/uploads/2017/11/20171104_160635.jpg"><img src="http://futa.ooo/wp-content/uploads/2017/11/20171104_160635-1024x768.jpg" alt=""></a></p>
<p><a href="http://futa.ooo/wp-content/uploads/2017/11/20171104_164950.jpg"><img src="http://futa.ooo/wp-content/uploads/2017/11/20171104_164950-768x1024.jpg" alt=""></a></p>
<p>第五步在下方主板的右侧 TX RX GND 塞 TTL 线并固定（如果要保修的话，不要固定，我是为了方便以后刷机）我用的热熔胶，如果希望牢固一点的话可以用焊锡。线可以从边上散热孔引出：<br><a href="http://futa.ooo/wp-content/uploads/2017/11/20171104_165104.jpg"><img src="http://futa.ooo/wp-content/uploads/2017/11/20171104_165104-768x1024.jpg" alt=""></a></p>
<p><a href="http://futa.ooo/wp-content/uploads/2017/11/20171104_185431.jpg"><img src="http://futa.ooo/wp-content/uploads/2017/11/20171104_185431-768x1024.jpg" alt=""></a></p>
<p>第六步接 TTL 小板调试（TX 接 RXD，RX 接 TXD，GND 接 GND），115200，如果有输出，就是正常的：<br><a href="http://futa.ooo/wp-content/uploads/2017/11/20171104_171541.jpg"><img src="http://futa.ooo/wp-content/uploads/2017/11/20171104_171541-768x1024.jpg" alt=""></a></p>
<p>最后合上侧面面板：<br><a href="http://futa.ooo/wp-content/uploads/2017/11/20171104_191757.jpg"><img src="http://futa.ooo/wp-content/uploads/2017/11/20171104_191757-1024x768.jpg" alt=""></a></p>
<p>PS 最后找公司的硬件工程师帮忙把引出的线改成了座儿，用热熔胶固定在了散热口：<br><a href="http://futa.ooo/wp-content/uploads/2017/11/20171105_222222.jpg"><img src="http://futa.ooo/wp-content/uploads/2017/11/20171105_222222-768x1024.jpg" alt=""></a></p>
<p><a href="http://futa.ooo/wp-content/uploads/2017/11/20171105_231846.jpg"><img src="http://futa.ooo/wp-content/uploads/2017/11/20171105_231846-768x1024.jpg" alt=""></a></p>
<p>有了 TTL，我们需要先刷入破解了 root 的官改固件并降级，为刷入 LEDE 固件做准备：</p>
<p>以下是需要的软件：</p>
<ul>
<li>Tftpd：<a href="http://tftpd32.jounin.net/" target="_blank" rel="noopener">http://tftpd32.jounin.net/</a></li>
</ul>
<ul>
<li>官改固件下载：<a href="http://futa.ooo/wp-content/uploads/2017/11/k3_root.zip">k3_root</a></li>
</ul>
<ul>
<li>低版本 mtd6 镜像下载：<a href="http://futa.ooo/wp-content/uploads/2017/11/K3-linux-partition-mtd6.zip">K3-linux-partition-mtd6</a></li>
</ul>
<p>第一步下载固件，安装运行 Tftpd 工具。使用网线连接至 k3 上，设置静态 IP 192.168.2.100，网关 192.168.2.1，将 Tftpd 中的目录切换到你存放解压出来的固件目录，并切换网卡（应该是 192.168.2.100，我因为刷机后截的图地址不一样）：<br><a href="http://futa.ooo/wp-content/uploads/2017/11/QQ图片20171105020419.png"><img src="http://futa.ooo/wp-content/uploads/2017/11/QQ图片20171105020419.png" alt=""></a></p>
<p>第二步给路由器断电，连接 TTL，捅 Reset 通电开机，如果成功进入 CFE 会出现下一步图中以 CFE&gt; 开头的界面</p>
<p>第三步输入命令，CFE 会拉取你本机上的固件：<br>`flash -noheader 192.168.2.100:/k3_root.bin nflash0.trx<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[![](http://futa.ooo/wp-content/uploads/2017/11/QQ图片20171105020442.jpg)](http://futa.ooo/wp-content/uploads/2017/11/QQ图片20171105020442.jpg)</span><br><span class="line"></span><br><span class="line">第四步等写入完成后输入 reboot 重启</span><br><span class="line"></span><br><span class="line">第五步在 TTL 输入以下命令，将 mtd6 镜像拉至路由器上并写入（**镜像大小 44M，刷写时间比较长，大约需要 20 ~ 30 分钟（尽量多等一段时间），刷写过程中不要断开路由器的电源或拔网线，以免变砖！！！**）：</span><br><span class="line">`cd /tmp</span><br><span class="line">tftp -g -l K3-linux-partition-mtd6.img -r K3-linux-partition-mtd6.img 192.168.2.100</span><br><span class="line">cat /tmp/K3-linux-partition-mtd6.img &gt; /dev/mtd6</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure></p>
<p>最后进入功能设置 –&gt; 手动升级看到如图系统版本就说明成功了<br><a href="http://futa.ooo/wp-content/uploads/2017/11/QQ图片20171105021238.png"><img src="http://futa.ooo/wp-content/uploads/2017/11/QQ图片20171105021238.png" alt=""></a></p>
<p>随后开始刷 LEDE</p>
<p>固件下载：</p>
<ul>
<li>基础包（无密码）：<a href="http://futa.ooo/wp-content/uploads/2017/11/lede-bcm53xx-phicomm-k3-squashfs-factory.zip">lede-bcm53xx-phicomm-k3-squashfs-factory</a></li>
</ul>
<ul>
<li>升级包（默认登录密码是 password）：<a href="http://futa.ooo/wp-content/uploads/2017/11/LEDE-17.01.2-R7.3.2-bcm53xx-phicomm-k3-squashfs.rar">LEDE-17.01.2-R7.3.2-bcm53xx-phicomm-k3-squashfs</a></li>
</ul>
<p>第一步刷入基础包，进入功能设置 –&gt; 手动升级，上传：<br><a href="http://futa.ooo/wp-content/uploads/2017/11/QQ图片20171105021247.png"><img src="http://futa.ooo/wp-content/uploads/2017/11/QQ图片20171105021247.png" alt=""></a></p>
<p><a href="http://futa.ooo/wp-content/uploads/2017/11/QQ图片20171105022757.png"><img src="http://futa.ooo/wp-content/uploads/2017/11/QQ图片20171105022757.png" alt=""></a></p>
<p>第二步打开 192.168.1.1，进入 System –&gt; Backup / Flash Firmware，上传升级包固件<br><a href="http://futa.ooo/wp-content/uploads/2017/11/QQ图片20171105023217.png"><img src="http://futa.ooo/wp-content/uploads/2017/11/QQ图片20171105023217.png" alt=""></a></p>
<p>最后重启完成，重新打开 192.168.1.1，使用 root / password 登录即可：<br><a href="http://futa.ooo/wp-content/uploads/2017/11/QQ截图20171105022906.png"><img src="http://futa.ooo/wp-content/uploads/2017/11/QQ截图20171105022906.png" alt=""></a></p>
<p>该固件带屏幕驱动，感谢 Lean 大的无私奉献！<br><a href="http://futa.ooo/wp-content/uploads/2017/11/20171105_011645.jpg"><img src="http://futa.ooo/wp-content/uploads/2017/11/20171105_011645-711x1024.jpg" alt=""></a></p>
<p>参考以下文章：</p>
<ol>
<li>拆机部分：<a href="http://www.xinxunwei.com/wxjs/qtcjjc/2017/0327/7300.html" target="_blank" rel="noopener">斐讯路由器怎么样？斐讯K3拆机图解</a></li>
</ol>
<ol start="2">
<li>官改固件：<a href="http://www.right.com.cn/forum/thread-212725-1-1.html" target="_blank" rel="noopener">斐讯K3 官方固件root版本 安装插件 entware</a></li>
</ol>
<ol start="3">
<li>固件降级：<a href="http://koolshare.cn/thread-95398-1-2.html" target="_blank" rel="noopener">K3原厂固件从217版降级212版方法</a></li>
</ol>
<ol start="4">
<li>Lean 大 LEDE：<a href="http://www.right.com.cn/forum/thread-214087-1-1.html" target="_blank" rel="noopener">斐讯 K3 OPENWRT LEDE R7.3  固件，Adbyby Plus，潘多拉多拨，S…</a></li>
</ol>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/openwrt/">openwrt</a>
    </span>
    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/10/28/PHP无限级分类实现（递归+非递归）/"><span>PHP无限级分类实现（递归+非递归）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/10/28/PHP无限级分类实现（递归+非递归）/" rel="bookmark">
        <time class="entry-date published" datetime="2017-10-28T04:21:16.000Z">
          2017-10-28
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>`&lt;?php<br>/**</p>
<ul>
<li>Created by PhpStorm.</li>
<li>User: qishou</li>
<li>Date: 15-8-2</li>
<li>Time: 上午12:00<br>*/<br>//准备数组，代替从数据库中检索出的数据(共有三个必须字段id,name,pid)<br>header(“content-type:text/html;charset=utf-8”);<br>$categories = array(<br> array(‘id’=&gt;1,’name’=&gt;’电脑’,’pid’=&gt;0),<br> array(‘id’=&gt;2,’name’=&gt;’手机’,’pid’=&gt;0),<br> array(‘id’=&gt;3,’name’=&gt;’笔记本’,’pid’=&gt;1),<br> array(‘id’=&gt;4,’name’=&gt;’台式机’,’pid’=&gt;1),<br> array(‘id’=&gt;5,’name’=&gt;’智能机’,’pid’=&gt;2),<br> array(‘id’=&gt;6,’name’=&gt;’功能机’,’pid’=&gt;2),<br> array(‘id’=&gt;7,’name’=&gt;’超级本’,’pid’=&gt;3),<br> array(‘id’=&gt;8,’name’=&gt;’游戏本’,’pid’=&gt;3),<br>);</li>
</ul>
<p>/<em>======================非递归实现========================</em>/<br>$tree = array();<br>//第一步，将分类id作为数组key,并创建children单元<br>foreach($categories as $category){<br>    $tree[$category[‘id’]] = $category;<br>    $tree[$category[‘id’]][‘children’] = array();<br>}<br>//第二步，利用引用，将每个分类添加到父类children数组中，这样一次遍历即可形成树形结构。<br>foreach($tree as $key=&gt;$item){<br>    if($item[‘pid’] != 0){<br>        $tree[$item[‘pid’]][‘children’][] = &amp;$tree[$key];//注意：此处必须传引用否则结果不对<br>        if($tree[$key][‘children’] == null){<br>            unset($tree[$key][‘children’]); //如果children为空，则删除该children元素（可选）<br>        }<br>    }<br>}<br>////第三步，删除无用的非根节点数据<br>foreach($tree as $key=&gt;$category){<br>    if($category[‘pid’] != 0){<br>        unset($tree[$key]);<br>    }<br>}</p>
<p>print_r($tree);</p>
<p>/<em>======================递归实现========================</em>/<br>$tree = $categories;<br>function get_attr($a,$pid){<br>    $tree = array();                                //每次都声明一个新数组用来放子元素<br>    foreach($a as $v){<br>        if($v[‘pid’] == $pid){                      //匹配子记录<br>            $v[‘children’] = get_attr($a,$v[‘id’]); //递归获取子记录<br>            if($v[‘children’] == null){<br>                unset($v[‘children’]);             //如果子元素为空则unset()进行删除，说明已经到该分支的最后一个元素了（可选）<br>            }<br>            $tree[] = $v;                           //将记录存入新数组<br>        }<br>    }<br>    return $tree;                                  //返回新数组<br>}<br>echo “<br><br><br>“;</p>
<p>print_r(get_attr($tree,0));</p>
<p><code>`</code></p>
<p>转载自 <a href="http://blog.csdn.net/qishouzhang/article/details/47204359" target="_blank" rel="noopener">http://blog.csdn.net/qishouzhang/article/details/47204359</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Web-开发/">Web 开发</a>
    </span>
    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/03/20/aria2配置示例/"><span>aria2配置示例</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/03/20/aria2配置示例/" rel="bookmark">
        <time class="entry-date published" datetime="2017-03-20T07:16:30.000Z">
          2017-03-20
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>其实面对man的存在，写什么总结完全没有必要，一切宝藏都在<a href="http://aria2.sourceforge.net/manual/en/html/aria2c.html" target="_blank" rel="noopener">manual</a>。不过反正不会有人会读就是了。那我就写一下吧</p>
<p>##基础<br>首先，aria2或者叫做aria2c，它是一个下载器，嗯。<br>常用的两种模式是直接下载，比如 aria2c “<a href="http://host/file.zip&quot;" target="_blank" rel="noopener">http://host/file.zip&quot;</a> 这样，当它完成后就退出了，就像wget（估计你们也不知道吧）那样。<br>另一种就是rpc server模式，特点就是，它启动之后什么都不干，然后等着从rpc接口添加任务，下载完也不退出，而是一直等着。对，就像迅雷干的那样，当然，它不会上传你硬盘上的数据。<br>因为第一种方式要每次都敲命令，除非像我是原生nix，没有命令行就没法用电脑，估计也没什么用，于是常用的就是第二种。一般启动命令是 aria2c –enable-rpc –rpc-listen-all=true –rpc-allow-origin-all -c -D 。但是，其实*这个命令是不好的！不要使用这种启动方式。<br>首先，用命令方式导致配置不方便修改保存，-D导致无法看到出错信息。<br><strong>推荐启动方式是使用配置文件</strong> $HOME/.aria2/aria2.conf 。嗯，我知道路由上这个地址是无法修改或者重启后会丢失的，那么你可以放到别的地方，然后 aria2c –conf-path= 注意  填完整路径，因为鬼知道这个程序是从那个路径启动的。-D (用于后台执行, 这样ssh断开连接后程序不会退出） 只有在确认OK之后在启动脚本中使用。</p>
<p><strong>以下方案都基于配置文件方式</strong></p>
<p>##图形界面<br>aria2是没有图形界面的，已知相对好用的图形界面有：</p>
<ul>
<li><a href="https://github.com/binux/yaaw" target="_blank" rel="noopener">binux/yaaw</a></li>
</ul>
<ul>
<li><a href="https://github.com/ziahamza/webui-aria2" target="_blank" rel="noopener">ziahamza/webui-aria2</a></li>
</ul>
<p><strong>请使用chrome，firefox等现代浏览器访问</strong>。这两个东西都可以直接使用，除了看英文不爽以外，有什么必要下载回来使用？（吐槽：难道你们就不觉得webui-aria2的title总是被压成好几行，诡异的配色（对，说的就是那个蓝色背景，深蓝颜色的 Use custom IP and port settings 按钮）不难看吗？）<br>图形界面基本都基于RPC模式，所以一定<strong>确定开启了RPC，IP端口可访问，并且在管理器中填写了正确的地址</strong>。</p>
<p>##配置<br><strong>请将所有配置置于配置文件中<br>只有在确认配置无误后再加上 -D 选项<br>请阅读出错信息!</strong></p>
<p>###RPC<br>需要1.14及以上版本<br><a href="http://aria2.sourceforge.net/manual/en/html/aria2c.html#rpc-options" target="_blank" rel="noopener">http://aria2.sourceforge.net/manual/en/html/aria2c.html#rpc-options</a><br>`#允许rpc<br>enable-rpc=true</p>
<p>#允许所有来源, web界面跨域权限需要<br>rpc-allow-origin-all=true</p>
<p>#允许非外部访问<br>rpc-listen-all=true</p>
<p>#RPC端口, 仅当默认端口被占用时修改</p>
<p>#rpc-listen-port=6800<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果启动时出现 Initializing EpollEventPoll failed. 或相似错误, 在配置中加上 event-poll=select</span><br><span class="line"></span><br><span class="line">**使用token验证（建议使用，需要1.18.4以上版本，帐号密码方式将在后续版本中停用！）**</span><br><span class="line">`# token验证</span><br><span class="line">rpc-secret=secret</span><br></pre></td></tr></table></figure></p>
<p>在YAAW中使用 <a href="http://token:secret@hostname:port/jsonrpc" target="_blank" rel="noopener">http://token:secret@hostname:port/jsonrpc</a> 的地址格式设置secret.<br>如果需要使用密码验证（需要1.15.2以上，1.18.6以下版本）<br>`#用户名<br>rpc-user=username</p>
<p>#密码<br>rpc-passwd=passwd<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在YAAW中使用 http://username:passwd@hostname:port/jsonrpc 的地址格式设置密码.</span><br><span class="line">对于RPC模式来说, 界面和后端是分离的, 只要给后端设置密码即可. 前端认证什么的是毫无意义的.</span><br><span class="line">如果你比较新潮, 在YAAW中也可以用 ws:// 为前缀,只用websocket连接aria2c, 如果你不知道websocket是什么. 那就算了.</span><br><span class="line"></span><br><span class="line">###速度相关</span><br><span class="line">`#最大同时下载数(任务数), 路由建议值: 3</span><br><span class="line">max-concurrent-downloads=5</span><br><span class="line">#断点续传</span><br><span class="line">continue=true</span><br><span class="line">#同服务器连接数</span><br><span class="line">max-connection-per-server=5</span><br><span class="line">#最小文件分片大小, 下载线程数上限取决于能分出多少片, 对于小文件重要</span><br><span class="line">min-split-size=10M</span><br><span class="line">#单文件最大线程数, 路由建议值: 5</span><br><span class="line">split=10</span><br><span class="line">#下载速度限制</span><br><span class="line">max-overall-download-limit=0</span><br><span class="line">#单文件速度限制</span><br><span class="line">max-download-limit=0</span><br><span class="line">#上传速度限制</span><br><span class="line">max-overall-upload-limit=0</span><br><span class="line">#单文件速度限制</span><br><span class="line">max-upload-limit=0</span><br><span class="line">#断开速度过慢的连接</span><br><span class="line">#lowest-speed-limit=0</span><br><span class="line">#验证用，需要1.16.1之后的release版本</span><br><span class="line">#referer=*</span><br></pre></td></tr></table></figure></p>
<p>###进度保存相关<br>aria2c只有在正常退出时(ctrl-c), 突然断电是无法保存进度的. 在第一次使用的时候会出现会话文件不存在的错误, 手动创建一个空文件即可. 如果您编写的是自动启动脚本，在启动aria2前加上 touch aria2.session 这句命令。<br>`input-file=/some/where/aria2.session<br>save-session=/some/where/aria2.session</p>
<p>#定时保存会话，需要1.16.1之后的release版</p>
<p>#save-session-interval=60<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">###磁盘相关</span><br><span class="line">`#文件保存路径, 默认为当前启动位置</span><br><span class="line">dir=/some/where</span><br><span class="line">#文件缓存, 使用内置的文件缓存, 如果你不相信Linux内核文件缓存和磁盘内置缓存时使用, 需要1.16及以上版本</span><br><span class="line">#disk-cache=0</span><br><span class="line">#另一种Linux文件缓存方式, 使用前确保您使用的内核支持此选项, 需要1.15及以上版本(?)</span><br><span class="line">#enable-mmap=true</span><br><span class="line">#文件预分配, 能有效降低文件碎片, 提高磁盘性能. 缺点是预分配时间较长</span><br><span class="line">#所需时间 none &lt; falloc ? trunc &lt;&lt; prealloc, falloc和trunc需要文件系统和内核支持</span><br><span class="line">file-allocation=prealloc</span><br></pre></td></tr></table></figure></p>
<p>###BT相关<br><a href="http://aria2.sourceforge.net/manual/en/html/aria2c.html#bittorrent-specific-options" target="_blank" rel="noopener">http://aria2.sourceforge.net/manual/en/html/aria2c.html#bittorrent-specific-options</a><br>`#启用本地节点查找<br>bt-enable-lpd=true</p>
<p>#添加额外的tracker</p>
<p>#bt-tracker=<uri>,…</uri></p>
<p>#单种子最大连接数</p>
<p>#bt-max-peers=55</p>
<p>#强制加密, 防迅雷必备</p>
<p>#bt-require-crypto=true</p>
<p>#当下载的文件是一个种子(以.torrent结尾)时, 自动下载BT<br>follow-torrent=true</p>
<p>#BT监听端口, 当端口屏蔽时使用</p>
<p>#listen-port=6881-6999<br>aria2亦可以用于PT下载, 下载的关键在于伪装</p>
<p>#不确定是否需要，为保险起见，need more test<br>enable-dht=false<br>bt-enable-lpd=false<br>enable-peer-exchange=false</p>
<p>#修改特征<br>user-agent=uTorrent/2210(25130)<br>peer-id-prefix=-UT2210-</p>
<p>#修改做种设置, 允许做种<br>seed-ratio=0</p>
<p>#保存会话<br>force-save=true<br>bt-hash-check-seed=true<br>bt-seed-unverified=true<br>bt-save-metadata=true</p>
<p>#定时保存会话，需要1.16.1之后的某个release版本（比如1.16.2）</p>
<p>#save-session-interval=60<br><code>`</code></p>
<p>##常见问题</p>
<p>###Internal server error<br>手动访问你的JSON-RPC地址 <a href="http://hostname:port/jsonrpc?jsoncallback=1" target="_blank" rel="noopener">http://hostname:port/jsonrpc?jsoncallback=1</a> 如果没有返回, 请确认aria2是否启动以及连通性. 如果aria2在路由器后或没有公网IP, 请做好端口映射.</p>
<p>###如何使用迅雷离线<br><a href="http://binux.github.com/ThunderLixianExporter/" target="_blank" rel="noopener">http://binux.github.com/ThunderLixianExporter/</a><br>安装后, 在迅雷离线的右上角的设置中设置RPC地址.<br>提供chrome插件: <a href="https://chrome.google.com/webstore/detail/thunderlixianassistant/eehlmkfpnagoieibahhcghphdbjcdmen" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/thunderlixianassistant/eehlmkfpnagoieibahhcghphdbjcdmen</a></p>
<p>###如何使用旋风离线(QQ离线)<br><a href="http://userscripts.org/scripts/show/142624" target="_blank" rel="noopener">http://userscripts.org/scripts/show/142624</a><br>安装脚本后, 在旋风离线页面使用.</p>
<p>转载自 <a href="https://binux.blog/2012/12/aria2-examples/" target="_blank" rel="noopener">https://binux.blog/2012/12/aria2-examples/</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/VPS-技术/">VPS 技术</a>
    </span>
    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/03/17/Managing Hierarchical Data in MySQL/"><span>Managing Hierarchical Data in MySQL</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/03/17/Managing Hierarchical Data in MySQL/" rel="bookmark">
        <time class="entry-date published" datetime="2017-03-16T20:50:14.000Z">
          2017-03-17
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><strong>引言</strong><br>大多数用户都曾在数据库中处理过分层数据(hierarchical data)，认为分层数据的管理不是关系数据库的目的。之所以这么认为，是因为关系数据库中的表没有层次关系，只是简单的平面化的列表；而分层数据具有父－子关系，显然关系数据库中的表不能自然地表现出其分层的特性。<br>我们认为，分层数据是每项只有一个父项和零个或多个子项（根项除外，根项没有父项）的数据集合。分层数据存在于许多基于数据库的应用程序中，包括论坛和邮件列表中的分类、商业组织图表、内容管理系统的分类、产品分类。我们打算使用下面一个虚构的电子商店的产品分类：<br><a href="http://futa.ooo/wp-content/uploads/2017/03/1.png"><img src="http://futa.ooo/wp-content/uploads/2017/03/1.png" alt=""></a><br>这些分类层次与上面提到的一些例子中的分类层次是相类似的。在本文中我们将从传统的邻接表(adjacency list)模型出发，阐述2种在MySQL中处理分层数据的模型。</p>
<p><strong>邻接表模型</strong><br>上述例子的分类数据将被存储在下面的数据表中（我给出了全部的数据表创建、数据插入的代码，你可以跟着做）：<br>`CREATE TABLE category(<br>category_id INT AUTO_INCREMENT PRIMARY KEY,<br>name VARCHAR(20) NOT NULL,<br>parent INT DEFAULT NULL);</p>
<p>INSERT INTO category<br>VALUES(1,’ELECTRONICS’,NULL),(2,’TELEVISIONS’,1),(3,’TUBE’,2),<br>(4,’LCD’,2),(5,’PLASMA’,2),(6,’PORTABLE ELECTRONICS’,1),<br>(7,’MP3 PLAYERS’,6),(8,’FLASH’,7),<br>(9,’CD PLAYERS’,6),(10,’2 WAY RADIOS’,6);</p>
<p>SELECT * FROM category ORDER BY category_id;</p>
<p>+————-+———————-+——–+<br>| category_id | name                 | parent |<br>+————-+———————-+——–+<br>|           1 | ELECTRONICS          |   NULL |<br>|           2 | TELEVISIONS          |      1 |<br>|           3 | TUBE                 |      2 |<br>|           4 | LCD                  |      2 |<br>|           5 | PLASMA               |      2 |<br>|           6 | PORTABLE ELECTRONICS |      1 |<br>|           7 | MP3 PLAYERS          |      6 |<br>|           8 | FLASH                |      7 |<br>|           9 | CD PLAYERS           |      6 |<br>|          10 | 2 WAY RADIOS         |      6 |<br>+————-+———————-+——–+<br>10 rows in set (0.00 sec)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在邻接表模型中，数据表中的每项包含了指向其父项的指示器。在此例中，最上层项的父项为空值(NULL)。邻接表模型的优势在于它很简单，可以很容易地看出FLASH是MP3 PLAYERS的子项，哪个是portable electronics的子项，哪个是electronics的子项。虽然，在客户端编码中邻接表模型处理起来也相当的简单，但是如果是纯SQL编码的话，该模型会有很多问题。</span><br><span class="line"></span><br><span class="line">**检索整树**</span><br><span class="line">通常在处理分层数据时首要的任务是，以某种缩进形式来呈现一棵完整的树。为此，在纯SQL编码中通常的做法是使用自连接(self-join)：</span><br><span class="line">`SELECT t1.name AS lev1, t2.name as lev2, t3.name as lev3, t4.name as lev4</span><br><span class="line">FROM category AS t1</span><br><span class="line">LEFT JOIN category AS t2 ON t2.parent = t1.category_id</span><br><span class="line">LEFT JOIN category AS t3 ON t3.parent = t2.category_id</span><br><span class="line">LEFT JOIN category AS t4 ON t4.parent = t3.category_id</span><br><span class="line">WHERE t1.name = &apos;ELECTRONICS&apos;;</span><br><span class="line"></span><br><span class="line">+-------------+----------------------+--------------+-------+</span><br><span class="line">| lev1        | lev2                 | lev3         | lev4  |</span><br><span class="line">+-------------+----------------------+--------------+-------+</span><br><span class="line">| ELECTRONICS | TELEVISIONS          | TUBE         | NULL  |</span><br><span class="line">| ELECTRONICS | TELEVISIONS          | LCD          | NULL  |</span><br><span class="line">| ELECTRONICS | TELEVISIONS          | PLASMA       | NULL  |</span><br><span class="line">| ELECTRONICS | PORTABLE ELECTRONICS | MP3 PLAYERS  | FLASH |</span><br><span class="line">| ELECTRONICS | PORTABLE ELECTRONICS | CD PLAYERS   | NULL  |</span><br><span class="line">| ELECTRONICS | PORTABLE ELECTRONICS | 2 WAY RADIOS | NULL  |</span><br><span class="line">+-------------+----------------------+--------------+-------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p><strong>检索所有叶子节点</strong><br>我们可以用左连接(LEFT JOIN)来检索出树中所有叶子节点(没有孩子节点的节点）：<br>`SELECT t1.name FROM<br>category AS t1 LEFT JOIN category as t2<br>ON t1.category_id = t2.parent<br>WHERE t2.category_id IS NULL;</p>
<p>+————–+<br>| name         |<br>+————–+<br>| TUBE         |<br>| LCD          |<br>| PLASMA       |<br>| FLASH        |<br>| CD PLAYERS   |<br>| 2 WAY RADIOS |<br>+————–+<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">**检索单一路径**</span><br><span class="line">通过自连接，我们也可以检索出单一路径：</span><br><span class="line">`SELECT t1.name AS lev1, t2.name as lev2, t3.name as lev3, t4.name as lev4</span><br><span class="line">FROM category AS t1</span><br><span class="line">LEFT JOIN category AS t2 ON t2.parent = t1.category_id</span><br><span class="line">LEFT JOIN category AS t3 ON t3.parent = t2.category_id</span><br><span class="line">LEFT JOIN category AS t4 ON t4.parent = t3.category_id</span><br><span class="line">WHERE t1.name = &apos;ELECTRONICS&apos; AND t4.name = &apos;FLASH&apos;;</span><br><span class="line"></span><br><span class="line">+-------------+----------------------+-------------+-------+</span><br><span class="line">| lev1        | lev2                 | lev3        | lev4  |</span><br><span class="line">+-------------+----------------------+-------------+-------+</span><br><span class="line">| ELECTRONICS | PORTABLE ELECTRONICS | MP3 PLAYERS | FLASH |</span><br><span class="line">+-------------+----------------------+-------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure></p>
<p>这种方法的主要局限是你需要为每层数据添加一个自连接，随着层次的增加，自连接变得越来越复杂，检索的性能自然而然的也就下降了。</p>
<p><strong>邻接表模型的局限性</strong><br>用纯SQL编码实现邻接表模型有一定的难度。在我们检索某分类的路径之前，我们需要知道该分类所在的层次。另外，我们在删除节点的时候要特别小心，因为潜在的可能会孤立一棵子树（当删除portable electronics分类时，所有他的子分类都成了孤儿）。部分局限性可以通过使用客户端代码或者存储过程来解决，我们可以从树的底部开始向上迭代来获得一颗树或者单一路径，我们也可以在删除节点的时候使其子节点指向一个新的父节点，来防止孤立子树的产生。</p>
<p><strong>嵌套集合(Nested Set)模型</strong><br>我想在这篇文章中重点阐述一种不同的方法，俗称为嵌套集合模型。在嵌套集合模型中，我们将以一种新的方式来看待我们的分层数据，不再是线与点了，而是嵌套容器。我试着以嵌套容器的方式画出了electronics分类图：<br><a href="http://futa.ooo/wp-content/uploads/2017/03/2.png"><img src="http://futa.ooo/wp-content/uploads/2017/03/2.png" alt=""></a><br>从上图可以看出我们依旧保持了数据的层次，父分类包围了其子分类。在数据表中，我们通过使用表示节点的嵌套关系的左值(left value)和右值(right value)来表现嵌套集合模型中数据的分层特性：<br>`CREATE TABLE nested_category (<br> category_id INT AUTO_INCREMENT PRIMARY KEY,<br> name VARCHAR(20) NOT NULL,<br> lft INT NOT NULL,<br> rgt INT NOT NULL<br>);</p>
<p>INSERT INTO nested_category<br>VALUES(1,’ELECTRONICS’,1,20),(2,’TELEVISIONS’,2,9),(3,’TUBE’,3,4),<br>(4,’LCD’,5,6),(5,’PLASMA’,7,8),(6,’PORTABLE ELECTRONICS’,10,19),<br>(7,’MP3 PLAYERS’,11,14),(8,’FLASH’,12,13),<br>(9,’CD PLAYERS’,15,16),(10,’2 WAY RADIOS’,17,18);</p>
<p>SELECT * FROM nested_category ORDER BY category_id;</p>
<p>+————-+———————-+—–+—–+<br>| category_id | name                 | lft | rgt |<br>+————-+———————-+—–+—–+<br>|           1 | ELECTRONICS          |   1 |  20 |<br>|           2 | TELEVISIONS          |   2 |   9 |<br>|           3 | TUBE                 |   3 |   4 |<br>|           4 | LCD                  |   5 |   6 |<br>|           5 | PLASMA               |   7 |   8 |<br>|           6 | PORTABLE ELECTRONICS |  10 |  19 |<br>|           7 | MP3 PLAYERS          |  11 |  14 |<br>|           8 | FLASH                |  12 |  13 |<br>|           9 | CD PLAYERS           |  15 |  16 |<br>|          10 | 2 WAY RADIOS         |  17 |  18 |<br>+————-+———————-+—–+—–+<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们使用了lft和rgt来代替left和right，是因为在MySQL中left和right是保留字。[http://dev.mysql.com/doc/mysql/en/reserved-words.html](http://dev.mysql.com/doc/mysql/en/reserved-words.html)，有一份详细的MySQL保留字清单。</span><br><span class="line">那么，我们怎样决定左值和右值呢？我们从外层节点的最左侧开始，从左到右编号：</span><br><span class="line">[![](http://futa.ooo/wp-content/uploads/2017/03/3.png)](http://futa.ooo/wp-content/uploads/2017/03/3.png)</span><br><span class="line">这样的编号方式也同样适用于典型的树状结构：</span><br><span class="line">[![](http://futa.ooo/wp-content/uploads/2017/03/4.png)](http://futa.ooo/wp-content/uploads/2017/03/4.png)</span><br><span class="line">当我们为树状的结构编号时，我们从左到右，一次一层，为节点赋右值前先从左到右遍历其子节点给其子节点赋左右值。这种方法被称作改进的**先序遍历算法**。</span><br><span class="line"></span><br><span class="line">**检索整树**</span><br><span class="line">我们可以通过自连接把父节点连接到子节点上来检索整树，是因为子节点的lft值总是在其父节点的lft值和rgt值之间：</span><br><span class="line">`SELECT node.name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">AND parent.name = &apos;ELECTRONICS&apos;</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+----------------------+</span><br><span class="line">| name                 |</span><br><span class="line">+----------------------+</span><br><span class="line">| ELECTRONICS          |</span><br><span class="line">| TELEVISIONS          |</span><br><span class="line">| TUBE                 |</span><br><span class="line">| LCD                  |</span><br><span class="line">| PLASMA               |</span><br><span class="line">| PORTABLE ELECTRONICS |</span><br><span class="line">| MP3 PLAYERS          |</span><br><span class="line">| FLASH                |</span><br><span class="line">| CD PLAYERS           |</span><br><span class="line">| 2 WAY RADIOS         |</span><br><span class="line">+----------------------+</span><br></pre></td></tr></table></figure></p>
<p>不像先前邻接表模型的例子，这个查询语句不管树的层次有多深都能很好的工作。在BETWEEN的子句中我们没有去关心node的rgt值，是因为使用node的rgt值得出的父节点总是和使用lft值得出的是相同的。</p>
<p><strong>检索所有叶子节点</strong><br>检索出所有的叶子节点，使用嵌套集合模型的方法比邻接表模型的LEFT JOIN方法简单多了。如果你仔细得看了nested_category表，你可能已经注意到叶子节点的左右值是连续的。要检索出叶子节点，我们只要查找满足rgt=lft+1的节点：<br>`SELECT name<br>FROM nested_category<br>WHERE rgt = lft + 1;</p>
<p>+————–+<br>| name         |<br>+————–+<br>| TUBE         |<br>| LCD          |<br>| PLASMA       |<br>| FLASH        |<br>| CD PLAYERS   |<br>| 2 WAY RADIOS |<br>+————–+<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">**检索单一路径**</span><br><span class="line">在嵌套集合模型中，我们可以不用多个自连接就可以检索出单一路径：</span><br><span class="line">`SELECT parent.name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">AND node.name = &apos;FLASH&apos;</span><br><span class="line">ORDER BY parent.lft;</span><br><span class="line"></span><br><span class="line">+----------------------+</span><br><span class="line">| name                 |</span><br><span class="line">+----------------------+</span><br><span class="line">| ELECTRONICS          |</span><br><span class="line">| PORTABLE ELECTRONICS |</span><br><span class="line">| MP3 PLAYERS          |</span><br><span class="line">| FLASH                |</span><br><span class="line">+----------------------+</span><br></pre></td></tr></table></figure></p>
<p><strong>检索节点的深度</strong><br>我们已经知道怎样去呈现一棵整树，但是为了更好的标识出节点在树中所处层次，我们怎样才能检索出节点在树中的深度呢？我们可以在先前的查询语句上增加COUNT函数和GROUP BY子句来实现：<br>`SELECT node.name, (COUNT(parent.name) - 1) AS depth<br>FROM nested_category AS node,<br>nested_category AS parent<br>WHERE node.lft BETWEEN parent.lft AND parent.rgt<br>GROUP BY node.name<br>ORDER BY node.lft;</p>
<p>+———————-+——-+<br>| name                 | depth |<br>+———————-+——-+<br>| ELECTRONICS          |     0 |<br>| TELEVISIONS          |     1 |<br>| TUBE                 |     2 |<br>| LCD                  |     2 |<br>| PLASMA               |     2 |<br>| PORTABLE ELECTRONICS |     1 |<br>| MP3 PLAYERS          |     2 |<br>| FLASH                |     3 |<br>| CD PLAYERS           |     2 |<br>| 2 WAY RADIOS         |     2 |<br>+———————-+——-+<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们可以根据depth值来缩进分类名字，使用CONCAT和REPEAT字符串函数:</span><br><span class="line">`SELECT CONCAT( REPEAT(&apos; &apos;, COUNT(parent.name) - 1), node.name) AS name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">GROUP BY node.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line">+-----------------------+</span><br><span class="line">| name                  |</span><br><span class="line">+-----------------------+</span><br><span class="line">| ELECTRONICS           |</span><br><span class="line">|  TELEVISIONS          |</span><br><span class="line">|   TUBE                |</span><br><span class="line">|   LCD                 |</span><br><span class="line">|   PLASMA              |</span><br><span class="line">|  PORTABLE ELECTRONICS |</span><br><span class="line">|   MP3 PLAYERS         |</span><br><span class="line">|    FLASH              |</span><br><span class="line">|   CD PLAYERS          |</span><br><span class="line">|   2 WAY RADIOS        |</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure></p>
<p>当然，在客户端应用程序中你可能会用depth值来直接展示数据的层次。Web开发者会遍历该树，随着depth值的增加和减少来添加</p>
<ul>
<li>和</li>
</ul>
<p>标签。</p>
<p><strong>检索子树的深度</strong><br>当我们需要子树的深度信息时，我们不能限制自连接中的node或parent，因为这么做会打乱数据集的顺序。因此，我们添加了第三个自连接作为子查询，来得出子树新起点的深度值：<br>`SELECT node.name, (COUNT(parent.name) - (sub_tree.depth + 1)) AS depth<br>FROM nested_category AS node,<br>    nested_category AS parent,<br>    nested_category AS sub_parent,<br>    (<br>        SELECT node.name, (COUNT(parent.name) - 1) AS depth<br>        FROM nested_category AS node,<br>        nested_category AS parent<br>        WHERE node.lft BETWEEN parent.lft AND parent.rgt<br>        AND node.name = ‘PORTABLE ELECTRONICS’<br>        GROUP BY node.name<br>        ORDER BY node.lft<br>    )AS sub_tree<br>WHERE node.lft BETWEEN parent.lft AND parent.rgt<br>    AND node.lft BETWEEN sub_parent.lft AND sub_parent.rgt<br>    AND sub_parent.name = sub_tree.name<br>GROUP BY node.name<br>ORDER BY node.lft;</p>
<p>+———————-+——-+<br>| name                 | depth |<br>+———————-+——-+<br>| PORTABLE ELECTRONICS |     0 |<br>| MP3 PLAYERS          |     1 |<br>| FLASH                |     2 |<br>| CD PLAYERS           |     1 |<br>| 2 WAY RADIOS         |     1 |<br>+———————-+——-+<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这个查询语句可以检索出任一节点子树的深度值，包括根节点。这里的深度值跟你指定的节点有关。</span><br><span class="line"></span><br><span class="line">**检索节点的直接子节点**</span><br><span class="line">可以想象一下，你在零售网站上呈现电子产品的分类。当用户点击分类后，你将要呈现该分类下的产品，同时也需列出该分类下的直接子分类，而不是该分类下的全部分类。为此，我们只呈现该节点及其直接子节点，不再呈现更深层次的节点。例如，当呈现PORTABLEELECTRONICS分类时，我们同时只呈现MP3 PLAYERS、CD PLAYERS和2 WAY RADIOS分类，而不呈现FLASH分类。</span><br><span class="line"></span><br><span class="line">要实现它非常的简单，在先前的查询语句上添加HAVING子句：</span><br><span class="line">`SELECT node.name, (COUNT(parent.name) - (sub_tree.depth + 1)) AS depth</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">	nested_category AS parent,</span><br><span class="line">	nested_category AS sub_parent,</span><br><span class="line">	(</span><br><span class="line">		SELECT node.name, (COUNT(parent.name) - 1) AS depth</span><br><span class="line">		FROM nested_category AS node,</span><br><span class="line">		nested_category AS parent</span><br><span class="line">		WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">		AND node.name = &apos;PORTABLE ELECTRONICS&apos;</span><br><span class="line">		GROUP BY node.name</span><br><span class="line">		ORDER BY node.lft</span><br><span class="line">	)AS sub_tree</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">	AND node.lft BETWEEN sub_parent.lft AND sub_parent.rgt</span><br><span class="line">	AND sub_parent.name = sub_tree.name</span><br><span class="line">GROUP BY node.name</span><br><span class="line">HAVING depth &lt;= 1</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line">+----------------------+-------+</span><br><span class="line">| name                 | depth |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| PORTABLE ELECTRONICS |     0 |</span><br><span class="line">| MP3 PLAYERS          |     1 |</span><br><span class="line">| CD PLAYERS           |     1 |</span><br><span class="line">| 2 WAY RADIOS         |     1 |</span><br><span class="line">+----------------------+-------+</span><br></pre></td></tr></table></figure></p>
<p>如果你不希望呈现父节点，你可以更改<strong>HAVING depth &lt;= 1</strong>为<strong>HAVING depth = 1</strong>。</p>
<p><strong>嵌套集合模型中集合函数的应用</strong><br>让我们添加一个产品表，我们可以使用它来示例集合函数的应用：<br>`CREATE TABLE product(<br>product_id INT AUTO_INCREMENT PRIMARY KEY,<br>name VARCHAR(40),<br>category_id INT NOT NULL<br>);</p>
<p>INSERT INTO product(name, category_id) VALUES(‘20” TV’,3),(‘36” TV’,3),<br>(‘Super-LCD 42”‘,4),(‘Ultra-Plasma 62”‘,5),(‘Value Plasma 38”‘,5),<br>(‘Power-MP3 5gb’,7),(‘Super-Player 1gb’,8),(‘Porta CD’,9),(‘CD To go!’,9),<br>(‘Family Talk 360’,10);</p>
<p>SELECT * FROM product;</p>
<p>+————+——————-+————-+<br>| product_id | name              | category_id |<br>+————+——————-+————-+<br>|          1 | 20” TV            |           3 |<br>|          2 | 36” TV            |           3 |<br>|          3 | Super-LCD 42”     |           4 |<br>|          4 | Ultra-Plasma 62”  |           5 |<br>|          5 | Value Plasma 38”  |           5 |<br>|          6 | Power-MP3 128mb   |           7 |<br>|          7 | Super-Shuffle 1gb |           8 |<br>|          8 | Porta CD          |           9 |<br>|          9 | CD To go!         |           9 |<br>|         10 | Family Talk 360   |          10 |<br>+————+——————-+————-+<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">现在，让我们写一个查询语句，在检索分类树的同时，计算出各分类下的产品数量：</span><br><span class="line">`SELECT parent.name, COUNT(product.name)</span><br><span class="line">FROM nested_category AS node ,</span><br><span class="line">nested_category AS parent,</span><br><span class="line">product</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">AND node.category_id = product.category_id</span><br><span class="line">GROUP BY parent.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+----------------------+---------------------+</span><br><span class="line">| name                 | COUNT(product.name) |</span><br><span class="line">+----------------------+---------------------+</span><br><span class="line">| ELECTRONICS          |                  10 |</span><br><span class="line">| TELEVISIONS          |                   5 |</span><br><span class="line">| TUBE                 |                   2 |</span><br><span class="line">| LCD                  |                   1 |</span><br><span class="line">| PLASMA               |                   2 |</span><br><span class="line">| PORTABLE ELECTRONICS |                   5 |</span><br><span class="line">| MP3 PLAYERS          |                   2 |</span><br><span class="line">| FLASH                |                   1 |</span><br><span class="line">| CD PLAYERS           |                   2 |</span><br><span class="line">| 2 WAY RADIOS         |                   1 |</span><br><span class="line">+----------------------+---------------------+</span><br></pre></td></tr></table></figure></p>
<p>这条查询语句在检索整树的查询语句上增加了COUNT和GROUP BY子句，同时在WHERE子句中引用了product表和一个自连接。</p>
<p><strong>新增节点</strong><br>到现在，我们已经知道了如何去查询我们的树，是时候去关注一下如何增加一个新节点来更新我们的树了。让我们再一次观察一下我们的嵌套集合图：<br><a href="http://futa.ooo/wp-content/uploads/2017/03/5.png"><img src="http://futa.ooo/wp-content/uploads/2017/03/5.png" alt=""></a><br>当我们想要在TELEVISIONS和PORTABLE ELECTRONICS节点之间新增一个节点，新节点的lft和rgt 的 值为10和11，所有该节点的右边节点的lft和rgt值都将加2，之后我们再添加新节点并赋相应的lft和rgt值。在MySQL 5中可以使用存储过程来完成，我假设当前大部分读者使用的是MySQL 4.1版本，因为这是最新的稳定版本。所以，我使用了锁表（LOCK TABLES）语句来隔离查询：<br>`LOCK TABLE nested_category WRITE;</p>
<p>SELECT @myRight := rgt FROM nested_category<br>WHERE name = ‘TELEVISIONS’;</p>
<p>UPDATE nested_category SET rgt = rgt + 2 WHERE rgt &gt; @myRight;<br>UPDATE nested_category SET lft = lft + 2 WHERE lft &gt; @myRight;</p>
<p>INSERT INTO nested_category(name, lft, rgt) VALUES(‘GAME CONSOLES’, @myRight + 1, @myRight + 2);</p>
<p>UNLOCK TABLES;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们可以检验一下新节点插入的正确性：</span><br><span class="line">`SELECT CONCAT( REPEAT( &apos; &apos;, (COUNT(parent.name) - 1) ), node.name) AS name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">GROUP BY node.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+-----------------------+</span><br><span class="line">| name                  |</span><br><span class="line">+-----------------------+</span><br><span class="line">| ELECTRONICS           |</span><br><span class="line">|  TELEVISIONS          |</span><br><span class="line">|   TUBE                |</span><br><span class="line">|   LCD                 |</span><br><span class="line">|   PLASMA              |</span><br><span class="line">|  GAME CONSOLES        |</span><br><span class="line">|  PORTABLE ELECTRONICS |</span><br><span class="line">|   MP3 PLAYERS         |</span><br><span class="line">|    FLASH              |</span><br><span class="line">|   CD PLAYERS          |</span><br><span class="line">|   2 WAY RADIOS        |</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure></p>
<p>如果我们想要在叶子节点下增加节点，我们得稍微修改一下查询语句。让我们在2 WAYRADIOS叶子节点下添加FRS节点吧：<br>`LOCK TABLE nested_category WRITE;</p>
<p>SELECT @myLeft := lft FROM nested_category</p>
<p>WHERE name = ‘2 WAY RADIOS’;</p>
<p>UPDATE nested_category SET rgt = rgt + 2 WHERE rgt &gt; @myLeft;<br>UPDATE nested_category SET lft = lft + 2 WHERE lft &gt; @myLeft;</p>
<p>INSERT INTO nested_category(name, lft, rgt) VALUES(‘FRS’, @myLeft + 1, @myLeft + 2);</p>
<p>UNLOCK TABLES;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在这个例子中，我们扩大了新产生的父节点(2 WAY RADIOS节点）的右值及其所有它的右边节点的左右值，之后置新增节点于新父节点之下。正如你所看到的，我们新增的节点已经完全融入了嵌套集合中：</span><br><span class="line">`SELECT CONCAT( REPEAT( &apos; &apos;, (COUNT(parent.name) - 1) ), node.name) AS name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">GROUP BY node.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+-----------------------+</span><br><span class="line">| name                  |</span><br><span class="line">+-----------------------+</span><br><span class="line">| ELECTRONICS           |</span><br><span class="line">|  TELEVISIONS          |</span><br><span class="line">|   TUBE                |</span><br><span class="line">|   LCD                 |</span><br><span class="line">|   PLASMA              |</span><br><span class="line">|  GAME CONSOLES        |</span><br><span class="line">|  PORTABLE ELECTRONICS |</span><br><span class="line">|   MP3 PLAYERS         |</span><br><span class="line">|    FLASH              |</span><br><span class="line">|   CD PLAYERS          |</span><br><span class="line">|   2 WAY RADIOS        |</span><br><span class="line">|    FRS                |</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure></p>
<p><strong>删除节点</strong><br>最后还有个基础任务，删除节点。删除节点的处理过程跟节点在分层数据中所处的位置有关，删除一个叶子节点比删除一个子节点要简单得多，因为删除子节点的时候，我们需要去处理孤立节点。<br>删除一个叶子节点的过程正好是新增一个叶子节点的逆过程，我们在删除节点的同时该节点右边所有节点的左右值和该父节点的右值都会减去该节点的宽度值：<br>`LOCK TABLE nested_category WRITE;</p>
<p>SELECT @myLeft := lft, @myRight := rgt, @myWidth := rgt - lft + 1<br>FROM nested_category<br>WHERE name = ‘GAME CONSOLES’;</p>
<p>DELETE FROM nested_category WHERE lft BETWEEN @myLeft AND @myRight;</p>
<p>UPDATE nested_category SET rgt = rgt - @myWidth WHERE rgt &gt; @myRight;<br>UPDATE nested_category SET lft = lft - @myWidth WHERE lft &gt; @myRight;</p>
<p>UNLOCK TABLES;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们再一次检验一下节点已经成功删除,而且没有打乱数据的层次：</span><br><span class="line">`SELECT CONCAT( REPEAT( &apos; &apos;, (COUNT(parent.name) - 1) ), node.name) AS name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">GROUP BY node.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+-----------------------+</span><br><span class="line">| name                  |</span><br><span class="line">+-----------------------+</span><br><span class="line">| ELECTRONICS           |</span><br><span class="line">|  TELEVISIONS          |</span><br><span class="line">|   TUBE                |</span><br><span class="line">|   LCD                 |</span><br><span class="line">|   PLASMA              |</span><br><span class="line">|  PORTABLE ELECTRONICS |</span><br><span class="line">|   MP3 PLAYERS         |</span><br><span class="line">|    FLASH              |</span><br><span class="line">|   CD PLAYERS          |</span><br><span class="line">|   2 WAY RADIOS        |</span><br><span class="line">|    FRS                |</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure></p>
<p>这个方法可以完美地删除节点及其子节点：<br>`LOCK TABLE nested_category WRITE;</p>
<p>SELECT @myLeft := lft, @myRight := rgt, @myWidth := rgt - lft + 1<br>FROM nested_category<br>WHERE name = ‘MP3 PLAYERS’;</p>
<p>DELETE FROM nested_category WHERE lft BETWEEN @myLeft AND @myRight;</p>
<p>UPDATE nested_category SET rgt = rgt - @myWidth WHERE rgt &gt; @myRight;<br>UPDATE nested_category SET lft = lft - @myWidth WHERE lft &gt; @myRight;</p>
<p>UNLOCK TABLES;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">再次验证我们已经成功的删除了一棵子树：</span><br><span class="line">`SELECT CONCAT( REPEAT( &apos; &apos;, (COUNT(parent.name) - 1) ), node.name) AS name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">GROUP BY node.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+-----------------------+</span><br><span class="line">| name                  |</span><br><span class="line">+-----------------------+</span><br><span class="line">| ELECTRONICS           |</span><br><span class="line">|  TELEVISIONS          |</span><br><span class="line">|   TUBE                |</span><br><span class="line">|   LCD                 |</span><br><span class="line">|   PLASMA              |</span><br><span class="line">|  PORTABLE ELECTRONICS |</span><br><span class="line">|   CD PLAYERS          |</span><br><span class="line">|   2 WAY RADIOS        |</span><br><span class="line">|    FRS                |</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure></p>
<p>有时，我们只删除该节点，而不删除该节点的子节点。在一些情况下，你希望改变其名字为占位符，直到替代名字的出现，比如你开除了一个主管（需要更换主管）。在另外一些情况下，你希望子节点挂到该删除节点的父节点下：<br>`LOCK TABLE nested_category WRITE;</p>
<p>SELECT @myLeft := lft, @myRight := rgt, @myWidth := rgt - lft + 1<br>FROM nested_category<br>WHERE name = ‘PORTABLE ELECTRONICS’;</p>
<p>DELETE FROM nested_category WHERE lft = @myLeft;</p>
<p>UPDATE nested_category SET rgt = rgt - 1, lft = lft - 1 WHERE lft BETWEEN @myLeft AND @myRight;<br>UPDATE nested_category SET rgt = rgt - 2 WHERE rgt &gt; @myRight;<br>UPDATE nested_category SET lft = lft - 2 WHERE lft &gt; @myRight;</p>
<p>UNLOCK TABLES;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在这个例子中，我们对该节点所有右边节点的左右值都减去了2（因为不考虑其子节点，该节点的宽度为2），对该节点的子节点的左右值都减去了1（弥补由于失去父节点的左值造成的裂缝）。我们再一次确认，那些节点是否都晋升了：</span><br><span class="line">`</span><br><span class="line">SELECT CONCAT( REPEAT( &apos; &apos;, (COUNT(parent.name) - 1) ), node.name) AS name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">GROUP BY node.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+---------------+</span><br><span class="line">| name          |</span><br><span class="line">+---------------+</span><br><span class="line">| ELECTRONICS   |</span><br><span class="line">|  TELEVISIONS  |</span><br><span class="line">|   TUBE        |</span><br><span class="line">|   LCD         |</span><br><span class="line">|   PLASMA      |</span><br><span class="line">|  CD PLAYERS   |</span><br><span class="line">|  2 WAY RADIOS |</span><br><span class="line">|   FRS         |</span><br><span class="line">+---------------+</span><br></pre></td></tr></table></figure></p>
<p>有时，当删除节点的时候，把该节点的一个子节点挂载到该节点的父节点下，而其他节点挂到该节点父节点的兄弟节点下，考虑到篇幅这种情况不在这里解说了。</p>
<p><strong>最后的思考</strong><br>我希望这篇文章对你有所帮助，SQL中的嵌套集合的观念大约有十年的历史了，在网上和一些书中都能找到许多相关信息。在我看来，讲述分层数据的管理最全面的，是来自一本名叫《Joe Celko’s Trees and Hierarchies in SQL for Smarties》的书，此书的作者是在高级SQL领域倍受尊敬的Joe Celko。Joe Celko被认为是嵌套集合模型的创造者，更是该领域内的多产作家。我把Celko的书当作无价之宝，并极力地推荐它。在这本书中涵盖了在此文中没有提及的一些高级话题，也提到了其他一些关于邻接表和嵌套集合模型下管理分层数据的方法。<br>在随后的参考书目章节中，我列出了一些网络资源，也许对你研究分层数据的管理会有所帮助，其中包括一些PHP相关的资源（处理嵌套集合的PHP库）。如果你还在使用邻接表模型，你该去试试嵌套集合模型了，在Storing Hierarchical Data in a Database 文中下方列出的一些资源链接中能找到一些样例代码，可以去试验一下。</p>
<p>转自 <a href="http://www.cnblogs.com/phaibin/archive/2009/06/09/1499687.html" target="_blank" rel="noopener">http://www.cnblogs.com/phaibin/archive/2009/06/09/1499687.html</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Web-开发/">Web 开发</a>
    </span>
    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/03/11/PHP 无极分类生成树状数组/"><span>PHP 无极分类生成树状数组</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/03/11/PHP 无极分类生成树状数组/" rel="bookmark">
        <time class="entry-date published" datetime="2017-03-11T06:35:49.000Z">
          2017-03-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>`&lt;?php<br>$arr=[<br>   [‘id’ =&gt; 1, ‘text’ =&gt; ‘Parent 1’, ‘pid’ =&gt; 0],<br>   [‘id’ =&gt; 2, ‘text’ =&gt; ‘Parent 2’, ‘pid’ =&gt; 0],<br>   [‘id’ =&gt; 3, ‘text’ =&gt; ‘Parent 3’, ‘pid’ =&gt; 0],<br>   [‘id’ =&gt; 4, ‘text’ =&gt; ‘Child 1’, ‘pid’ =&gt; 1],<br>   [‘id’ =&gt; 5, ‘text’ =&gt; ‘Parent 4’, ‘pid’ =&gt; 0],<br>   [‘id’ =&gt; 6, ‘text’ =&gt; ‘Child 2’, ‘pid’ =&gt; 1],<br>   [‘id’ =&gt; 7, ‘text’ =&gt; ‘Child 3’, ‘pid’ =&gt; 1],<br>   [‘id’ =&gt; 8, ‘text’ =&gt; ‘Parent 5’, ‘pid’ =&gt; 0],<br>   [‘id’ =&gt; 9, ‘text’ =&gt; ‘Child 1’, ‘pid’ =&gt; 2],<br>   [‘id’ =&gt; 10, ‘text’ =&gt; ‘Child 4’, ‘pid’ =&gt; 1],<br>   [‘id’ =&gt; 11, ‘text’ =&gt; ‘Child 1’, ‘pid’ =&gt; 5],<br>   [‘id’ =&gt; 12, ‘text’ =&gt; ‘GrandChild 1’, ‘pid’ =&gt; 10]<br>];</p>
<p>class createTree {<br>    private static $table = [];</p>
<pre><code>private function __construct() {}

private static function tree($pid = 0) {
    $tree = array();
    foreach (self::$table as $row) {
        if ($row[&apos;pid&apos;] === $pid) {
            $tmp = self::tree($row[&apos;id&apos;]);
            if ($tmp) {
                $row[&apos;children&apos;] = $tmp;
            }
            $tree[] = $row;                
        }
    }
    return $tree;        
}

public static function get($table) {
    self::$table = $table;
    return self::tree();        
}
</code></pre><p>}</p>
<p>var_dump(createTree::get($arr));<br><code>`</code></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Web-开发/">Web 开发</a>
    </span>
    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/12/27/一个简单的 MySQL 队列问题/"><span>一个简单的 MySQL 队列问题</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/12/27/一个简单的 MySQL 队列问题/" rel="bookmark">
        <time class="entry-date published" datetime="2016-12-26T23:47:23.000Z">
          2016-12-27
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>最近有个朋友要实现队列任务方面的工作，我们就 mysql(innodb) 的事务和锁的特性聊了一些有趣的话题。<br>其中，最终的解决方案来自大神 <a href="https://github.com/fengmk2" target="_blank" rel="noopener">https://github.com/fengmk2</a> 之前的一个队列实现。 我做了一个小改进，使得之前表级锁的表现可以恢复到行级锁水平。</p>
<p>任务的大致描述是这样的：<br>有一个表，里面存了很多的用户id，大概100w条，表的结构简化如下：<br>`create table user_block_status {<br>  user_id bigint // 用户的id<br>  status int // 用户的状态。1 ok 2 not ok<br>  updated_time timestamp // 更新时间戳<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这个表里面，每隔10秒就要去检查用户是否存在违规页面。如果存在的话，则需要把 status 置为 2，默认是 1。</span><br><span class="line">有 100 个 worker 会并发地从表里面读取 user_id，所以我们要设计一个策略，使得这 100 个 worker 在并发时， 读到的是独立的 100 个条目。</span><br><span class="line"></span><br><span class="line">**方案1**</span><br><span class="line">一开始的方案是这样的：</span><br><span class="line">`</span><br><span class="line">// 这一句不一定会发请求，可能会优化成跟接下来的第一个 query 一起发出</span><br><span class="line">sql.begin_transaction</span><br><span class="line"></span><br><span class="line">// 第一次io发生。</span><br><span class="line">// 如果一个用户在 10s 内没有被更新，那么取出来</span><br><span class="line">// 这时候由于程序拿得到 user_id 的值，所以网络io是发生了的。否则拿不到 user_id 的值</span><br><span class="line">outdate_time = now() - 10s</span><br><span class="line">line = sql.query(&apos;select user_id where updated_time &lt; ? order by updated_time asc limit 1&apos;, [outdate_time])</span><br><span class="line"></span><br><span class="line">// 第二次 io 发生</span><br><span class="line">// 更新这一行的 updated_time，免得被其他worker重复读取</span><br><span class="line">user_id = line.user_id</span><br><span class="line">sql.query(&apos;update user_block_status set updated_time=now() where user_id = ?&apos;,</span><br><span class="line">  [user_id])</span><br><span class="line"></span><br><span class="line">// 第三次 io 发生</span><br><span class="line">sql.commit</span><br><span class="line"></span><br><span class="line">// do something with user_id</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这个地方我们发起了 3 次 io 请求。当然，请求数不是很关键，因为请求数以及对应的时间是一个恒定量， 而随着 worker 的增加，这一块并不会带来额外的性能瓶颈。但由于我们使用了事务，所以当 worker 由 100 增加到 1000 的时候，数据库由于存在大量的事务操作，这些事务都需要掌握写锁，所以有潜在的写锁排队问题。<br>而且关键是，方案是不可行的，根本没有起到队列的效果。<br>为什么呢？我们假设网络io无限快，而数据库每条语句的执行时间是1s，那么我们这个事务的执行时间是 2s。 这时如果 3 个 worker 并发地在同一秒（00:00）执行，那么假设 worker1 读到的 user_id 是 10086， 由于读锁是共享的，worker2 和 worker3 读到的 user_id 也是 10086。这时他们三个都想要更新 10086 的值， 而 worker1 抢先加了写锁，所以 worker2 和 worker3 就需要等待 worker1 的事务执行完毕， 才能重新获得 10086 的写锁并进行写入。 所以当 worker2 执行的时候，是 00:02 的时候，当 worker3 执行的时候，是 00:04 的时刻。 而且由于他们都是在对 10086 进行更新，所以没有起到队列的效果。<br>这里的查询条件太特殊，导致所有并发的事务需要的都是同一条数据， 这时候 innodb 行级锁的特性也没有发挥出来。<br>这个方案不仅并发时的表现类似表级锁的特性，而且也没有达到队列的效果。</p>
<p><strong>方案2</strong><br>将 update 语句在先，select 语句在后。<br>update 语句改成<br>`outdate_time = now() - 10s<br>result = sql.query(‘update user_block_status set updated_time=now() where updated_time &lt; ?   order by updated_time asc limit 1’,<br>  [outdate_time])</p>
<h2 id="each-worker-can-get-different-result-user-id"><a href="#each-worker-can-get-different-result-user-id" class="headerlink" title="each worker can get different result.user_id"></a>each worker can get different result.user_id</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这样在 update 的时候，3 个 worker 会排队，分别更新不同的 user_id 条目。然后返回来的 也是不同的 user_id。</span><br><span class="line">可关键是，update 语句并不会将被 update 了的 id 返回给程序，所以我们后面的 select 语句拿不到对应的 user_id。 这个方案先否决。</span><br><span class="line"></span><br><span class="line">**方案3**</span><br><span class="line">方案1的基础上，在 select 语句中，手工地干扰一下，使得不同的 worker 取到不同的条目</span><br><span class="line">`outdate_time = now() - 10s</span><br><span class="line">random_number = random_int(0, worker_count * 2)</span><br><span class="line">line = sql.query(&apos;select user_id where updated_time &lt; ?  order by updated_time asc limit 1 offset ?&apos;,</span><br><span class="line">  [outdate_time, random_number])</span><br></pre></td></tr></table></figure>
<p>这时，我们的 worker 有很大的几率可以取出不同 user_id。但这里也还有个问题就是，很可能两个 worker 的 random_number 是同一个值。那么就发生了两次重复读取，不过对于我们的业务来说，重复读取只会造成资源的浪费， 而不会带来数据一致性的问题。只要尽量减少重复读的几率，那么这个方案就是可被接受的。<br>其中 worker_count * 2 是拍脑袋决定的数，如果数据库中始终有大量需要处理的数据，可以加大点。</p>
<p><strong>方案4</strong><br>方案3还是挺不完美的，虽然能解决问题，但是从概念上来说，我们需要的是队列。 队列的意思就是：排队！排队！排队！<br>方案3只是从业务逻辑层面出发，做出了一些规避，模拟了我们需要的效果。<br>那么回到方案2，其实方案2是更接近队列的。因为不同的 worker 真正在等待另一个 worker 更新东西。 可方案2无奈的是，我们拿不到被更新的id。那么有没有办法拿到呢？<br>其实是有的，用 mysql 的 LAST_INSERT_ID() 函数。<br>`LAST_INSERT_ID(): Value of the AUTOINCREMENT column for the last INSERT<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">关于这个函数可以看看 [https://dev.mysql.com/doc/refman/5.7/en/information-functions.html](https://dev.mysql.com/doc/refman/5.7/en/information-functions.html) 这里的详细介绍。</span><br><span class="line">这个函数本来的含义是，拿到 AUTO_INCREMENT 那一列的最新值。也就是我们最新 insert 进表的那个 id。 但实际上，它也可以作为一个 sql 语句中的变量来使用，它可以被赋值，然后取出。 而且它的作用域是同一 connection 内，这样我们多个 worker 如果对 LAST_INSERT_ID 赋了不同的值， 也不会互相干扰，因为不同的 worker 使用不同的 connection。</span><br><span class="line">这时，我们的查询在方案2的基础上就变成：</span><br><span class="line">`sql.begin_transaction</span><br><span class="line"></span><br><span class="line">outdate_time = now() - 10s</span><br><span class="line">sql.query(&apos;update user_block_status set updated_time=now()，</span><br><span class="line"> id=LAST_INSERT_ID(id) where updated_time &lt; ?  order by updated_time asc limit 1&apos;,</span><br><span class="line">  [outdate_time])</span><br><span class="line"></span><br><span class="line">line = sql.query(&apos;select user_id where id = LAST_INSERT_ID()&apos;)</span><br><span class="line"></span><br><span class="line">## do sth with line.user_id</span><br><span class="line"></span><br><span class="line">sql.commit</span><br></pre></td></tr></table></figure></p>
<p>ok，已经能排队了，业务上已经可以满足了。<br>目前性能上说，网络io还是三个，而且，【行级锁】没有被利用的特定依然存在。 写锁依然要排队，为什么这么说？因为不管 worker 有多少个，当他们并发的时候，where 条件都始终把它们 指向同一行数据，所以还是要为了同一行数据排队。即使目前我们已经达成了【排队之后，互相更新不同条目】这个目的。<br>方案4就总的性价比来说，目前跟方案3相比，还不一定谁好谁坏。 方案4的性能在于多个worker抢一个锁，大家总是等；方案3是无脑乱取，造成资源浪费，降低worker的效率，浪费机器。<br>什么情况下方案3好？ 如果总是有一大堆数据没有被处理的话，那么把方案3的乱取范围开大点，就能更好避免浪费。 而当一大堆数据等待处理的时候，方案4却不停在排队，这就等于堵住了。<br>还有一种情况就是，方案4的写锁排队已经成为瓶颈。但其实这跟上面是一回事，当总是有一大堆 worker 来取 东西的话，说明就是有一大堆数据没有被处理。否则开那么多 worker 干嘛。<br>什么情况下方案4好？ 前提就是，写锁排队并不成为瓶颈。如果要处理的数据并不是那么多，那么使用方案4的话，可以降低我们需要的 worker 数量，节约机器。 而且 worker 数量评估可以更加理性。</p>
<p><strong>方案5</strong><br>那么，我们把方案3的 offset 思想加进来吧。可惜啊可惜，update 语法只支持 limit，不支持 offset。<br>`UPDATE [LOW_PRIORITY] [IGNORE] table_reference<br>    SET col_name1={expr1|DEFAULT} [, col_name2={expr2|DEFAULT}] …<br>    [WHERE where_condition]<br>    [ORDER BY …]<br>    [LIMIT row_count]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">那就绕一绕。</span><br><span class="line">不用 offset，而是通过更改 outdate_time 的值，让他们获得不同的行数据。</span><br><span class="line">我们的程序是要求 10s 算作过期，那么 11s、20s、30s 肯定也算过期吧。那就这样写：</span><br><span class="line">`// 在 10 到 30s 之间随机取值</span><br><span class="line">outdate_time = now() - (random(10, 30))s</span><br><span class="line">sql.query(&apos;update user_block_status set updated_time=now()，</span><br><span class="line"> id=LAST_INSERT_ID(id) where updated_time &lt; ?  order by updated_time asc  limit 1&apos;,</span><br><span class="line">  [outdate_time])</span><br><span class="line">where updated_time &lt; now() - 10s 与 where updated_time &lt; now() - 12s 与 where updated_time &lt; now() - 15s</span><br><span class="line">//（不要在 where 条件里面写计算，这只是示例） 还是有可能锁定同一条数据。但至少，这个方案既利用上了行级锁，也不会造成多个 worker 处理同一 user_id 的 资源浪费。</span><br></pre></td></tr></table></figure></p>
<p><strong>方案6</strong><br>锁的问题差不多就这么解决了。<br>我们再回头看看，发现还有个 io 问题可以再弄弄。现在还是 3 个 io 嘛。<br>其实到了现在这步，begin_transaction 可以去掉了。因为我们只有一个涉及写锁的操作在里面，这个操作本身作为单一语句， 就已经是原子性的了。<br>但由于我们利用了 LAST_INSERT_ID，所以我们要保证 update 语句和它之后的 select 语句在同一个 connection 中。<br>很多的 mysql 库实现都是用了连接池的，所以同一段代码中的两条 sql 有可能会利用两条 connection， 导致得到我们非预期的 user_id。<br>但就我们的业务来说，LAST_INSERT_ID 混了其实是没关系的。每个 worker 始终还是会得到一个 unique 的 user_id。 这就够了。那么我们也不必加一些多余的逻辑，保证这两条语句取到同一个 connection。<br>这时，io 操作从 3，降低到了 2。<br>那么，有没有可能降到 1 呢。<br>其实也可以啊…………因为基本所有 mysql 库都支持 multistatements 特性。<br>我们可以在一条 query 写两个语句，返回接口会是一个数组，分别表示这两个语句的值。<br>类似这样，sql.query(‘update …..; select ….;’)。这是支持的。而且这么一来， 同一 connection 的问题也解决了。避免为以后留坑。<br>重写方案<br>`outdate_time = now() - (random(10, 30))s<br>result = sql.query(‘update user_block_status set updated_time=now()，<br> user_id=LAST_INSERT_ID(user_id) where updated_time &lt; ?  order by updated_time asc limit 1;</p>
<p> select * from user_block_status where user_id = LAST_INSERT_ID()’,<br>  [outdate_time])</p>
<p>// do something with result[1].user_id<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">。。。。。。。。。。。。。</span><br><span class="line">还是有坑的。。。。。。。。。。。。。。。</span><br><span class="line">如果 where updated_time &lt; ? 一条都不命中，那么会发生什么结果？</span><br><span class="line">首先，update 没有改变任何行。而 LAST_INSERT_ID 还是会返回一个合理的 id，有可能是真正的 LAST_INSERT_ID， 也可能是这条 connection 中上次手工设置的。</span><br><span class="line">在这里可以多说一下 LAST_INSERT_ID 的特性。默认情况下，LAST_INSERT_ID() 不带参数会返回最新插入那条的 id。 带参数的情况下 LAST_INSERT_ID(id) 本身的返回值就是参数，然后在接下来的调用中，如果不发生任何 insert，那么 值会在 connection 中一直保持。如果发生了 insert，就会被更新。</span><br><span class="line">如果不处理这个 update nothing 的异常情况，当队列全部被处理完的时候， 我们的 worker 会一直工作，不会停下来。所以我们要在取 LAST_INSERT_ID 的值时， 判断一下上一条 update 语句到底有没有发生作用。</span><br><span class="line">这时候我们需要用到另一个跟 LAST_INSERT_ID 一起出现在文档中的函数，</span><br><span class="line">`ROW_COUNT(): The number of rows updated</span><br></pre></td></tr></table></figure></p>
<p>判断一下 ROW_COUNT，如果是 0 的话，就条件不符，这时候我们在程序里面拿到的值就是空。<br>最终方案<br>`outdate_time = now() - (random(10, 30))s<br>result = sql.query(‘update user_block_status set updated_time=now()，<br>  user_id=LAST_INSERT_ID(user_id) where updated_time &lt; ?  order by updated_time asc limit 1;</p>
<p>  select * from user_block_status where user_id = LAST_INSERT_ID()<br>    and ROW_COUNT() &lt;&gt; 0’,<br>  [outdate_time])</p>
<p>// do something with result[1].user_id<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当然，mysql 用来解决这种队列问题可能不是一个好的方案。队列相关的知识，我还在努力学习中。</span><br><span class="line">参考资料：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  * http://www.cnblogs.com/zhoujinyi/p/3437475.html</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">  * https://dev.mysql.com/doc/refman/5.7/en/information-functions.html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">转载自 [https://ruby-china.org/topics/27814](https://ruby-china.org/topics/27814)</span><br><span class="line"></span><br><span class="line">附：虽然用的是 ruby 语言，但其中最关键的还是 sql 语句。最近做个基于 laravel 的应用中使用到了队列的概念，因为对并发要求不高，所以直接用了 MariaDB，记下源码留作备用：</span><br><span class="line">`&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\Http\Controllers\api\v1;</span><br><span class="line"></span><br><span class="line">use App\Http\Controllers\Controller;</span><br><span class="line">use Illuminate\Http\Request;</span><br><span class="line">use Illuminate\Support\Facades\DB;</span><br><span class="line"></span><br><span class="line">class server extends Controller &#123;</span><br><span class="line">    public function create(Request $request) &#123;</span><br><span class="line">        $inputFilters = [</span><br><span class="line">            &quot;gid&quot; =&gt; [&quot;filter&quot; =&gt; FILTER_VALIDATE_INT, &quot;options&quot; =&gt; [&apos;min_range&apos; =&gt; 1]],</span><br><span class="line">            &quot;sid&quot; =&gt; [&quot;filter&quot; =&gt; FILTER_VALIDATE_INT, &quot;options&quot; =&gt; [&apos;min_range&apos; =&gt; 1]]</span><br><span class="line">        ];</span><br><span class="line">        $inputData = $request-&gt;all();</span><br><span class="line">        $insertData = filter_var_array($inputData, $inputFilters);</span><br><span class="line">        foreach ($insertData as $value) &#123;</span><br><span class="line">            if (!$value) &#123;</span><br><span class="line">                return response()-&gt;json([&quot;errno&quot; =&gt; -1], 500);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        DB::table(&apos;srv&apos;)</span><br><span class="line">            -&gt;where([</span><br><span class="line">                [&apos;conf&apos;, &apos;=&apos;, $insertData[&quot;gid&quot;]],</span><br><span class="line">                [&apos;state&apos;, &apos;=&apos;, &apos;0&apos;],</span><br><span class="line">                [&apos;power&apos;, &apos;=&apos;, &apos;0&apos;]</span><br><span class="line">            ])</span><br><span class="line">            -&gt;orderBy(&apos;id&apos;, &apos;desc&apos;)</span><br><span class="line">            -&gt;take(1)</span><br><span class="line">            -&gt;update([</span><br><span class="line">                &apos;state&apos; =&gt; 1,</span><br><span class="line">                &apos;power&apos; =&gt; 1,</span><br><span class="line">                &apos;sid&apos; =&gt; $insertData[&quot;sid&quot;],</span><br><span class="line">                &apos;id&apos; =&gt; DB::raw(&apos;LAST_INSERT_ID(id)&apos;)</span><br><span class="line">            ]);</span><br><span class="line">        $data = DB::table(&apos;srv&apos;)</span><br><span class="line">                    -&gt;where([</span><br><span class="line">                        [&apos;id&apos;, &apos;=&apos;, DB::raw(&apos;LAST_INSERT_ID()&apos;)],</span><br><span class="line">                        [DB::raw(&apos;ROW_COUNT()&apos;), &apos;&lt;&gt;&apos;, 0]</span><br><span class="line">                    ])</span><br><span class="line">                    -&gt;first();</span><br><span class="line">        if (!$data) &#123;</span><br><span class="line">            return response()-&gt;json([&quot;errno&quot; =&gt; -2], 500);</span><br><span class="line">        &#125;</span><br><span class="line">        return response()-&gt;json([&quot;errno&quot; =&gt; 0, &quot;data&quot; =&gt; $data]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Web-开发/">Web 开发</a>
    </span>
    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/12/23/jQuery(selector).html() 过滤 script tag 的解决方法/"><span>jQuery(selector).html() 过滤 script tag 的解决方法</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/12/23/jQuery(selector).html() 过滤 script tag 的解决方法/" rel="bookmark">
        <time class="entry-date published" datetime="2016-12-23T09:59:20.000Z">
          2016-12-23
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>　　之前用 pjax 做个项目，使用了 .html() 方法将获取到的数据插入 container。但是却发现其会自动过滤 script tag，现找到解决方法 (<a href="http://stackoverflow.com/questions/4079179/jquery-html-strips-out-script-tags" target="_blank" rel="noopener">jquery html() strips out script tags</a>)，在此记录一下<br>　　以下是我应用到项目里的部分代码，对 stackoverflow 的答案多进行了一次判断<br>`<br>    $(document).on(“pjax:end”, function(event, data) {<br>        var responseDom = $(data.responseText);<br>        if (!$(event.target).filter(“script”).length) {<br>            responseDom.filter(‘script’).each(function(){<br>                if (this.src) {<br>                    var script = document.createElement(‘script’), i, attrName, attrValue, attrs = this.attributes;<br>                    for(i = 0; i &lt; attrs.length; i++) {<br>                        attrName = attrs[i].name;<br>                        attrValue = attrs[i].value;<br>                        script[attrName] = attrValue;<br>                    }<br>                    event.target.appendChild(script);<br>                } else {<br>                    $.globalEval(this.text || this.textContent || this.innerHTML || ‘’);<br>                }<br>            });<br>        }<br>    });</p>
<p><code>`</code></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Web-开发/">Web 开发</a>
    </span>
    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/10/27/安装 Laravel，撞墙，采用 Packageist 的中国镜像/"><span>安装 Laravel，撞墙，采用 Packageist 的中国镜像</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/10/27/安装 Laravel，撞墙，采用 Packageist 的中国镜像/" rel="bookmark">
        <time class="entry-date published" datetime="2016-10-26T19:11:00.000Z">
          2016-10-27
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>参考：</p>
<ul>
<li><a href="https://laravel.com/docs/5.2" target="_blank" rel="noopener">https://laravel.com/docs/5.2</a> – 英文手册</li>
</ul>
<ul>
<li><a href="http://laravel-china.org/docs/5.1" target="_blank" rel="noopener">http://laravel-china.org/docs/5.1</a> – 中文手册</li>
</ul>
<ul>
<li><a href="http://pkg.phpcomposer.com/" target="_blank" rel="noopener">http://pkg.phpcomposer.com/</a> – Packagist / Composer 中国全量镜像内（绕过垃圾的墙）</li>
</ul>
<p><strong>安装 Laravel，创建 blog 项目</strong><br>安装方法有两种：</p>
<ol>
<li>全局安装 Laravel Installer，然后用下面的指令创建新项目： laravel new blog</li>
</ol>
<ol start="2">
<li>不安装啥，直接用 Composer 创建新项目：composer create-project –prefer-dist laravel/laravel blog</li>
</ol>
<p>看起来第一种方案比较好，然而：<br>！说明！由于墙的存在，全局安装 Laravel Installer 的方案可能不会成功。</p>
<p><strong>全局安装 Laravel Installer</strong><br>`composer global require “laravel/installer”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">**执行命令**</span><br><span class="line">`laravel new blog</span><br></pre></td></tr></table></figure></p>
<p>悲剧了，出现错误：<br>cURL error 7: Failed to connect to cabinet.laravel.com port 80: Timed out……<br>直接用 Composer 创建 Laravel 项目</p>
<p>参照网上的方案，先执行加速 composer 的执行（用国内的镜像，好人呐！）：<br>`composer config -g repo.packagist composer <a href="https://packagist.phpcomposer.com" target="_blank" rel="noopener">https://packagist.phpcomposer.com</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">然后执行</span><br><span class="line">`composer global require &quot;laravel/installer&quot;</span><br></pre></td></tr></table></figure></p>
<p>创建项目</p>
<p>转载自 <a href="http://blog.sina.com.cn/s/blog_6262a50e0102ws9z.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_6262a50e0102ws9z.html</a>，有删改</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Web-开发/">Web 开发</a>
    </span>
    

    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">下一页</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2018 403 Forbidden
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>