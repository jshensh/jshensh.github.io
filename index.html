<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>博客</title>

  
  <meta name="author" content="403 Forbidden">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="博客"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="博客" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">博客</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/about.html">关于</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2018/08/13/斐讯 N1 折腾记：运行 Linux 及优化/"><span>斐讯 N1 折腾记：运行 Linux 及优化</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/08/13/斐讯 N1 折腾记：运行 Linux 及优化/" rel="bookmark">
        <time class="entry-date published" datetime="2018-08-13T06:16:02.000Z">
          2018-08-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>　　咳咳咳，上篇教程教大家给斐讯 N1 降级并且刷了官改系统，可以当作一个电视盒子和下载机来使用。<br>　　有些小伙伴可能不想把它当作电视盒子，就想把它当作 NAS 或者是服务器，但是总不能拿 Android 玩吧，Android 也不是针对服务器设计的。<br>　　那么我们说过，N1 不仅能刷官改，还能运行 Linux，而且是完整的 Linux 发行版，用 Linux 当服务器、NAS、下载机，包括电视盒子，体验总是要比 Android 好的。<br>　　这篇教程就教大家如何在斐讯 N1 运行 Linux 以及后续的优化，在此之前，需要将你的 N1 降级并刷入 webpad 的官改固件，或者只刷入降级关键分区（感谢群里的小伙伴反馈）。传送门：<a href="/2018/08/12/%E6%96%90%E8%AE%AF%20N1%20%E6%8A%98%E8%85%BE%E8%AE%B0%EF%BC%9A%E9%99%8D%E7%BA%A7%E5%8F%8A%E5%88%B7%E5%85%A5%E5%AE%98%E6%94%B9/">《斐讯N1折腾记：降级及刷入官改》</a></p>
<h2 id="制作-Linux-启动盘"><a href="#制作-Linux-启动盘" class="headerlink" title="制作 Linux 启动盘"></a>制作 Linux 启动盘</h2><p>　　N1 运行 Linux 的原理是通电的时候引导 U 盘里的系统<br>　　所以我们需要准备一个 U 盘来制作启动盘，U 盘大小推荐不低于 8G，连续读写速度推荐达到 30M/s，随机读写速度推荐达到 10M/s。最好是买个全新的，如果是旧的，提前备份好 U 盘内数据。<br>　　N1 运行的 Linux 发行版叫做 Armbian，玩过树莓派的小伙伴应该对这个系统不陌生，是适用于 ARM 架构的 Debian 和 Ubuntu。</p>
<blockquote>
<p><strong>下载地址</strong></p>
<p>Armbian：<br><a href="https://pan.baidu.com/s/1ux7zAF2QYoLWwTTB0Ah5ug" target="_blank" rel="noopener">https://pan.baidu.com/s/1ux7zAF2QYoLWwTTB0Ah5ug</a> 密码：axov<br><a href="https://yadi.sk/d/pHxaRAs-tZiei" target="_blank" rel="noopener">https://yadi.sk/d/pHxaRAs-tZiei</a><br><a href="https://mega.nz/#F!j9QSDQSQ!6WpasOlbZYIInfw6yo4phQ" target="_blank" rel="noopener">https://mega.nz/#F!j9QSDQSQ!6WpasOlbZYIInfw6yo4phQ</a><br><a href="https://share.weiyun.com/5eCvcvS" target="_blank" rel="noopener">https://share.weiyun.com/5eCvcvS</a> （部分搬运）密码：mivmcn<br>启动盘制作工具：<a href="https://www.alexpage.de/usb-image-tool/download/" target="_blank" rel="noopener">https://www.alexpage.de/usb-image-tool/download/</a></p>
</blockquote>
<p>　　里面有好几个版本，下载最新的 5.44 版本，然后选择 kernel_3.14，3.14 内核在 N1 上面使用最好，WiFi、蓝牙都可以正常工作，如果你不需要蓝牙和 WiFi，也可以使用 4.16 版本。</p>
<blockquote>
<p><strong>IMG 文件名含义</strong></p>
<p>例如：<code>Armbian_5.44_S9xxx_Debian_stretch_3.14.29_server_20180601.img</code><br>Armbian：这个就不多说了<br>5.44：Armbian 的版本号<br>S9xxx：适用的 CPU<br>Debian：基于 Debian 编译的，另外还有 Ubuntu。<br>stretch：Debian 或 Ubuntu 的发行版代号，stretch 表示的是 Debian 9。<br>3.14.29：Linux 内核版本号<br>server：桌面环境，Server 代表的是服务器版，没桌面环境，其他的代表的是相应的桌面环境，比如：xfce、mate。<br>20180601：编译日期</p>
</blockquote>
<p>　　小白推荐使用 Ubuntu，桌面环境推荐使用 mate。我推荐使用 Debian Server，做一个真正的服务器。<br>　　下面我会以 Armbian_5.44_S9xxx_Debian_stretch_3.14.29_server_20180601 版为例<br>　　首先格式化你的 U 盘分区格式为 FAT32，推荐最好把 U 盘分区全部删除。<br>　　打开启动盘制作工具：左侧选择你的 U 盘 → 点击 [Restore] → 选择 Linux 镜像文件 → 提示框点击 [是] → 等待制作完成<br>　　制作完成后，会出现一个名为 BOOT 的分区，打开它。如果你把分区全部删除了，BOOT 分区默认是 FAT16 格式，Windows 是不会显示的，可以使用 Ubuntu 来访问。<br>　　把<code>dtb</code>文件夹里的<code>gxl_p230_2g.dtb</code>复制到 BOOT 分区的根目录并重命名为<code>dtb.img</code>。如果是 4.16 内核，dtb 文件是<code>meson-gxl-s905d-p230.dtb</code>。<br>　　将 N1 断电，插上 U 盘、网线，最好是插靠近 HDMI 接口那个 USB 接口，通电开机。<br>　　正常情况下顺利开机并进入 Linux 系统，如果没有进入 Linux 系统而是进入了 Android 系统，ADB 连接至 N1，输入<code>adb shell reboot update</code>。<br>　　接下来的操作我会以 SSH 远程连接为例，如果你使用 HDMI 连接显示器也可以，这种情况推荐你连接一个 USB HUB，方便连接鼠标和键盘，当然，如果你用的是 Server，那么就不需要鼠标了。<br>　　用户：root<br>　　密码：1234<br>　　如何获取 N1 运行 Linux 的 IP？打开 cmd，输入<code>nslookup amlogic</code>，如果<code>amlogic</code>无法解析IP，可以尝试解析<code>aml</code>。<br>　　首次登陆需要重置密码，先输入当前密码（1234），再输入新密码以及确认新密码。<br>　　设置完密码之后会让你新建一个普通用户，如果是使用 Server，直接按 Ctrl + C 跳过。如果是使用桌面版，推荐创建一个普通用户，按照提示操作即可。<br>　　跳过之后，再次使用 SSH 连接。<br>　　这时候，整个系统就可以用了，不过我们需要做一些小工作。</p>
<h2 id="小工作"><a href="#小工作" class="headerlink" title="小工作"></a>小工作</h2><p>　　加载 WiFi 驱动：<code>modprobe dhd &amp;&amp; echo dhd &gt;&gt; /etc/modules</code><br>　　设置时区：<code>echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone &amp;&amp; ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code><br>　　删除默认DNS：<code>rm /etc/resolvconf/resolv.conf.d/head &amp;&amp; touch /etc/resolvconf/resolv.conf.d/head &amp;&amp; systemctl restart network-manager.service</code><br>　　注：在重启系统后，输入<code>cat /etc/resolv.conf</code>，查看返回结果的第一行是否为<code>nameserver 8.8.8.8</code>，如果不是，则表示删除成功，如果是，则再执行一次删除命令。<br>　　停止红外支持：<code>systemctl stop lircd.service lircd-setup.service lircd.socket lircd-uinput.service lircmd.service</code><br>　　删除红外支持：<code>apt remove -y lirc &amp;&amp; apt autoremove -y</code><br>　　N1 没有红外，而且由于红外支持找不到红外，一直给系统日志写错误。<br>　　重启系统：<code>reboot</code><br>　　更新软件包：<code>apt update &amp;&amp; apt upgrade -y</code></p>
<h3 id="挂载外置存储设备"><a href="#挂载外置存储设备" class="headerlink" title="挂载外置存储设备"></a>挂载外置存储设备</h3><p>　　推荐把外置存储设备分区格式化为 ext4 格式，不推荐使用 NTFS 格式。<br>　　如果你的外置存储设备是 NTFS 格式，可以使用<code>mkfs.ext4</code>命令将你的外置存储设备格式化为 ext4 格式，格式化前提前备份数据。<br>　　可以用<code>fdisk -l</code>查看你的外置存储设备是那个设备，一般是<code>/dev/sdb</code>，分区是<code>/dev/sdb1</code>，如果有多个分区，依次类推。<br>　　输入<code>mkfs.ext4 /dev/sdb1</code>将分区格式化为 ext4，格式化完成后使用<code>fdisk -l</code>查看是否格式化成功，如果分区的 Type 属性为 Linux（如下图所示），表示分区为 ext4/3。</p>
<p><a href="/uploads/2018/08/fdisk.png"><img src="/uploads/2018/08/fdisk.png" alt="fdisk"></a></p>
<p>　　格式化成功后，为了方便挂载，可以给分区设置一个卷标。<br>　　命令：<code>e2label</code><br>　　设置卷标示例：<code>e2label /dev/sdb1 H1</code><br>　　查看卷标示例：<code>e2label /dev/sdb1</code><br>　　然后就可以挂载分区了<br>　　挂载分区示例：<code>echo &quot;LABEL=H1 /mnt ext4 defaults,noatime,nodiratime 0 2&quot; &gt;&gt; /etc/fstab</code><br>　　此命令会将卷标为 H1 的分区挂载到 /mnt 目录下<br>　　重启系统使挂载生效</p>
<h3 id="Samba-网络共享"><a href="#Samba-网络共享" class="headerlink" title="Samba 网络共享"></a>Samba 网络共享</h3><p>　　使用 Samba 将外置存储设备共享给其他设备<br>　　Samba 可以使用 Armbian 自带的一个可视化菜单来配置，非常方便。<br>　　启动 Armbian 配置菜单：<code>armbian-config</code><br>　　选择 [Software] → [Softy] → 选中 (空格) [Samba] → 回车 → 输入 samba 用户名和密码 → 工作组填写 WORKGROUP → 等待安装完成<br>　　安装后，它会自动弹出修改配置文件的界面。</p>
<p><a href="/uploads/2018/08/samba.png"><img src="/uploads/2018/08/samba.png" alt="samba"></a></p>
<p>　　将红框里的内容删除<br>　　将 ext 的 path 改为 /mnt，如果你的挂载路径不是 /mnt，则改为你的挂载路径。<br>　　按下 TAB 键 → 选择 [OK] → 保存退出<br>　　Samba 网络共享配置完成</p>
<h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>　　小山觉得，既然斐讯 N1 的定位是 NAS，那么运行 Android 系统是显然满足不了 NAS 这个属性的，只有运行稳定且高效的 Linux 才可以称为 NAS。<br>　　Linux 有着更多的扩展性，你可以在上面任意的折腾，比如搭建个开发环境，Web 服务器等等。<br>　　总而言之，几十块钱买个 N1 这样的玩具，小山觉得是非常值的。<br>　　还是那句话：文章有什么不懂的地方，欢迎在下方或者在QQ群告诉我。<br>　　以后如果我想到 N1 的更多玩法会继续分享给大家的，再次感谢所有为 N1 可玩性付出的人。<br>　　本篇文章参考了以下资料：</p>
<ul>
<li><a href="https://forum.armbian.com/topic/2419-armbian-for-amlogic-s905-and-s905x/" target="_blank" rel="noopener">https://forum.armbian.com/topic/2419-armbian-for-amlogic-s905-and-s905x/</a></li>
<li><a href="http://www.right.com.cn/forum/thread-323198-1-1.html" target="_blank" rel="noopener">http://www.right.com.cn/forum/thread-323198-1-1.html</a></li>
<li><a href="http://www.right.com.cn/forum/thread-326034-1-1.html" target="_blank" rel="noopener">http://www.right.com.cn/forum/thread-326034-1-1.html</a></li>
</ul>
<p>　　转载自 <a href="https://www.mivm.cn/phicomm-n1-linux/" target="_blank" rel="noopener">https://www.mivm.cn/phicomm-n1-linux/</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/斐讯/">斐讯</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/08/13/斐讯 N1 折腾记：运行 Linux 及优化/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/08/12/斐讯 N1 折腾记：降级及刷入官改/"><span>斐讯 N1 折腾记：降级及刷入官改</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/08/12/斐讯 N1 折腾记：降级及刷入官改/" rel="bookmark">
        <time class="entry-date published" datetime="2018-08-12T06:16:54.000Z">
          2018-08-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>　　上个月，斐讯 K2T 首发那天，小山一不小心抢了两台 K2T，这就尴尬了。退了吧，好不容易抢到的，不退吧，我只能激活一台。所以，两台 K2T 我自己用了一台，另一台我准备卖出去。然而一个月过去了，眼看K码就要到期了，还是没有人要。咋办呢，只能再注册个账号来激活这台 K2T，但是首次激活的机会不能浪费啊，所以我又买了 N1 + H1 。<br>　　本来我根本不打算买 N1，因为我觉得这货没啥用，也没怎么关注过它。但是买来之后才发现，这货居然还能刷固件，刷完固件之后就是个电视盒子了，而且还能运行完整的 Linux。<br>　　这就非常耐斯了，我的折腾之心按耐不住了，所以就开始一步步的折腾。<br>　　这篇教程就先教大家给 斐讯 N1 降级以及刷入官改固件（电视盒子），这也是以后折腾的基础。</p>
<h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>　　如果你的 N1 系统版本是 2.19，那么可以直接跳过降级过程，如果是其他版本，请按照下面的方法降级关键分区。<br>　　降级准备：你需要有一根双公头的 USB 数据线，淘宝几块钱包邮，附上小山购买的链接（绝对不是广告）：<a href="https://detail.tmall.com/item.htm?id=13036924933" target="_blank" rel="noopener">https://detail.tmall.com/item.htm?id=13036924933</a><br>　　有些机智的小伙伴可能会说，我主板有 Type-C 接口，我拿手机的 Type-C 数据线，Type-C 这头插主板，A 头插 N1 行不行。<br>　　这个方法是可以的，小山最开始也是这么做的。但是，只能用来降级，刷官改是不行的，这个问题在刷官改步骤会解释。</p>
<ol>
<li>开启 ADB 调试</li>
</ol>
<p>　　非常简单，只需要用鼠标点击斐讯 N1 官方固件的那个版本号 4 次，出现 【ADB调试开启】的字样即可。</p>
<ol start="2">
<li>重启至 fastboot 模式</li>
</ol>
<p>　　如果经常给手机刷机的小伙伴，对这个模式肯定不陌生，也就是我们平常所说的线刷模式。<br>　　这一步需要用到 ADB 调试工具，下载地址：<a href="https://dl.google.com/android/repository/platform-tools-latest-windows.zip" target="_blank" rel="noopener">https://dl.google.com/android/repository/platform-tools-latest-windows.zip</a><br>　　下载完成后解压，然后打开解压后的文件夹。按住 Shift，鼠标右键点击空白处，点击 [在此处打开 Powershell 窗口] 或 [在此处打开 命令提示符 窗口]。<br>　　输入<code>.\adb.exe connect %IP%</code><br>　　将 %IP% 替换为 N1 的 IP，也就是官方固件页面显示的那个 IP。<br>　　示例：<code>.\adb.exe connect 192.168.1.222</code><br>　　如果返回类似<code>connected to 192.168.1.222</code>这样的提示，表示连接成功。<br>　　连接成功后输入<code>.\adb.exe shell reboot fastboot</code>，重启至 fastboot 模式。</p>
<ol start="3">
<li>刷入降级关键分区</li>
</ol>
<p>　　将你的 N1 用双公头 USB 数据线与电脑连接，务必连接至靠近 HDMI 接口的那个 USB 接口，连接后查看设备管理器是否识别出新的硬件，如果新硬件驱动异常，右键新硬件点击 [更新驱动程序]。<br>　　驱动正常后，输入<code>.\fastboot.exe devices</code>查看 fastboot 工具是否已识别设备。<br>　　如果返回类似<code>XXXXXXXXXXXX fastboot</code>这样的提示，表示成功识别。<br>　　注：XXXXX 为序列号<br>　　然后就可以刷入降级分区了，分区文件下载地址：<a href="/uploads/2018/08/N1_V2.19_imgs.zip">N1_V2.19_imgs.zip</a><br>　　将压缩包内的分区文件解压至 ADB 工具包文件夹<br>　　依次输入命令刷入各个分区</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.\fastboot.exe flash boot boot.img</span><br><span class="line">.\fastboot.exe flash bootloader bootloader.img</span><br><span class="line">.\fastboot.exe flash recovery recovery.img</span><br></pre></td></tr></table></figure>
<p>　　如果没有返回任何错误信息，表示降级成功。<br>　　输入<code>.\fastboot.exe reboot</code>重启设备<br>　　至此，降级步骤就完成了，可以放心的刷官改固件了。<br>　　可能有些小伙伴会说，系统版本哪里显示的不是 2.19 啊。这个降级并不是降级系统，而是降级引导等关键分区，所以系统版本哪里不会变的。</p>
<h2 id="刷入官改"><a href="#刷入官改" class="headerlink" title="刷入官改"></a>刷入官改</h2><p>　　这一步比较危险和麻烦，也正是因为这一步困扰了小山好久。<br>　　上面我说了，小山试过用 Type-C 数据线刷官改，但是没成功，为什么呢？<br>　　问题不是出在 Type-C 上面，而是出在那个垃圾烧录工具的驱动上面（<del>国产芯片的烧录工具，你们懂的</del>）。<br>　　那个烧录工具的驱动程序虽然可以兼容 Windows 10，但是缺兼容不了最新 CPU 平台。<br>　　小山用的是 Ryzen 平台，B350 主板，但是小山各种方法都试过了，插上去它就是识别不了。后来小山把以前的旧电脑拿出来，同一个系统环境，旧电脑插上去就识别了。所以我认为是那个驱动不支持最新的CPU平台，当然，我这里只测试了 Ryzen，酷睿系列没测试，但是我估计，酷睿 7 8 系也都不支持，如果有用酷睿新平台的小伙伴成功了记得在下面留言告诉我。<br>　　所以说，这一步，如果你用的是 Ryzen 平台，那么还是去找一台比较旧的电脑吧。<br>　　注：小山并没有看不起国产芯片，以上言论只针对晶晨USB烧录工具。<br>　　首先下载USB烧录工具，下载地址：<a href="/uploads/2018/08/USB_Burning_Tool_v2.1.6.zip">USB_Burning_Tool_v2.1.6.zip</a><br>　　安装的时候记得创建桌面快捷方式，安装最后的驱动安装一定不要跳过。<br>　　另外小山找到了一个 Linux 版本的烧录工具，但没来得及测试，有兴趣的小伙伴可以试一试：<a href="http://forum.khadas.com/t/burning-tools-for-linux-pc/1832" target="_blank" rel="noopener">http://forum.khadas.com/t/burning-tools-for-linux-pc/1832</a><br>　　安装完成后还有个小工作要做</p>
<blockquote>
<p><strong>小工作</strong></p>
<p>打开设备管理器<br>随便点击一个硬件<br>点击 [操作] 菜单 → [添加过时硬件] → 下一步 → 选择 [安装我手动从列表选择的硬件] → 下一步 → 选择 [libusb-win32 Usb Devices] → 下一步 →  选择 [WorldCup Device] → 下一步 →  下一步 → 完成<br><a href="/uploads/2018/08/Burning_Tool_Driver.png"><img src="/uploads/2018/08/Burning_Tool_Driver.png" alt="Burning Tool 驱动"></a><br>小工作做完之后，那个USB烧录工具才可以正常工作。</p>
</blockquote>
<p>　　官改固件我推荐刷 webpad 的官改固件，集成度高，也很好用，自带 Google 服务、Root、Xposed 框架、离线下载等常用软件。下载地址：<a href="http://www.right.com.cn/forum/thread-322736-1-1.html" target="_blank" rel="noopener">http://www.right.com.cn/forum/thread-322736-1-1.html</a><br>　　如果只是想当一个电视盒子用的，也可以刷 YYFROM 的语音版固件，下载地址：<a href="http://www.yyfrom.com/cms/yyfrom/product/2018-4-9/156.html" target="_blank" rel="noopener">http://www.yyfrom.com/cms/yyfrom/product/2018-4-9/156.html</a><br>　　下载你喜欢的官改固件，解压压缩包，得到 img 文件。<br>　　打开 USB_Burning_Tool → 点击 [文件] 菜单 → 导入烧录包 → 选择官改固件的 img 文件 → 等待校验完成<br>　　<strong>校验完成后，一定要去除勾选右边烧录配置的 [擦除flash] 和 [擦除bootloader]，否则会报错。</strong></p>
<p><a href="/uploads/2018/08/Burning_Tool_01.png"><img src="/uploads/2018/08/Burning_Tool_01.png" alt="Burning Tool"></a></p>
<p>　　然后点击烧录工具的 【开始】，这时候，工具就进入了待命状态。<br>　　首先将 N1 彻底断电，然后用双公头 USB 数据线连接电脑，然后接通电源。<br>　　如果不出意外，工具应该会识别出 N1 并且开始烧录。<br>　　如果没有识别出 N1，而 N1 直接进入了系统。使用 ADB 连接 N1（方法见上），输入<code>.\adb.exe shell reboot update</code>重启至刷机模式，应该就可以正常识别了。<br>　　小山懒得再搬出旧电脑了，这里的截图借用别人的。</p>
<p><a href="/uploads/2018/08/Burning_Tool_02.png"><img src="/uploads/2018/08/Burning_Tool_02.png" alt="Burning Tool"></a></p>
<p>　　等待上方那个紫色的进度条变绿，提示烧录成功，这时候不要着急拔掉 N1，先点击烧录工具的 【停止】，再关闭烧录工具，然后拔掉 N1，断电，通电开机。<br>　　首次启动大约需要 3-4 分钟，请耐心等待。<br>　　系统启动后，会提示遥控器配对，因为用了 T1 的一些东西，直接跳过即可。<br>　　然后联网，安装一些直播、点播视频应用，就可以完完整整的当一个电视盒子来用了。<br>　　操控方面，可以使用天天链里的遥控器，也可以自己买个蓝牙遥控器，这个看个人喜好。<br>　　如果你刷了 webpad 的固件，在浏览器输入 IP:8081，既可管理离线下载、samba等软件。具体用法我就不多说了。</p>
<h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>　　斐讯 N1 现在二手平台仅卖 70 元，但 N1 的配置是跟那些两三百的电视盒子不相上下的，可谓是非常的有性价比。<br>　　如果你想入手一个电视盒子，或者是想买一个类似树莓派的玩具（不搞硬件开发）。那么可以考虑下 N1，做电视盒子绰绰有余，运行 Linux 后，就是一个没有硬件扩展性的树莓派，当然，我相信大多数人买树莓派是搞软件开发的。<br>　　这是我目前觉得斐讯最有性价比的产品之一<br>　　再次感谢 <a href="http://www.right.com.cn/forum/?4478" target="_blank" rel="noopener">webpad</a> 为 N1 可玩性做出的贡献<br>　　下篇教程教大家如何在 N1 上运行完整的 Linux 发行版</p>
<p>　　转载自 <a href="https://www.mivm.cn/phicomm-n1-unofficial/" target="_blank" rel="noopener">https://www.mivm.cn/phicomm-n1-unofficial/</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/斐讯/">斐讯</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/08/12/斐讯 N1 折腾记：降级及刷入官改/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/07/12/流水账记录下 Centos 7 配置 frp 服务端与客户端的全过程/"><span>流水账记录下 Centos 7 配置 frp 服务端与客户端的全过程</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/07/12/流水账记录下 Centos 7 配置 frp 服务端与客户端的全过程/" rel="bookmark">
        <time class="entry-date published" datetime="2018-07-12T00:51:43.000Z">
          2018-07-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>下载 frp：<a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">https://github.com/fatedier/frp/releases</a>，解压到 <code>/usr/local/frp</code> 目录下</p>
<p><strong>服务端：</strong><br>编辑四个文件：<br>/usr/local/frp/frps_full.ini（配置文件，视情况编辑）</p>
<p>/usr/lib/systemd/system/frps.service<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=frps</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/etc/cron.hourly/frps</span><br><span class="line">ExecReload=/usr/bin/frpsreload</span><br><span class="line">ExecStop=/usr/bin/killall frps</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></p>
<p>/etc/cron.hourly/frps<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/sh</span><br><span class="line">echo $(date +"%Y-%m-%d %H:%M:%S") &gt; /tmp/frpTimestamp</span><br><span class="line">ps aux | grep "frps -c" | grep -v grep</span><br><span class="line">if [ $? -ne 0 ];then</span><br><span class="line">    nohup /usr/local/frp/frps -c /usr/local/frp/frps_full.ini &gt;&gt; /root/frp.log 2&gt;&amp;1 &amp; echo $! &gt; /var/run/frp-server.pid</span><br><span class="line">fi;</span><br></pre></td></tr></table></figure></p>
<p>/usr/bin/frpsreload<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/sh</span><br><span class="line">kill -9 $(cat /var/run/frp-server.pid)</span><br><span class="line">nohup /usr/local/frp/frps -c /usr/local/frp/frps_full.ini &gt;&gt; /root/frp.log 2&gt;&amp;1 &amp; echo $! &gt; /var/run/frp-server.pid</span><br></pre></td></tr></table></figure></p>
<p>然后执行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl frps enable</span><br><span class="line">service frps start</span><br></pre></td></tr></table></figure></p>
<p>最后是 nginx 反代设置：<br>/usr/local/nginx/conf/vhost/pi.imjs.0cdn.cn.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  pi.imjs.0cdn.cn *.pi.imjs.0cdn.cn;</span><br><span class="line"> </span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass        http://127.0.0.1:8080;</span><br><span class="line">        proxy_set_header  X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header  Host $host:8080;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>客户端：</strong><br>编辑四个文件：<br>/usr/local/frp/frpc_full.ini（配置文件，视情况编辑）</p>
<p>/usr/lib/systemd/system/frp.service<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=frp</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/etc/cron.hourly/frp</span><br><span class="line">ExecReload=/usr/bin/frpreload</span><br><span class="line">ExecStop=killall frp</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure></p>
<p>/etc/cron.hourly/frp<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/sh</span><br><span class="line">echo $(date +"%Y-%m-%d %H:%M:%S") &gt; /tmp/frpTimestamp</span><br><span class="line">ps aux | grep "frp -c" | grep -v grep</span><br><span class="line">if [ $? -ne 0 ];then</span><br><span class="line">    ntpdate ntp1.aliyun.com &amp;&amp; (nohup /usr/local/frp/frpc -c /usr/local/frp/frpc_full.ini &gt;&gt; /root/frp.log 2&gt;&amp;1 &amp; echo $! &gt; /var/run/frp-client.pid)</span><br><span class="line">fi;</span><br></pre></td></tr></table></figure></p>
<p>/usr/bin/frpreload<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/sh</span><br><span class="line">kill -9 $(cat /var/run/frp-client.pid)</span><br><span class="line">nohup /usr/local/frp/frpc -c /usr/local/frp/frpc_full.ini &gt;/dev/null 2&gt;&amp;1 &amp; echo $! &gt; /var/run/frp-client.pid</span><br></pre></td></tr></table></figure></p>
<p>最后执行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl frp enable</span><br><span class="line">service frp start</span><br></pre></td></tr></table></figure></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/VPS-技术/">VPS 技术</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/07/12/流水账记录下 Centos 7 配置 frp 服务端与客户端的全过程/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/11/19/清除windows访问Samba的访问记录/"><span>清除windows访问Samba的访问记录</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/11/19/清除windows访问Samba的访问记录/" rel="bookmark">
        <time class="entry-date published" datetime="2017-11-19T00:45:01.000Z">
          2017-11-19
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>在 windows 中访问 Samba 服务器后，windows 会存储访问记录，比如密码。当我们想清除密码，重新输入时，步骤如下：<br><strong>1. 获取访问记录</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#在windows的命令行(cmd)中运行net use，可见访问Samba服务器的记录：</span><br><span class="line">C:\Users\User&gt;net use</span><br><span class="line">会记录新的网络连接。 </span><br><span class="line">状态       本地        远程                      网络</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">OK                     \\192.168.2.1\IPC$         Microsoft Windows Network</span><br><span class="line">命令成功完成。</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 删除访问记录</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\User&gt;net use \\192.168.2.1\IPC$ /del /y</span><br><span class="line"> \\192.168.2.1\IPC$ 已经删除。</span><br></pre></td></tr></table></figure></p>
<p><strong>3. 尝试重新登陆Samba</strong></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/openwrt/">openwrt</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2017/11/19/清除windows访问Samba的访问记录/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/11/04/斐讯 K3 流光金开箱与 TTL 刷 LEDE 教程（适用于 v21.5.39.260 系统）/"><span>斐讯 K3 流光金开箱与 TTL 刷 LEDE 教程（适用于 v21.5.39.260 系统）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/11/04/斐讯 K3 流光金开箱与 TTL 刷 LEDE 教程（适用于 v21.5.39.260 系统）/" rel="bookmark">
        <time class="entry-date published" datetime="2017-11-04T10:40:13.000Z">
          2017-11-04
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><strong>注意：V21.5.39.260 集成的 CFE 编译日期为 8月2日，斐讯封堵了 CFE 网页执行命令，而且固件采用公私钥验证，除了 TTL 手动执行命令基本无法刷入其他固件（<a href="http://www.right.com.cn/forum/thread-212725-1-1.html" target="_blank" rel="noopener">斐讯K3 官方固件root版本 安装插件 entware </a>）</strong></p>
<p><strong>本文分四段：开箱，拆机加 TTL，CFE 刷官改固件，网页刷 LEDE 固件</strong></p>
<p><strong>在刷入 LEDE 固件之前，不要给 k3 连网！避免自动升级！<br>在刷入 LEDE 固件之前，不要给 k3 连网！避免自动升级！<br>在刷入 LEDE 固件之前，不要给 k3 连网！避免自动升级！</strong></p>
<p>11 月 1 号 K3 流光金首发送贼快的闪迪 U 盘，趁活动入了两台：<br><a href="/uploads/2017/11/QQ截图20171105012114.png"><img src="/uploads/2017/11/QQ截图20171105012114.png" alt=""></a></p>
<p>先上购买链接：</p>
<ul>
<li>斐讯K3流光金 AC3150：<a href="http://t.cn/RWIdtzy" target="_blank" rel="noopener">https://item.jd.com/5428209.html</a></li>
</ul>
<ul>
<li>斐讯K3星空银 AC3150：<a href="http://t.cn/RO955lB" target="_blank" rel="noopener">https://item.jd.com/3959251.html</a></li>
</ul>
<p>到手开箱全家福：<br><a href="/uploads/2017/11/20171102_120516.jpg"><img src="/uploads/2017/11/20171102_120516-1024x768.jpg" alt=""></a></p>
<p>四网口 + USB 3.0：<br><a href="/uploads/2017/11/20171102_120552.jpg"><img src="/uploads/2017/11/20171102_120552-768x1024.jpg" alt=""></a></p>
<p>整机照：<br><a href="/uploads/2017/11/20171102_121232.jpg"><img src="/uploads/2017/11/20171102_121232-768x1024.jpg" alt=""></a></p>
<p>mmp 的系统版本 v21.5.39.260：<br><a href="/uploads/2017/11/QQ截图20171102121540.png"><img src="/uploads/2017/11/QQ截图20171102121540.png" alt=""></a></p>
<p>嗯废话说完，先给各位拆个机</p>
<p>第一步先扯下底部脚垫，卸下四个螺丝。注意这里有保修易碎贴，如果还要保修的话，拿电吹风吹下挑开：<br><a href="/uploads/2017/11/20171104_154507.jpg"><img src="/uploads/2017/11/20171104_154507-768x1024.jpg" alt=""></a></p>
<p>第二步从如图位置插入塑料卡片撬开两侧侧面面板。最好不要用美工刀、钢尺等锐利的物品操作，会留下撬痕：<br><a href="/uploads/2017/11/20171104_155201.jpg"><img src="/uploads/2017/11/20171104_155201-768x1024.jpg" alt=""></a></p>
<p>第三步拆开侧面面板，轻轻取下上方天线（注意侧面有卡扣，把塑料外壳往外掰一下就可以取出来了），取下后搁在上面就行，目的是为了卸螺丝。<br><a href="/uploads/2017/11/20171104_155356.jpg"><img src="/uploads/2017/11/20171104_155356-1024x768.jpg" alt=""></a></p>
<p>第四步卸下固定两块主板用的八颗螺丝（在螺丝边上上胶的家伙我谢谢你全家）：</p>
<p><a href="/uploads/2017/11/20171104_160635.jpg"><img src="/uploads/2017/11/20171104_160635-1024x768.jpg" alt=""></a></p>
<p><a href="/uploads/2017/11/20171104_164950.jpg"><img src="/uploads/2017/11/20171104_164950-768x1024.jpg" alt=""></a></p>
<p>第五步在下方主板的右侧 TX RX GND 塞 TTL 线并固定（如果要保修的话，不要固定，我是为了方便以后刷机）我用的热熔胶，如果希望牢固一点的话可以用焊锡。线可以从边上散热孔引出：<br><a href="/uploads/2017/11/20171104_165104.jpg"><img src="/uploads/2017/11/20171104_165104-768x1024.jpg" alt=""></a></p>
<p><a href="/uploads/2017/11/20171104_185431.jpg"><img src="/uploads/2017/11/20171104_185431-768x1024.jpg" alt=""></a></p>
<p>第六步接 TTL 小板调试（TX 接 RXD，RX 接 TXD，GND 接 GND），115200，如果有输出，就是正常的：<br><a href="/uploads/2017/11/20171104_171541.jpg"><img src="/uploads/2017/11/20171104_171541-768x1024.jpg" alt=""></a></p>
<p>最后合上侧面面板：<br><a href="/uploads/2017/11/20171104_191757.jpg"><img src="/uploads/2017/11/20171104_191757-1024x768.jpg" alt=""></a></p>
<p>PS 最后找公司的硬件工程师帮忙把引出的线改成了座儿，用热熔胶固定在了散热口：<br><a href="/uploads/2017/11/20171105_222222.jpg"><img src="/uploads/2017/11/20171105_222222-768x1024.jpg" alt=""></a></p>
<p><a href="/uploads/2017/11/20171105_231846.jpg"><img src="/uploads/2017/11/20171105_231846-768x1024.jpg" alt=""></a></p>
<p>有了 TTL，我们需要先刷入破解了 root 的官改固件并降级，为刷入 LEDE 固件做准备：</p>
<p>以下是需要的软件：</p>
<ul>
<li>Tftpd：<a href="http://tftpd32.jounin.net/" target="_blank" rel="noopener">http://tftpd32.jounin.net/</a></li>
</ul>
<ul>
<li>官改固件下载：<a href="/uploads/2017/11/k3_root.zip">k3_root</a></li>
</ul>
<ul>
<li>低版本 mtd6 镜像下载：<a href="/uploads/2017/11/K3-linux-partition-mtd6.zip">K3-linux-partition-mtd6</a></li>
</ul>
<p>第一步下载固件，安装运行 Tftpd 工具。使用网线连接至 k3 上，设置静态 IP 192.168.2.100，网关 192.168.2.1，将 Tftpd 中的目录切换到你存放解压出来的固件目录，并切换网卡（应该是 192.168.2.100，我因为刷机后截的图地址不一样）：<br><a href="/uploads/2017/11/QQ图片20171105020419.png"><img src="/uploads/2017/11/QQ图片20171105020419.png" alt=""></a></p>
<p>第二步给路由器断电，连接 TTL，捅 Reset 通电开机，如果成功进入 CFE 会出现下一步图中以 CFE&gt; 开头的界面</p>
<p>第三步输入命令，CFE 会拉取你本机上的固件：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flash -noheader 192.168.2.100:/k3_root.bin nflash0.trx</span><br></pre></td></tr></table></figure></p>
<p><a href="/uploads/2017/11/QQ图片20171105020442.jpg"><img src="/uploads/2017/11/QQ图片20171105020442.jpg" alt=""></a></p>
<p>第四步等写入完成后输入 reboot 重启</p>
<p>第五步在 TTL 输入以下命令，将 mtd6 镜像拉至路由器上并写入（<strong>镜像大小 44M，刷写时间比较长，大约需要 20 ~ 30 分钟（尽量多等一段时间），刷写过程中不要断开路由器的电源或拔网线，以免变砖！！！</strong>）：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd /tmp</span><br><span class="line">tftp -g -l K3-linux-partition-mtd6.img -r K3-linux-partition-mtd6.img 192.168.2.100</span><br><span class="line">cat /tmp/K3-linux-partition-mtd6.img &gt; /dev/mtd6</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure></p>
<p>最后进入功能设置 –&gt; 手动升级看到如图系统版本就说明成功了<br><a href="/uploads/2017/11/QQ图片20171105021238.png"><img src="/uploads/2017/11/QQ图片20171105021238.png" alt=""></a></p>
<p>随后开始刷 LEDE</p>
<p>固件下载：</p>
<ul>
<li>基础包（无密码）：<a href="/uploads/2017/11/lede-bcm53xx-phicomm-k3-squashfs-factory.zip">lede-bcm53xx-phicomm-k3-squashfs-factory</a></li>
</ul>
<ul>
<li>升级包（默认登录密码是 password）：<a href="/uploads/2017/11/LEDE-17.01.2-R7.3.2-bcm53xx-phicomm-k3-squashfs.rar">LEDE-17.01.2-R7.3.2-bcm53xx-phicomm-k3-squashfs</a></li>
</ul>
<p>第一步刷入基础包，进入功能设置 –&gt; 手动升级，上传：<br><a href="/uploads/2017/11/QQ图片20171105021247.png"><img src="/uploads/2017/11/QQ图片20171105021247.png" alt=""></a></p>
<p><a href="/uploads/2017/11/QQ图片20171105022757.png"><img src="/uploads/2017/11/QQ图片20171105022757.png" alt=""></a></p>
<p>第二步打开 192.168.1.1，进入 System –&gt; Backup / Flash Firmware，上传升级包固件<br><a href="/uploads/2017/11/QQ图片20171105023217.png"><img src="/uploads/2017/11/QQ图片20171105023217.png" alt=""></a></p>
<p>最后重启完成，重新打开 192.168.1.1，使用 root / password 登录即可：<br><a href="/uploads/2017/11/QQ截图20171105022906.png"><img src="/uploads/2017/11/QQ截图20171105022906.png" alt=""></a></p>
<p>该固件带屏幕驱动，感谢 Lean 大的无私奉献！<br><a href="/uploads/2017/11/20171105_011645.jpg"><img src="/uploads/2017/11/20171105_011645-711x1024.jpg" alt=""></a></p>
<p>参考以下文章：</p>
<ol>
<li>拆机部分：<a href="http://www.xinxunwei.com/wxjs/qtcjjc/2017/0327/7300.html" target="_blank" rel="noopener">斐讯路由器怎么样？斐讯K3拆机图解</a></li>
</ol>
<ol start="2">
<li>官改固件：<a href="http://www.right.com.cn/forum/thread-212725-1-1.html" target="_blank" rel="noopener">斐讯K3 官方固件root版本 安装插件 entware</a></li>
</ol>
<ol start="3">
<li>固件降级：<a href="http://koolshare.cn/thread-95398-1-2.html" target="_blank" rel="noopener">K3原厂固件从217版降级212版方法</a></li>
</ol>
<ol start="4">
<li>Lean 大 LEDE：<a href="http://www.right.com.cn/forum/thread-214087-1-1.html" target="_blank" rel="noopener">斐讯 K3 OPENWRT LEDE R7.3  固件，Adbyby Plus，潘多拉多拨，S…</a></li>
</ol>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/openwrt/">openwrt</a>, <a href="/categories/openwrt/斐讯/">斐讯</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2017/11/04/斐讯 K3 流光金开箱与 TTL 刷 LEDE 教程（适用于 v21.5.39.260 系统）/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/10/28/PHP无限级分类实现（递归+非递归）/"><span>PHP无限级分类实现（递归+非递归）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/10/28/PHP无限级分类实现（递归+非递归）/" rel="bookmark">
        <time class="entry-date published" datetime="2017-10-28T04:21:16.000Z">
          2017-10-28
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by PhpStorm.</span></span><br><span class="line"><span class="comment"> * User: qishou</span></span><br><span class="line"><span class="comment"> * Date: 15-8-2</span></span><br><span class="line"><span class="comment"> * Time: 上午12:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//准备数组，代替从数据库中检索出的数据(共有三个必须字段id,name,pid)</span></span><br><span class="line">header(<span class="string">"content-type:text/html;charset=utf-8"</span>);</span><br><span class="line">$categories = <span class="keyword">array</span>(</span><br><span class="line">    <span class="keyword">array</span>(<span class="string">'id'</span>=&gt;<span class="number">1</span>,<span class="string">'name'</span>=&gt;<span class="string">'电脑'</span>,<span class="string">'pid'</span>=&gt;<span class="number">0</span>),</span><br><span class="line">    <span class="keyword">array</span>(<span class="string">'id'</span>=&gt;<span class="number">2</span>,<span class="string">'name'</span>=&gt;<span class="string">'手机'</span>,<span class="string">'pid'</span>=&gt;<span class="number">0</span>),</span><br><span class="line">    <span class="keyword">array</span>(<span class="string">'id'</span>=&gt;<span class="number">3</span>,<span class="string">'name'</span>=&gt;<span class="string">'笔记本'</span>,<span class="string">'pid'</span>=&gt;<span class="number">1</span>),</span><br><span class="line">    <span class="keyword">array</span>(<span class="string">'id'</span>=&gt;<span class="number">4</span>,<span class="string">'name'</span>=&gt;<span class="string">'台式机'</span>,<span class="string">'pid'</span>=&gt;<span class="number">1</span>),</span><br><span class="line">    <span class="keyword">array</span>(<span class="string">'id'</span>=&gt;<span class="number">5</span>,<span class="string">'name'</span>=&gt;<span class="string">'智能机'</span>,<span class="string">'pid'</span>=&gt;<span class="number">2</span>),</span><br><span class="line">    <span class="keyword">array</span>(<span class="string">'id'</span>=&gt;<span class="number">6</span>,<span class="string">'name'</span>=&gt;<span class="string">'功能机'</span>,<span class="string">'pid'</span>=&gt;<span class="number">2</span>),</span><br><span class="line">    <span class="keyword">array</span>(<span class="string">'id'</span>=&gt;<span class="number">7</span>,<span class="string">'name'</span>=&gt;<span class="string">'超级本'</span>,<span class="string">'pid'</span>=&gt;<span class="number">3</span>),</span><br><span class="line">    <span class="keyword">array</span>(<span class="string">'id'</span>=&gt;<span class="number">8</span>,<span class="string">'name'</span>=&gt;<span class="string">'游戏本'</span>,<span class="string">'pid'</span>=&gt;<span class="number">3</span>),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*======================非递归实现========================*/</span></span><br><span class="line">$tree = <span class="keyword">array</span>();</span><br><span class="line"><span class="comment">//第一步，将分类id作为数组key,并创建children单元</span></span><br><span class="line"><span class="keyword">foreach</span>($categories <span class="keyword">as</span> $category)&#123;</span><br><span class="line">    $tree[$category[<span class="string">'id'</span>]] = $category;</span><br><span class="line">    $tree[$category[<span class="string">'id'</span>]][<span class="string">'children'</span>] = <span class="keyword">array</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二步，利用引用，将每个分类添加到父类children数组中，这样一次遍历即可形成树形结构。</span></span><br><span class="line"><span class="keyword">foreach</span>($tree <span class="keyword">as</span> $key=&gt;$item)&#123;</span><br><span class="line">    <span class="keyword">if</span>($item[<span class="string">'pid'</span>] != <span class="number">0</span>)&#123;</span><br><span class="line">        $tree[$item[<span class="string">'pid'</span>]][<span class="string">'children'</span>][] = &amp;$tree[$key];<span class="comment">//注意：此处必须传引用否则结果不对</span></span><br><span class="line">        <span class="keyword">if</span>($tree[$key][<span class="string">'children'</span>] == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">unset</span>($tree[$key][<span class="string">'children'</span>]); <span class="comment">//如果children为空，则删除该children元素（可选）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">////第三步，删除无用的非根节点数据</span></span><br><span class="line"><span class="keyword">foreach</span>($tree <span class="keyword">as</span> $key=&gt;$category)&#123;</span><br><span class="line">    <span class="keyword">if</span>($category[<span class="string">'pid'</span>] != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">unset</span>($tree[$key]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print_r($tree);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*======================递归实现========================*/</span></span><br><span class="line">$tree = $categories;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_attr</span><span class="params">($a,$pid)</span></span>&#123;</span><br><span class="line">    $tree = <span class="keyword">array</span>();                                <span class="comment">//每次都声明一个新数组用来放子元素</span></span><br><span class="line">    <span class="keyword">foreach</span>($a <span class="keyword">as</span> $v)&#123;</span><br><span class="line">        <span class="keyword">if</span>($v[<span class="string">'pid'</span>] == $pid)&#123;                      <span class="comment">//匹配子记录</span></span><br><span class="line">            $v[<span class="string">'children'</span>] = get_attr($a,$v[<span class="string">'id'</span>]); <span class="comment">//递归获取子记录</span></span><br><span class="line">            <span class="keyword">if</span>($v[<span class="string">'children'</span>] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">unset</span>($v[<span class="string">'children'</span>]);             <span class="comment">//如果子元素为空则unset()进行删除，说明已经到该分支的最后一个元素了（可选）</span></span><br><span class="line">            &#125;</span><br><span class="line">            $tree[] = $v;                           <span class="comment">//将记录存入新数组</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $tree;                                  <span class="comment">//返回新数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;"</span>;</span><br><span class="line"></span><br><span class="line">print_r(get_attr($tree,<span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p>转载自 <a href="http://blog.csdn.net/qishouzhang/article/details/47204359" target="_blank" rel="noopener">http://blog.csdn.net/qishouzhang/article/details/47204359</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Web-开发/">Web 开发</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2017/10/28/PHP无限级分类实现（递归+非递归）/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/03/20/aria2配置示例/"><span>aria2配置示例</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/03/20/aria2配置示例/" rel="bookmark">
        <time class="entry-date published" datetime="2017-03-20T07:16:30.000Z">
          2017-03-20
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>其实面对man的存在，写什么总结完全没有必要，一切宝藏都在<a href="http://aria2.sourceforge.net/manual/en/html/aria2c.html" target="_blank" rel="noopener">manual</a>。不过反正不会有人会读就是了。那我就写一下吧</p>
<p>##基础<br>首先，aria2或者叫做aria2c，它是一个下载器，嗯。<br>常用的两种模式是直接下载，比如 aria2c “<a href="http://host/file.zip&quot;" target="_blank" rel="noopener">http://host/file.zip&quot;</a> 这样，当它完成后就退出了，就像wget（估计你们也不知道吧）那样。<br>另一种就是rpc server模式，特点就是，它启动之后什么都不干，然后等着从rpc接口添加任务，下载完也不退出，而是一直等着。对，就像迅雷干的那样，当然，它不会上传你硬盘上的数据。<br>因为第一种方式要每次都敲命令，除非像我是原生nix，没有命令行就没法用电脑，估计也没什么用，于是常用的就是第二种。一般启动命令是 aria2c –enable-rpc –rpc-listen-all=true –rpc-allow-origin-all -c -D 。但是，其实*这个命令是不好的！不要使用这种启动方式。<br>首先，用命令方式导致配置不方便修改保存，-D导致无法看到出错信息。<br><strong>推荐启动方式是使用配置文件</strong> $HOME/.aria2/aria2.conf 。嗯，我知道路由上这个地址是无法修改或者重启后会丢失的，那么你可以放到别的地方，然后 aria2c –conf-path= 注意  填完整路径，因为鬼知道这个程序是从那个路径启动的。-D (用于后台执行, 这样ssh断开连接后程序不会退出） 只有在确认OK之后在启动脚本中使用。</p>
<p><strong>以下方案都基于配置文件方式</strong></p>
<p>##图形界面<br>aria2是没有图形界面的，已知相对好用的图形界面有：</p>
<ul>
<li><a href="https://github.com/binux/yaaw" target="_blank" rel="noopener">binux/yaaw</a></li>
</ul>
<ul>
<li><a href="https://github.com/ziahamza/webui-aria2" target="_blank" rel="noopener">ziahamza/webui-aria2</a></li>
</ul>
<p><strong>请使用chrome，firefox等现代浏览器访问</strong>。这两个东西都可以直接使用，除了看英文不爽以外，有什么必要下载回来使用？（吐槽：难道你们就不觉得webui-aria2的title总是被压成好几行，诡异的配色（对，说的就是那个蓝色背景，深蓝颜色的 Use custom IP and port settings 按钮）不难看吗？）<br>图形界面基本都基于RPC模式，所以一定<strong>确定开启了RPC，IP端口可访问，并且在管理器中填写了正确的地址</strong>。</p>
<p>##配置<br><strong>请将所有配置置于配置文件中<br>只有在确认配置无误后再加上 -D 选项<br>请阅读出错信息!</strong></p>
<p>###RPC<br>需要1.14及以上版本<br><a href="http://aria2.sourceforge.net/manual/en/html/aria2c.html#rpc-options" target="_blank" rel="noopener">http://aria2.sourceforge.net/manual/en/html/aria2c.html#rpc-options</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#允许rpc</span><br><span class="line">enable-rpc=true</span><br><span class="line">#允许所有来源, web界面跨域权限需要</span><br><span class="line">rpc-allow-origin-all=true</span><br><span class="line">#允许非外部访问</span><br><span class="line">rpc-listen-all=true</span><br><span class="line">#RPC端口, 仅当默认端口被占用时修改</span><br><span class="line">#rpc-listen-port=6800</span><br></pre></td></tr></table></figure></p>
<p>如果启动时出现 Initializing EpollEventPoll failed. 或相似错误, 在配置中加上 event-poll=select</p>
<p><strong>使用token验证（建议使用，需要1.18.4以上版本，帐号密码方式将在后续版本中停用！）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># token验证</span><br><span class="line">rpc-secret=secret</span><br></pre></td></tr></table></figure></p>
<p>在YAAW中使用 <a href="http://token:secret@hostname:port/jsonrpc" target="_blank" rel="noopener">http://token:secret@hostname:port/jsonrpc</a> 的地址格式设置secret.<br>如果需要使用密码验证（需要1.15.2以上，1.18.6以下版本）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#用户名</span><br><span class="line">rpc-user=username</span><br><span class="line">#密码</span><br><span class="line">rpc-passwd=passwd</span><br></pre></td></tr></table></figure></p>
<p>在YAAW中使用 <a href="http://username:passwd@hostname:port/jsonrpc" target="_blank" rel="noopener">http://username:passwd@hostname:port/jsonrpc</a> 的地址格式设置密码.<br>对于RPC模式来说, 界面和后端是分离的, 只要给后端设置密码即可. 前端认证什么的是毫无意义的.<br>如果你比较新潮, 在YAAW中也可以用 ws:// 为前缀,只用websocket连接aria2c, 如果你不知道websocket是什么. 那就算了.</p>
<p>###速度相关<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#最大同时下载数(任务数), 路由建议值: 3</span><br><span class="line">max-concurrent-downloads=5</span><br><span class="line">#断点续传</span><br><span class="line">continue=true</span><br><span class="line">#同服务器连接数</span><br><span class="line">max-connection-per-server=5</span><br><span class="line">#最小文件分片大小, 下载线程数上限取决于能分出多少片, 对于小文件重要</span><br><span class="line">min-split-size=10M</span><br><span class="line">#单文件最大线程数, 路由建议值: 5</span><br><span class="line">split=10</span><br><span class="line">#下载速度限制</span><br><span class="line">max-overall-download-limit=0</span><br><span class="line">#单文件速度限制</span><br><span class="line">max-download-limit=0</span><br><span class="line">#上传速度限制</span><br><span class="line">max-overall-upload-limit=0</span><br><span class="line">#单文件速度限制</span><br><span class="line">max-upload-limit=0</span><br><span class="line">#断开速度过慢的连接</span><br><span class="line">#lowest-speed-limit=0</span><br><span class="line">#验证用，需要1.16.1之后的release版本</span><br><span class="line">#referer=*</span><br></pre></td></tr></table></figure></p>
<p>###进度保存相关<br>aria2c只有在正常退出时(ctrl-c), 突然断电是无法保存进度的. 在第一次使用的时候会出现会话文件不存在的错误, 手动创建一个空文件即可. 如果您编写的是自动启动脚本，在启动aria2前加上 touch aria2.session 这句命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input-file=/some/where/aria2.session</span><br><span class="line">save-session=/some/where/aria2.session</span><br><span class="line">#定时保存会话，需要1.16.1之后的release版</span><br><span class="line">#save-session-interval=60</span><br></pre></td></tr></table></figure></p>
<p>###磁盘相关<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#文件保存路径, 默认为当前启动位置</span><br><span class="line">dir=/some/where</span><br><span class="line">#文件缓存, 使用内置的文件缓存, 如果你不相信Linux内核文件缓存和磁盘内置缓存时使用, 需要1.16及以上版本</span><br><span class="line">#disk-cache=0</span><br><span class="line">#另一种Linux文件缓存方式, 使用前确保您使用的内核支持此选项, 需要1.15及以上版本(?)</span><br><span class="line">#enable-mmap=true</span><br><span class="line">#文件预分配, 能有效降低文件碎片, 提高磁盘性能. 缺点是预分配时间较长</span><br><span class="line">#所需时间 none &lt; falloc ? trunc &lt;&lt; prealloc, falloc和trunc需要文件系统和内核支持</span><br><span class="line">file-allocation=prealloc</span><br></pre></td></tr></table></figure></p>
<p>###BT相关<br><a href="http://aria2.sourceforge.net/manual/en/html/aria2c.html#bittorrent-specific-options" target="_blank" rel="noopener">http://aria2.sourceforge.net/manual/en/html/aria2c.html#bittorrent-specific-options</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#启用本地节点查找</span><br><span class="line">bt-enable-lpd=true</span><br><span class="line">#添加额外的tracker</span><br><span class="line">#bt-tracker=&lt;URI&gt;,…</span><br><span class="line">#单种子最大连接数</span><br><span class="line">#bt-max-peers=55</span><br><span class="line">#强制加密, 防迅雷必备</span><br><span class="line">#bt-require-crypto=true</span><br><span class="line">#当下载的文件是一个种子(以.torrent结尾)时, 自动下载BT</span><br><span class="line">follow-torrent=true</span><br><span class="line">#BT监听端口, 当端口屏蔽时使用</span><br><span class="line">#listen-port=6881-6999</span><br><span class="line">aria2亦可以用于PT下载, 下载的关键在于伪装</span><br><span class="line">#不确定是否需要，为保险起见，need more test</span><br><span class="line">enable-dht=false</span><br><span class="line">bt-enable-lpd=false</span><br><span class="line">enable-peer-exchange=false</span><br><span class="line">#修改特征</span><br><span class="line">user-agent=uTorrent/2210(25130)</span><br><span class="line">peer-id-prefix=-UT2210-</span><br><span class="line">#修改做种设置, 允许做种</span><br><span class="line">seed-ratio=0</span><br><span class="line">#保存会话</span><br><span class="line">force-save=true</span><br><span class="line">bt-hash-check-seed=true</span><br><span class="line">bt-seed-unverified=true</span><br><span class="line">bt-save-metadata=true</span><br><span class="line">#定时保存会话，需要1.16.1之后的某个release版本（比如1.16.2）</span><br><span class="line">#save-session-interval=60</span><br></pre></td></tr></table></figure></p>
<p>##常见问题</p>
<p>###Internal server error<br>手动访问你的JSON-RPC地址 <a href="http://hostname:port/jsonrpc?jsoncallback=1" target="_blank" rel="noopener">http://hostname:port/jsonrpc?jsoncallback=1</a> 如果没有返回, 请确认aria2是否启动以及连通性. 如果aria2在路由器后或没有公网IP, 请做好端口映射.</p>
<p>###如何使用迅雷离线<br><a href="http://binux.github.com/ThunderLixianExporter/" target="_blank" rel="noopener">http://binux.github.com/ThunderLixianExporter/</a><br>安装后, 在迅雷离线的右上角的设置中设置RPC地址.<br>提供chrome插件: <a href="https://chrome.google.com/webstore/detail/thunderlixianassistant/eehlmkfpnagoieibahhcghphdbjcdmen" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/thunderlixianassistant/eehlmkfpnagoieibahhcghphdbjcdmen</a></p>
<p>###如何使用旋风离线(QQ离线)<br><a href="http://userscripts.org/scripts/show/142624" target="_blank" rel="noopener">http://userscripts.org/scripts/show/142624</a><br>安装脚本后, 在旋风离线页面使用.</p>
<p>转载自 <a href="https://binux.blog/2012/12/aria2-examples/" target="_blank" rel="noopener">https://binux.blog/2012/12/aria2-examples/</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/VPS-技术/">VPS 技术</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2017/03/20/aria2配置示例/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/03/17/Managing Hierarchical Data in MySQL/"><span>Managing Hierarchical Data in MySQL</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/03/17/Managing Hierarchical Data in MySQL/" rel="bookmark">
        <time class="entry-date published" datetime="2017-03-16T20:50:14.000Z">
          2017-03-17
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><strong>引言</strong><br>大多数用户都曾在数据库中处理过分层数据(hierarchical data)，认为分层数据的管理不是关系数据库的目的。之所以这么认为，是因为关系数据库中的表没有层次关系，只是简单的平面化的列表；而分层数据具有父－子关系，显然关系数据库中的表不能自然地表现出其分层的特性。<br>我们认为，分层数据是每项只有一个父项和零个或多个子项（根项除外，根项没有父项）的数据集合。分层数据存在于许多基于数据库的应用程序中，包括论坛和邮件列表中的分类、商业组织图表、内容管理系统的分类、产品分类。我们打算使用下面一个虚构的电子商店的产品分类：<br><a href="/uploads/2017/03/1.png"><img src="/uploads/2017/03/1.png" alt=""></a><br>这些分类层次与上面提到的一些例子中的分类层次是相类似的。在本文中我们将从传统的邻接表(adjacency list)模型出发，阐述2种在MySQL中处理分层数据的模型。</p>
<p><strong>邻接表模型</strong><br>上述例子的分类数据将被存储在下面的数据表中（我给出了全部的数据表创建、数据插入的代码，你可以跟着做）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE category(</span><br><span class="line">category_id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">name VARCHAR(20) NOT NULL,</span><br><span class="line">parent INT DEFAULT NULL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO category</span><br><span class="line">VALUES(1,&apos;ELECTRONICS&apos;,NULL),(2,&apos;TELEVISIONS&apos;,1),(3,&apos;TUBE&apos;,2),</span><br><span class="line">(4,&apos;LCD&apos;,2),(5,&apos;PLASMA&apos;,2),(6,&apos;PORTABLE ELECTRONICS&apos;,1),</span><br><span class="line">(7,&apos;MP3 PLAYERS&apos;,6),(8,&apos;FLASH&apos;,7),</span><br><span class="line">(9,&apos;CD PLAYERS&apos;,6),(10,&apos;2 WAY RADIOS&apos;,6);</span><br><span class="line"></span><br><span class="line">SELECT * FROM category ORDER BY category_id;</span><br><span class="line"></span><br><span class="line">+-------------+----------------------+--------+</span><br><span class="line">| category_id | name                 | parent |</span><br><span class="line">+-------------+----------------------+--------+</span><br><span class="line">|           1 | ELECTRONICS          |   NULL |</span><br><span class="line">|           2 | TELEVISIONS          |      1 |</span><br><span class="line">|           3 | TUBE                 |      2 |</span><br><span class="line">|           4 | LCD                  |      2 |</span><br><span class="line">|           5 | PLASMA               |      2 |</span><br><span class="line">|           6 | PORTABLE ELECTRONICS |      1 |</span><br><span class="line">|           7 | MP3 PLAYERS          |      6 |</span><br><span class="line">|           8 | FLASH                |      7 |</span><br><span class="line">|           9 | CD PLAYERS           |      6 |</span><br><span class="line">|          10 | 2 WAY RADIOS         |      6 |</span><br><span class="line">+-------------+----------------------+--------+</span><br><span class="line">10 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>在邻接表模型中，数据表中的每项包含了指向其父项的指示器。在此例中，最上层项的父项为空值(NULL)。邻接表模型的优势在于它很简单，可以很容易地看出FLASH是MP3 PLAYERS的子项，哪个是portable electronics的子项，哪个是electronics的子项。虽然，在客户端编码中邻接表模型处理起来也相当的简单，但是如果是纯SQL编码的话，该模型会有很多问题。</p>
<p><strong>检索整树</strong><br>通常在处理分层数据时首要的任务是，以某种缩进形式来呈现一棵完整的树。为此，在纯SQL编码中通常的做法是使用自连接(self-join)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SELECT t1.name AS lev1, t2.name as lev2, t3.name as lev3, t4.name as lev4</span><br><span class="line">FROM category AS t1</span><br><span class="line">LEFT JOIN category AS t2 ON t2.parent = t1.category_id</span><br><span class="line">LEFT JOIN category AS t3 ON t3.parent = t2.category_id</span><br><span class="line">LEFT JOIN category AS t4 ON t4.parent = t3.category_id</span><br><span class="line">WHERE t1.name = &apos;ELECTRONICS&apos;;</span><br><span class="line"></span><br><span class="line">+-------------+----------------------+--------------+-------+</span><br><span class="line">| lev1        | lev2                 | lev3         | lev4  |</span><br><span class="line">+-------------+----------------------+--------------+-------+</span><br><span class="line">| ELECTRONICS | TELEVISIONS          | TUBE         | NULL  |</span><br><span class="line">| ELECTRONICS | TELEVISIONS          | LCD          | NULL  |</span><br><span class="line">| ELECTRONICS | TELEVISIONS          | PLASMA       | NULL  |</span><br><span class="line">| ELECTRONICS | PORTABLE ELECTRONICS | MP3 PLAYERS  | FLASH |</span><br><span class="line">| ELECTRONICS | PORTABLE ELECTRONICS | CD PLAYERS   | NULL  |</span><br><span class="line">| ELECTRONICS | PORTABLE ELECTRONICS | 2 WAY RADIOS | NULL  |</span><br><span class="line">+-------------+----------------------+--------------+-------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p><strong>检索所有叶子节点</strong><br>我们可以用左连接(LEFT JOIN)来检索出树中所有叶子节点(没有孩子节点的节点）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SELECT t1.name FROM</span><br><span class="line">category AS t1 LEFT JOIN category as t2</span><br><span class="line">ON t1.category_id = t2.parent</span><br><span class="line">WHERE t2.category_id IS NULL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+--------------+</span><br><span class="line">| name         |</span><br><span class="line">+--------------+</span><br><span class="line">| TUBE         |</span><br><span class="line">| LCD          |</span><br><span class="line">| PLASMA       |</span><br><span class="line">| FLASH        |</span><br><span class="line">| CD PLAYERS   |</span><br><span class="line">| 2 WAY RADIOS |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure></p>
<p><strong>检索单一路径</strong><br>通过自连接，我们也可以检索出单一路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT t1.name AS lev1, t2.name as lev2, t3.name as lev3, t4.name as lev4</span><br><span class="line">FROM category AS t1</span><br><span class="line">LEFT JOIN category AS t2 ON t2.parent = t1.category_id</span><br><span class="line">LEFT JOIN category AS t3 ON t3.parent = t2.category_id</span><br><span class="line">LEFT JOIN category AS t4 ON t4.parent = t3.category_id</span><br><span class="line">WHERE t1.name = &apos;ELECTRONICS&apos; AND t4.name = &apos;FLASH&apos;;</span><br><span class="line"></span><br><span class="line">+-------------+----------------------+-------------+-------+</span><br><span class="line">| lev1        | lev2                 | lev3        | lev4  |</span><br><span class="line">+-------------+----------------------+-------------+-------+</span><br><span class="line">| ELECTRONICS | PORTABLE ELECTRONICS | MP3 PLAYERS | FLASH |</span><br><span class="line">+-------------+----------------------+-------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure></p>
<p>这种方法的主要局限是你需要为每层数据添加一个自连接，随着层次的增加，自连接变得越来越复杂，检索的性能自然而然的也就下降了。</p>
<p><strong>邻接表模型的局限性</strong><br>用纯SQL编码实现邻接表模型有一定的难度。在我们检索某分类的路径之前，我们需要知道该分类所在的层次。另外，我们在删除节点的时候要特别小心，因为潜在的可能会孤立一棵子树（当删除portable electronics分类时，所有他的子分类都成了孤儿）。部分局限性可以通过使用客户端代码或者存储过程来解决，我们可以从树的底部开始向上迭代来获得一颗树或者单一路径，我们也可以在删除节点的时候使其子节点指向一个新的父节点，来防止孤立子树的产生。</p>
<p><strong>嵌套集合(Nested Set)模型</strong><br>我想在这篇文章中重点阐述一种不同的方法，俗称为嵌套集合模型。在嵌套集合模型中，我们将以一种新的方式来看待我们的分层数据，不再是线与点了，而是嵌套容器。我试着以嵌套容器的方式画出了electronics分类图：<br><a href="/uploads/2017/03/2.png"><img src="/uploads/2017/03/2.png" alt=""></a><br>从上图可以看出我们依旧保持了数据的层次，父分类包围了其子分类。在数据表中，我们通过使用表示节点的嵌套关系的左值(left value)和右值(right value)来表现嵌套集合模型中数据的分层特性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE nested_category (</span><br><span class="line"> category_id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line"> name VARCHAR(20) NOT NULL,</span><br><span class="line"> lft INT NOT NULL,</span><br><span class="line"> rgt INT NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO nested_category</span><br><span class="line">VALUES(1,&apos;ELECTRONICS&apos;,1,20),(2,&apos;TELEVISIONS&apos;,2,9),(3,&apos;TUBE&apos;,3,4),</span><br><span class="line">(4,&apos;LCD&apos;,5,6),(5,&apos;PLASMA&apos;,7,8),(6,&apos;PORTABLE ELECTRONICS&apos;,10,19),</span><br><span class="line">(7,&apos;MP3 PLAYERS&apos;,11,14),(8,&apos;FLASH&apos;,12,13),</span><br><span class="line">(9,&apos;CD PLAYERS&apos;,15,16),(10,&apos;2 WAY RADIOS&apos;,17,18);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT * FROM nested_category ORDER BY category_id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+-------------+----------------------+-----+-----+</span><br><span class="line">| category_id | name                 | lft | rgt |</span><br><span class="line">+-------------+----------------------+-----+-----+</span><br><span class="line">|           1 | ELECTRONICS          |   1 |  20 |</span><br><span class="line">|           2 | TELEVISIONS          |   2 |   9 |</span><br><span class="line">|           3 | TUBE                 |   3 |   4 |</span><br><span class="line">|           4 | LCD                  |   5 |   6 |</span><br><span class="line">|           5 | PLASMA               |   7 |   8 |</span><br><span class="line">|           6 | PORTABLE ELECTRONICS |  10 |  19 |</span><br><span class="line">|           7 | MP3 PLAYERS          |  11 |  14 |</span><br><span class="line">|           8 | FLASH                |  12 |  13 |</span><br><span class="line">|           9 | CD PLAYERS           |  15 |  16 |</span><br><span class="line">|          10 | 2 WAY RADIOS         |  17 |  18 |</span><br><span class="line">+-------------+----------------------+-----+-----+</span><br></pre></td></tr></table></figure></p>
<p>我们使用了lft和rgt来代替left和right，是因为在MySQL中left和right是保留字。<a href="http://dev.mysql.com/doc/mysql/en/reserved-words.html" target="_blank" rel="noopener">http://dev.mysql.com/doc/mysql/en/reserved-words.html</a>，有一份详细的MySQL保留字清单。<br>那么，我们怎样决定左值和右值呢？我们从外层节点的最左侧开始，从左到右编号：<br><a href="/uploads/2017/03/3.png"><img src="/uploads/2017/03/3.png" alt=""></a><br>这样的编号方式也同样适用于典型的树状结构：<br><a href="/uploads/2017/03/4.png"><img src="/uploads/2017/03/4.png" alt=""></a><br>当我们为树状的结构编号时，我们从左到右，一次一层，为节点赋右值前先从左到右遍历其子节点给其子节点赋左右值。这种方法被称作改进的<strong>先序遍历算法</strong>。</p>
<p><strong>检索整树</strong><br>我们可以通过自连接把父节点连接到子节点上来检索整树，是因为子节点的lft值总是在其父节点的lft值和rgt值之间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">SELECT node.name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">AND parent.name = &apos;ELECTRONICS&apos;</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+----------------------+</span><br><span class="line">| name                 |</span><br><span class="line">+----------------------+</span><br><span class="line">| ELECTRONICS          |</span><br><span class="line">| TELEVISIONS          |</span><br><span class="line">| TUBE                 |</span><br><span class="line">| LCD                  |</span><br><span class="line">| PLASMA               |</span><br><span class="line">| PORTABLE ELECTRONICS |</span><br><span class="line">| MP3 PLAYERS          |</span><br><span class="line">| FLASH                |</span><br><span class="line">| CD PLAYERS           |</span><br><span class="line">| 2 WAY RADIOS         |</span><br><span class="line">+----------------------+</span><br></pre></td></tr></table></figure></p>
<p>不像先前邻接表模型的例子，这个查询语句不管树的层次有多深都能很好的工作。在BETWEEN的子句中我们没有去关心node的rgt值，是因为使用node的rgt值得出的父节点总是和使用lft值得出的是相同的。</p>
<p><strong>检索所有叶子节点</strong><br>检索出所有的叶子节点，使用嵌套集合模型的方法比邻接表模型的LEFT JOIN方法简单多了。如果你仔细得看了nested_category表，你可能已经注意到叶子节点的左右值是连续的。要检索出叶子节点，我们只要查找满足rgt=lft+1的节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT name</span><br><span class="line">FROM nested_category</span><br><span class="line">WHERE rgt = lft + 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+--------------+</span><br><span class="line">| name         |</span><br><span class="line">+--------------+</span><br><span class="line">| TUBE         |</span><br><span class="line">| LCD          |</span><br><span class="line">| PLASMA       |</span><br><span class="line">| FLASH        |</span><br><span class="line">| CD PLAYERS   |</span><br><span class="line">| 2 WAY RADIOS |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure></p>
<p><strong>检索单一路径</strong><br>在嵌套集合模型中，我们可以不用多个自连接就可以检索出单一路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT parent.name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">AND node.name = &apos;FLASH&apos;</span><br><span class="line">ORDER BY parent.lft;</span><br><span class="line"></span><br><span class="line">+----------------------+</span><br><span class="line">| name                 |</span><br><span class="line">+----------------------+</span><br><span class="line">| ELECTRONICS          |</span><br><span class="line">| PORTABLE ELECTRONICS |</span><br><span class="line">| MP3 PLAYERS          |</span><br><span class="line">| FLASH                |</span><br><span class="line">+----------------------+</span><br></pre></td></tr></table></figure></p>
<p><strong>检索节点的深度</strong><br>我们已经知道怎样去呈现一棵整树，但是为了更好的标识出节点在树中所处层次，我们怎样才能检索出节点在树中的深度呢？我们可以在先前的查询语句上增加COUNT函数和GROUP BY子句来实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SELECT node.name, (COUNT(parent.name) - 1) AS depth</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">GROUP BY node.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line">+----------------------+-------+</span><br><span class="line">| name                 | depth |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| ELECTRONICS          |     0 |</span><br><span class="line">| TELEVISIONS          |     1 |</span><br><span class="line">| TUBE                 |     2 |</span><br><span class="line">| LCD                  |     2 |</span><br><span class="line">| PLASMA               |     2 |</span><br><span class="line">| PORTABLE ELECTRONICS |     1 |</span><br><span class="line">| MP3 PLAYERS          |     2 |</span><br><span class="line">| FLASH                |     3 |</span><br><span class="line">| CD PLAYERS           |     2 |</span><br><span class="line">| 2 WAY RADIOS         |     2 |</span><br><span class="line">+----------------------+-------+</span><br></pre></td></tr></table></figure></p>
<p>我们可以根据depth值来缩进分类名字，使用CONCAT和REPEAT字符串函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SELECT CONCAT( REPEAT(&apos; &apos;, COUNT(parent.name) - 1), node.name) AS name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">GROUP BY node.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line">+-----------------------+</span><br><span class="line">| name                  |</span><br><span class="line">+-----------------------+</span><br><span class="line">| ELECTRONICS           |</span><br><span class="line">|  TELEVISIONS          |</span><br><span class="line">|   TUBE                |</span><br><span class="line">|   LCD                 |</span><br><span class="line">|   PLASMA              |</span><br><span class="line">|  PORTABLE ELECTRONICS |</span><br><span class="line">|   MP3 PLAYERS         |</span><br><span class="line">|    FLASH              |</span><br><span class="line">|   CD PLAYERS          |</span><br><span class="line">|   2 WAY RADIOS        |</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure></p>
<p>当然，在客户端应用程序中你可能会用depth值来直接展示数据的层次。Web开发者会遍历该树，随着depth值的增加和减少来添加</p>
<ul>
<li>和</li>
</ul>
<p>标签。</p>
<p><strong>检索子树的深度</strong><br>当我们需要子树的深度信息时，我们不能限制自连接中的node或parent，因为这么做会打乱数据集的顺序。因此，我们添加了第三个自连接作为子查询，来得出子树新起点的深度值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">SELECT node.name, (COUNT(parent.name) - (sub_tree.depth + 1)) AS depth</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">	nested_category AS parent,</span><br><span class="line">	nested_category AS sub_parent,</span><br><span class="line">	(</span><br><span class="line">		SELECT node.name, (COUNT(parent.name) - 1) AS depth</span><br><span class="line">		FROM nested_category AS node,</span><br><span class="line">		nested_category AS parent</span><br><span class="line">		WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">		AND node.name = &apos;PORTABLE ELECTRONICS&apos;</span><br><span class="line">		GROUP BY node.name</span><br><span class="line">		ORDER BY node.lft</span><br><span class="line">	)AS sub_tree</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">	AND node.lft BETWEEN sub_parent.lft AND sub_parent.rgt</span><br><span class="line">	AND sub_parent.name = sub_tree.name</span><br><span class="line">GROUP BY node.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+----------------------+-------+</span><br><span class="line">| name                 | depth |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| PORTABLE ELECTRONICS |     0 |</span><br><span class="line">| MP3 PLAYERS          |     1 |</span><br><span class="line">| FLASH                |     2 |</span><br><span class="line">| CD PLAYERS           |     1 |</span><br><span class="line">| 2 WAY RADIOS         |     1 |</span><br><span class="line">+----------------------+-------+</span><br></pre></td></tr></table></figure></p>
<p>这个查询语句可以检索出任一节点子树的深度值，包括根节点。这里的深度值跟你指定的节点有关。</p>
<p><strong>检索节点的直接子节点</strong><br>可以想象一下，你在零售网站上呈现电子产品的分类。当用户点击分类后，你将要呈现该分类下的产品，同时也需列出该分类下的直接子分类，而不是该分类下的全部分类。为此，我们只呈现该节点及其直接子节点，不再呈现更深层次的节点。例如，当呈现PORTABLEELECTRONICS分类时，我们同时只呈现MP3 PLAYERS、CD PLAYERS和2 WAY RADIOS分类，而不呈现FLASH分类。</p>
<p>要实现它非常的简单，在先前的查询语句上添加HAVING子句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">SELECT node.name, (COUNT(parent.name) - (sub_tree.depth + 1)) AS depth</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">	nested_category AS parent,</span><br><span class="line">	nested_category AS sub_parent,</span><br><span class="line">	(</span><br><span class="line">		SELECT node.name, (COUNT(parent.name) - 1) AS depth</span><br><span class="line">		FROM nested_category AS node,</span><br><span class="line">		nested_category AS parent</span><br><span class="line">		WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">		AND node.name = &apos;PORTABLE ELECTRONICS&apos;</span><br><span class="line">		GROUP BY node.name</span><br><span class="line">		ORDER BY node.lft</span><br><span class="line">	)AS sub_tree</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">	AND node.lft BETWEEN sub_parent.lft AND sub_parent.rgt</span><br><span class="line">	AND sub_parent.name = sub_tree.name</span><br><span class="line">GROUP BY node.name</span><br><span class="line">HAVING depth &lt;= 1</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line">+----------------------+-------+</span><br><span class="line">| name                 | depth |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| PORTABLE ELECTRONICS |     0 |</span><br><span class="line">| MP3 PLAYERS          |     1 |</span><br><span class="line">| CD PLAYERS           |     1 |</span><br><span class="line">| 2 WAY RADIOS         |     1 |</span><br><span class="line">+----------------------+-------+</span><br></pre></td></tr></table></figure></p>
<p>如果你不希望呈现父节点，你可以更改<strong>HAVING depth &lt;= 1</strong>为<strong>HAVING depth = 1</strong>。</p>
<p><strong>嵌套集合模型中集合函数的应用</strong><br>让我们添加一个产品表，我们可以使用它来示例集合函数的应用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE product(</span><br><span class="line">product_id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">name VARCHAR(40),</span><br><span class="line">category_id INT NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO product(name, category_id) VALUES(&apos;20&quot; TV&apos;,3),(&apos;36&quot; TV&apos;,3),</span><br><span class="line">(&apos;Super-LCD 42&quot;&apos;,4),(&apos;Ultra-Plasma 62&quot;&apos;,5),(&apos;Value Plasma 38&quot;&apos;,5),</span><br><span class="line">(&apos;Power-MP3 5gb&apos;,7),(&apos;Super-Player 1gb&apos;,8),(&apos;Porta CD&apos;,9),(&apos;CD To go!&apos;,9),</span><br><span class="line">(&apos;Family Talk 360&apos;,10);</span><br><span class="line"></span><br><span class="line">SELECT * FROM product;</span><br><span class="line"></span><br><span class="line">+------------+-------------------+-------------+</span><br><span class="line">| product_id | name              | category_id |</span><br><span class="line">+------------+-------------------+-------------+</span><br><span class="line">|          1 | 20&quot; TV            |           3 |</span><br><span class="line">|          2 | 36&quot; TV            |           3 |</span><br><span class="line">|          3 | Super-LCD 42&quot;     |           4 |</span><br><span class="line">|          4 | Ultra-Plasma 62&quot;  |           5 |</span><br><span class="line">|          5 | Value Plasma 38&quot;  |           5 |</span><br><span class="line">|          6 | Power-MP3 128mb   |           7 |</span><br><span class="line">|          7 | Super-Shuffle 1gb |           8 |</span><br><span class="line">|          8 | Porta CD          |           9 |</span><br><span class="line">|          9 | CD To go!         |           9 |</span><br><span class="line">|         10 | Family Talk 360   |          10 |</span><br><span class="line">+------------+-------------------+-------------+</span><br></pre></td></tr></table></figure></p>
<p>现在，让我们写一个查询语句，在检索分类树的同时，计算出各分类下的产品数量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">SELECT parent.name, COUNT(product.name)</span><br><span class="line">FROM nested_category AS node ,</span><br><span class="line">nested_category AS parent,</span><br><span class="line">product</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">AND node.category_id = product.category_id</span><br><span class="line">GROUP BY parent.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+----------------------+---------------------+</span><br><span class="line">| name                 | COUNT(product.name) |</span><br><span class="line">+----------------------+---------------------+</span><br><span class="line">| ELECTRONICS          |                  10 |</span><br><span class="line">| TELEVISIONS          |                   5 |</span><br><span class="line">| TUBE                 |                   2 |</span><br><span class="line">| LCD                  |                   1 |</span><br><span class="line">| PLASMA               |                   2 |</span><br><span class="line">| PORTABLE ELECTRONICS |                   5 |</span><br><span class="line">| MP3 PLAYERS          |                   2 |</span><br><span class="line">| FLASH                |                   1 |</span><br><span class="line">| CD PLAYERS           |                   2 |</span><br><span class="line">| 2 WAY RADIOS         |                   1 |</span><br><span class="line">+----------------------+---------------------+</span><br></pre></td></tr></table></figure></p>
<p>这条查询语句在检索整树的查询语句上增加了COUNT和GROUP BY子句，同时在WHERE子句中引用了product表和一个自连接。</p>
<p><strong>新增节点</strong><br>到现在，我们已经知道了如何去查询我们的树，是时候去关注一下如何增加一个新节点来更新我们的树了。让我们再一次观察一下我们的嵌套集合图：<br><a href="/uploads/2017/03/5.png"><img src="/uploads/2017/03/5.png" alt=""></a><br>当我们想要在TELEVISIONS和PORTABLE ELECTRONICS节点之间新增一个节点，新节点的lft和rgt 的 值为10和11，所有该节点的右边节点的lft和rgt值都将加2，之后我们再添加新节点并赋相应的lft和rgt值。在MySQL 5中可以使用存储过程来完成，我假设当前大部分读者使用的是MySQL 4.1版本，因为这是最新的稳定版本。所以，我使用了锁表（LOCK TABLES）语句来隔离查询：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLE nested_category WRITE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT @myRight := rgt FROM nested_category</span><br><span class="line">WHERE name = &apos;TELEVISIONS&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UPDATE nested_category SET rgt = rgt + 2 WHERE rgt &gt; @myRight;</span><br><span class="line">UPDATE nested_category SET lft = lft + 2 WHERE lft &gt; @myRight;</span><br><span class="line"></span><br><span class="line">INSERT INTO nested_category(name, lft, rgt) VALUES(&apos;GAME CONSOLES&apos;, @myRight + 1, @myRight + 2);</span><br><span class="line"></span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure></p>
<p>我们可以检验一下新节点插入的正确性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SELECT CONCAT( REPEAT( &apos; &apos;, (COUNT(parent.name) - 1) ), node.name) AS name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">GROUP BY node.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+-----------------------+</span><br><span class="line">| name                  |</span><br><span class="line">+-----------------------+</span><br><span class="line">| ELECTRONICS           |</span><br><span class="line">|  TELEVISIONS          |</span><br><span class="line">|   TUBE                |</span><br><span class="line">|   LCD                 |</span><br><span class="line">|   PLASMA              |</span><br><span class="line">|  GAME CONSOLES        |</span><br><span class="line">|  PORTABLE ELECTRONICS |</span><br><span class="line">|   MP3 PLAYERS         |</span><br><span class="line">|    FLASH              |</span><br><span class="line">|   CD PLAYERS          |</span><br><span class="line">|   2 WAY RADIOS        |</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure></p>
<p>如果我们想要在叶子节点下增加节点，我们得稍微修改一下查询语句。让我们在2 WAYRADIOS叶子节点下添加FRS节点吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLE nested_category WRITE;</span><br><span class="line"></span><br><span class="line">SELECT @myLeft := lft FROM nested_category</span><br><span class="line"></span><br><span class="line">WHERE name = &apos;2 WAY RADIOS&apos;;</span><br><span class="line"></span><br><span class="line">UPDATE nested_category SET rgt = rgt + 2 WHERE rgt &gt; @myLeft;</span><br><span class="line">UPDATE nested_category SET lft = lft + 2 WHERE lft &gt; @myLeft;</span><br><span class="line"></span><br><span class="line">INSERT INTO nested_category(name, lft, rgt) VALUES(&apos;FRS&apos;, @myLeft + 1, @myLeft + 2);</span><br><span class="line"></span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，我们扩大了新产生的父节点(2 WAY RADIOS节点）的右值及其所有它的右边节点的左右值，之后置新增节点于新父节点之下。正如你所看到的，我们新增的节点已经完全融入了嵌套集合中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">SELECT CONCAT( REPEAT( &apos; &apos;, (COUNT(parent.name) - 1) ), node.name) AS name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">GROUP BY node.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+-----------------------+</span><br><span class="line">| name                  |</span><br><span class="line">+-----------------------+</span><br><span class="line">| ELECTRONICS           |</span><br><span class="line">|  TELEVISIONS          |</span><br><span class="line">|   TUBE                |</span><br><span class="line">|   LCD                 |</span><br><span class="line">|   PLASMA              |</span><br><span class="line">|  GAME CONSOLES        |</span><br><span class="line">|  PORTABLE ELECTRONICS |</span><br><span class="line">|   MP3 PLAYERS         |</span><br><span class="line">|    FLASH              |</span><br><span class="line">|   CD PLAYERS          |</span><br><span class="line">|   2 WAY RADIOS        |</span><br><span class="line">|    FRS                |</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure></p>
<p><strong>删除节点</strong><br>最后还有个基础任务，删除节点。删除节点的处理过程跟节点在分层数据中所处的位置有关，删除一个叶子节点比删除一个子节点要简单得多，因为删除子节点的时候，我们需要去处理孤立节点。<br>删除一个叶子节点的过程正好是新增一个叶子节点的逆过程，我们在删除节点的同时该节点右边所有节点的左右值和该父节点的右值都会减去该节点的宽度值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLE nested_category WRITE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT @myLeft := lft, @myRight := rgt, @myWidth := rgt - lft + 1</span><br><span class="line">FROM nested_category</span><br><span class="line">WHERE name = &apos;GAME CONSOLES&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELETE FROM nested_category WHERE lft BETWEEN @myLeft AND @myRight;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UPDATE nested_category SET rgt = rgt - @myWidth WHERE rgt &gt; @myRight;</span><br><span class="line">UPDATE nested_category SET lft = lft - @myWidth WHERE lft &gt; @myRight;</span><br><span class="line"></span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure></p>
<p>我们再一次检验一下节点已经成功删除,而且没有打乱数据的层次：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SELECT CONCAT( REPEAT( &apos; &apos;, (COUNT(parent.name) - 1) ), node.name) AS name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">GROUP BY node.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+-----------------------+</span><br><span class="line">| name                  |</span><br><span class="line">+-----------------------+</span><br><span class="line">| ELECTRONICS           |</span><br><span class="line">|  TELEVISIONS          |</span><br><span class="line">|   TUBE                |</span><br><span class="line">|   LCD                 |</span><br><span class="line">|   PLASMA              |</span><br><span class="line">|  PORTABLE ELECTRONICS |</span><br><span class="line">|   MP3 PLAYERS         |</span><br><span class="line">|    FLASH              |</span><br><span class="line">|   CD PLAYERS          |</span><br><span class="line">|   2 WAY RADIOS        |</span><br><span class="line">|    FRS                |</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure></p>
<p>这个方法可以完美地删除节点及其子节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLE nested_category WRITE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT @myLeft := lft, @myRight := rgt, @myWidth := rgt - lft + 1</span><br><span class="line">FROM nested_category</span><br><span class="line">WHERE name = &apos;MP3 PLAYERS&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELETE FROM nested_category WHERE lft BETWEEN @myLeft AND @myRight;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UPDATE nested_category SET rgt = rgt - @myWidth WHERE rgt &gt; @myRight;</span><br><span class="line">UPDATE nested_category SET lft = lft - @myWidth WHERE lft &gt; @myRight;</span><br><span class="line"></span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure></p>
<p>再次验证我们已经成功的删除了一棵子树：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SELECT CONCAT( REPEAT( &apos; &apos;, (COUNT(parent.name) - 1) ), node.name) AS name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">GROUP BY node.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+-----------------------+</span><br><span class="line">| name                  |</span><br><span class="line">+-----------------------+</span><br><span class="line">| ELECTRONICS           |</span><br><span class="line">|  TELEVISIONS          |</span><br><span class="line">|   TUBE                |</span><br><span class="line">|   LCD                 |</span><br><span class="line">|   PLASMA              |</span><br><span class="line">|  PORTABLE ELECTRONICS |</span><br><span class="line">|   CD PLAYERS          |</span><br><span class="line">|   2 WAY RADIOS        |</span><br><span class="line">|    FRS                |</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure></p>
<p>有时，我们只删除该节点，而不删除该节点的子节点。在一些情况下，你希望改变其名字为占位符，直到替代名字的出现，比如你开除了一个主管（需要更换主管）。在另外一些情况下，你希望子节点挂到该删除节点的父节点下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLE nested_category WRITE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT @myLeft := lft, @myRight := rgt, @myWidth := rgt - lft + 1</span><br><span class="line">FROM nested_category</span><br><span class="line">WHERE name = &apos;PORTABLE ELECTRONICS&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELETE FROM nested_category WHERE lft = @myLeft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UPDATE nested_category SET rgt = rgt - 1, lft = lft - 1 WHERE lft BETWEEN @myLeft AND @myRight;</span><br><span class="line">UPDATE nested_category SET rgt = rgt - 2 WHERE rgt &gt; @myRight;</span><br><span class="line">UPDATE nested_category SET lft = lft - 2 WHERE lft &gt; @myRight;</span><br><span class="line"></span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，我们对该节点所有右边节点的左右值都减去了2（因为不考虑其子节点，该节点的宽度为2），对该节点的子节点的左右值都减去了1（弥补由于失去父节点的左值造成的裂缝）。我们再一次确认，那些节点是否都晋升了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SELECT CONCAT( REPEAT( &apos; &apos;, (COUNT(parent.name) - 1) ), node.name) AS name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">GROUP BY node.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+---------------+</span><br><span class="line">| name          |</span><br><span class="line">+---------------+</span><br><span class="line">| ELECTRONICS   |</span><br><span class="line">|  TELEVISIONS  |</span><br><span class="line">|   TUBE        |</span><br><span class="line">|   LCD         |</span><br><span class="line">|   PLASMA      |</span><br><span class="line">|  CD PLAYERS   |</span><br><span class="line">|  2 WAY RADIOS |</span><br><span class="line">|   FRS         |</span><br><span class="line">+---------------+</span><br></pre></td></tr></table></figure></p>
<p>有时，当删除节点的时候，把该节点的一个子节点挂载到该节点的父节点下，而其他节点挂到该节点父节点的兄弟节点下，考虑到篇幅这种情况不在这里解说了。</p>
<p><strong>最后的思考</strong><br>我希望这篇文章对你有所帮助，SQL中的嵌套集合的观念大约有十年的历史了，在网上和一些书中都能找到许多相关信息。在我看来，讲述分层数据的管理最全面的，是来自一本名叫《Joe Celko’s Trees and Hierarchies in SQL for Smarties》的书，此书的作者是在高级SQL领域倍受尊敬的Joe Celko。Joe Celko被认为是嵌套集合模型的创造者，更是该领域内的多产作家。我把Celko的书当作无价之宝，并极力地推荐它。在这本书中涵盖了在此文中没有提及的一些高级话题，也提到了其他一些关于邻接表和嵌套集合模型下管理分层数据的方法。<br>在随后的参考书目章节中，我列出了一些网络资源，也许对你研究分层数据的管理会有所帮助，其中包括一些PHP相关的资源（处理嵌套集合的PHP库）。如果你还在使用邻接表模型，你该去试试嵌套集合模型了，在Storing Hierarchical Data in a Database 文中下方列出的一些资源链接中能找到一些样例代码，可以去试验一下。</p>
<p>转自 <a href="http://www.cnblogs.com/phaibin/archive/2009/06/09/1499687.html" target="_blank" rel="noopener">http://www.cnblogs.com/phaibin/archive/2009/06/09/1499687.html</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Web-开发/">Web 开发</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2017/03/17/Managing Hierarchical Data in MySQL/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/03/11/PHP 无极分类生成树状数组/"><span>PHP 无极分类生成树状数组</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/03/11/PHP 无极分类生成树状数组/" rel="bookmark">
        <time class="entry-date published" datetime="2017-03-11T06:35:49.000Z">
          2017-03-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$arr=[</span><br><span class="line">   [<span class="string">'id'</span> =&gt; <span class="number">1</span>, <span class="string">'text'</span> =&gt; <span class="string">'Parent 1'</span>, <span class="string">'pid'</span> =&gt; <span class="number">0</span>],</span><br><span class="line">   [<span class="string">'id'</span> =&gt; <span class="number">2</span>, <span class="string">'text'</span> =&gt; <span class="string">'Parent 2'</span>, <span class="string">'pid'</span> =&gt; <span class="number">0</span>],</span><br><span class="line">   [<span class="string">'id'</span> =&gt; <span class="number">3</span>, <span class="string">'text'</span> =&gt; <span class="string">'Parent 3'</span>, <span class="string">'pid'</span> =&gt; <span class="number">0</span>],</span><br><span class="line">   [<span class="string">'id'</span> =&gt; <span class="number">4</span>, <span class="string">'text'</span> =&gt; <span class="string">'Child 1'</span>, <span class="string">'pid'</span> =&gt; <span class="number">1</span>],</span><br><span class="line">   [<span class="string">'id'</span> =&gt; <span class="number">5</span>, <span class="string">'text'</span> =&gt; <span class="string">'Parent 4'</span>, <span class="string">'pid'</span> =&gt; <span class="number">0</span>],</span><br><span class="line">   [<span class="string">'id'</span> =&gt; <span class="number">6</span>, <span class="string">'text'</span> =&gt; <span class="string">'Child 2'</span>, <span class="string">'pid'</span> =&gt; <span class="number">1</span>],</span><br><span class="line">   [<span class="string">'id'</span> =&gt; <span class="number">7</span>, <span class="string">'text'</span> =&gt; <span class="string">'Child 3'</span>, <span class="string">'pid'</span> =&gt; <span class="number">1</span>],</span><br><span class="line">   [<span class="string">'id'</span> =&gt; <span class="number">8</span>, <span class="string">'text'</span> =&gt; <span class="string">'Parent 5'</span>, <span class="string">'pid'</span> =&gt; <span class="number">0</span>],</span><br><span class="line">   [<span class="string">'id'</span> =&gt; <span class="number">9</span>, <span class="string">'text'</span> =&gt; <span class="string">'Child 1'</span>, <span class="string">'pid'</span> =&gt; <span class="number">2</span>],</span><br><span class="line">   [<span class="string">'id'</span> =&gt; <span class="number">10</span>, <span class="string">'text'</span> =&gt; <span class="string">'Child 4'</span>, <span class="string">'pid'</span> =&gt; <span class="number">1</span>],</span><br><span class="line">   [<span class="string">'id'</span> =&gt; <span class="number">11</span>, <span class="string">'text'</span> =&gt; <span class="string">'Child 1'</span>, <span class="string">'pid'</span> =&gt; <span class="number">5</span>],</span><br><span class="line">   [<span class="string">'id'</span> =&gt; <span class="number">12</span>, <span class="string">'text'</span> =&gt; <span class="string">'GrandChild 1'</span>, <span class="string">'pid'</span> =&gt; <span class="number">10</span>]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">createTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> $table = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">tree</span><span class="params">($pid = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        $tree = <span class="keyword">array</span>();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">self</span>::$table <span class="keyword">as</span> $row) &#123;</span><br><span class="line">            <span class="keyword">if</span> ($row[<span class="string">'pid'</span>] === $pid) &#123;</span><br><span class="line">                $tmp = <span class="keyword">self</span>::tree($row[<span class="string">'id'</span>]);</span><br><span class="line">                <span class="keyword">if</span> ($tmp) &#123;</span><br><span class="line">                    $row[<span class="string">'children'</span>] = $tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                $tree[] = $row;                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $tree;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">($table)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">self</span>::$table = $table;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>::tree();        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump(createTree::get($arr));</span><br></pre></td></tr></table></figure>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Web-开发/">Web 开发</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2017/03/11/PHP 无极分类生成树状数组/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/12/27/一个简单的 MySQL 队列问题/"><span>一个简单的 MySQL 队列问题</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/12/27/一个简单的 MySQL 队列问题/" rel="bookmark">
        <time class="entry-date published" datetime="2016-12-26T23:47:23.000Z">
          2016-12-27
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>最近有个朋友要实现队列任务方面的工作，我们就 mysql(innodb) 的事务和锁的特性聊了一些有趣的话题。<br>其中，最终的解决方案来自大神 <a href="https://github.com/fengmk2" target="_blank" rel="noopener">https://github.com/fengmk2</a> 之前的一个队列实现。 我做了一个小改进，使得之前表级锁的表现可以恢复到行级锁水平。</p>
<p>任务的大致描述是这样的：<br>有一个表，里面存了很多的用户id，大概100w条，表的结构简化如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user_block_status &#123;</span><br><span class="line">  user_id <span class="built_in">bigint</span> // 用户的<span class="keyword">id</span></span><br><span class="line">  <span class="keyword">status</span> <span class="built_in">int</span> // 用户的状态。<span class="number">1</span> ok <span class="number">2</span> <span class="keyword">not</span> ok</span><br><span class="line">  updated_time <span class="keyword">timestamp</span> // 更新时间戳</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个表里面，每隔10秒就要去检查用户是否存在违规页面。如果存在的话，则需要把 status 置为 2，默认是 1。<br>有 100 个 worker 会并发地从表里面读取 user_id，所以我们要设计一个策略，使得这 100 个 worker 在并发时， 读到的是独立的 100 个条目。</p>
<p><strong>方案1</strong><br>一开始的方案是这样的：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 这一句不一定会发请求，可能会优化成跟接下来的第一个 query 一起发出</span><br><span class="line">sql.begin_transaction</span><br><span class="line"></span><br><span class="line">// 第一次io发生。</span><br><span class="line">// 如果一个用户在 10s 内没有被更新，那么取出来</span><br><span class="line">// 这时候由于程序拿得到 user_id 的值，所以网络io是发生了的。否则拿不到 user_id 的值</span><br><span class="line">outdate_time = now() - 10s</span><br><span class="line">line = sql.query('<span class="keyword">select</span> user_id <span class="keyword">where</span> updated_time &lt; ? <span class="keyword">order</span> <span class="keyword">by</span> updated_time <span class="keyword">asc</span> <span class="keyword">limit</span> <span class="number">1</span><span class="string">', [outdate_time])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 第二次 io 发生</span></span><br><span class="line"><span class="string">// 更新这一行的 updated_time，免得被其他worker重复读取</span></span><br><span class="line"><span class="string">user_id = line.user_id</span></span><br><span class="line"><span class="string">sql.query('</span><span class="keyword">update</span> user_block_status <span class="keyword">set</span> updated_time=<span class="keyword">now</span>() <span class="keyword">where</span> user_id = ?<span class="string">',</span></span><br><span class="line"><span class="string">  [user_id])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 第三次 io 发生</span></span><br><span class="line"><span class="string">sql.commit</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// do something with user_id</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，这个地方我们发起了 3 次 io 请求。当然，请求数不是很关键，因为请求数以及对应的时间是一个恒定量， 而随着 worker 的增加，这一块并不会带来额外的性能瓶颈。但由于我们使用了事务，所以当 worker 由 100 增加到 1000 的时候，数据库由于存在大量的事务操作，这些事务都需要掌握写锁，所以有潜在的写锁排队问题。<br>而且关键是，方案是不可行的，根本没有起到队列的效果。<br>为什么呢？我们假设网络io无限快，而数据库每条语句的执行时间是1s，那么我们这个事务的执行时间是 2s。 这时如果 3 个 worker 并发地在同一秒（00:00）执行，那么假设 worker1 读到的 user_id 是 10086， 由于读锁是共享的，worker2 和 worker3 读到的 user_id 也是 10086。这时他们三个都想要更新 10086 的值， 而 worker1 抢先加了写锁，所以 worker2 和 worker3 就需要等待 worker1 的事务执行完毕， 才能重新获得 10086 的写锁并进行写入。 所以当 worker2 执行的时候，是 00:02 的时候，当 worker3 执行的时候，是 00:04 的时刻。 而且由于他们都是在对 10086 进行更新，所以没有起到队列的效果。<br>这里的查询条件太特殊，导致所有并发的事务需要的都是同一条数据， 这时候 innodb 行级锁的特性也没有发挥出来。<br>这个方案不仅并发时的表现类似表级锁的特性，而且也没有达到队列的效果。</p>
<p><strong>方案2</strong><br>将 update 语句在先，select 语句在后。<br>update 语句改成<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">outdate_time = now() - 10s</span><br><span class="line">result = sql.query('<span class="keyword">update</span> user_block_status <span class="keyword">set</span> updated_time=<span class="keyword">now</span>() <span class="keyword">where</span> updated_time &lt; ?   <span class="keyword">order</span> <span class="keyword">by</span> updated_time <span class="keyword">asc</span> <span class="keyword">limit</span> <span class="number">1</span><span class="string">',</span></span><br><span class="line"><span class="string">  [outdate_time])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## each worker can get different result.user_id</span></span><br></pre></td></tr></table></figure></p>
<p>这样在 update 的时候，3 个 worker 会排队，分别更新不同的 user_id 条目。然后返回来的 也是不同的 user_id。<br>可关键是，update 语句并不会将被 update 了的 id 返回给程序，所以我们后面的 select 语句拿不到对应的 user_id。 这个方案先否决。</p>
<p><strong>方案3</strong><br>方案1的基础上，在 select 语句中，手工地干扰一下，使得不同的 worker 取到不同的条目<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">outdate_time = now() - 10s</span><br><span class="line">random_number = random_int(0, worker_count * 2)</span><br><span class="line">line = sql.query('<span class="keyword">select</span> user_id <span class="keyword">where</span> updated_time &lt; ?  <span class="keyword">order</span> <span class="keyword">by</span> updated_time <span class="keyword">asc</span> <span class="keyword">limit</span> <span class="number">1</span> <span class="keyword">offset</span> ?<span class="string">',</span></span><br><span class="line"><span class="string">  [outdate_time, random_number])</span></span><br></pre></td></tr></table></figure></p>
<p>这时，我们的 worker 有很大的几率可以取出不同 user_id。但这里也还有个问题就是，很可能两个 worker 的 random_number 是同一个值。那么就发生了两次重复读取，不过对于我们的业务来说，重复读取只会造成资源的浪费， 而不会带来数据一致性的问题。只要尽量减少重复读的几率，那么这个方案就是可被接受的。<br>其中 worker_count * 2 是拍脑袋决定的数，如果数据库中始终有大量需要处理的数据，可以加大点。</p>
<p><strong>方案4</strong><br>方案3还是挺不完美的，虽然能解决问题，但是从概念上来说，我们需要的是队列。 队列的意思就是：排队！排队！排队！<br>方案3只是从业务逻辑层面出发，做出了一些规避，模拟了我们需要的效果。<br>那么回到方案2，其实方案2是更接近队列的。因为不同的 worker 真正在等待另一个 worker 更新东西。 可方案2无奈的是，我们拿不到被更新的id。那么有没有办法拿到呢？<br>其实是有的，用 mysql 的 LAST_INSERT_ID() 函数。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LAST_INSERT_ID(): Value of the AUTOINCREMENT column for the last <span class="keyword">INSERT</span></span><br></pre></td></tr></table></figure></p>
<p>关于这个函数可以看看 <a href="https://dev.mysql.com/doc/refman/5.7/en/information-functions.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/information-functions.html</a> 这里的详细介绍。<br>这个函数本来的含义是，拿到 AUTO_INCREMENT 那一列的最新值。也就是我们最新 insert 进表的那个 id。 但实际上，它也可以作为一个 sql 语句中的变量来使用，它可以被赋值，然后取出。 而且它的作用域是同一 connection 内，这样我们多个 worker 如果对 LAST_INSERT_ID 赋了不同的值， 也不会互相干扰，因为不同的 worker 使用不同的 connection。<br>这时，我们的查询在方案2的基础上就变成：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sql.begin_transaction</span><br><span class="line"></span><br><span class="line">outdate_time = now() - 10s</span><br><span class="line">sql.query('<span class="keyword">update</span> user_block_status <span class="keyword">set</span> updated_time=<span class="keyword">now</span>()，</span><br><span class="line"> <span class="keyword">id</span>=<span class="keyword">LAST_INSERT_ID</span>(<span class="keyword">id</span>) <span class="keyword">where</span> updated_time &lt; ?  <span class="keyword">order</span> <span class="keyword">by</span> updated_time <span class="keyword">asc</span> <span class="keyword">limit</span> <span class="number">1</span><span class="string">',</span></span><br><span class="line"><span class="string">  [outdate_time])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">line = sql.query('</span><span class="keyword">select</span> user_id <span class="keyword">where</span> <span class="keyword">id</span> = <span class="keyword">LAST_INSERT_ID</span>()<span class="string">')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## do sth with line.user_id</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">sql.commit</span></span><br></pre></td></tr></table></figure></p>
<p>ok，已经能排队了，业务上已经可以满足了。<br>目前性能上说，网络io还是三个，而且，【行级锁】没有被利用的特定依然存在。 写锁依然要排队，为什么这么说？因为不管 worker 有多少个，当他们并发的时候，where 条件都始终把它们 指向同一行数据，所以还是要为了同一行数据排队。即使目前我们已经达成了【排队之后，互相更新不同条目】这个目的。<br>方案4就总的性价比来说，目前跟方案3相比，还不一定谁好谁坏。 方案4的性能在于多个worker抢一个锁，大家总是等；方案3是无脑乱取，造成资源浪费，降低worker的效率，浪费机器。<br>什么情况下方案3好？ 如果总是有一大堆数据没有被处理的话，那么把方案3的乱取范围开大点，就能更好避免浪费。 而当一大堆数据等待处理的时候，方案4却不停在排队，这就等于堵住了。<br>还有一种情况就是，方案4的写锁排队已经成为瓶颈。但其实这跟上面是一回事，当总是有一大堆 worker 来取 东西的话，说明就是有一大堆数据没有被处理。否则开那么多 worker 干嘛。<br>什么情况下方案4好？ 前提就是，写锁排队并不成为瓶颈。如果要处理的数据并不是那么多，那么使用方案4的话，可以降低我们需要的 worker 数量，节约机器。 而且 worker 数量评估可以更加理性。</p>
<p><strong>方案5</strong><br>那么，我们把方案3的 offset 思想加进来吧。可惜啊可惜，update 语法只支持 limit，不支持 offset。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> [<span class="keyword">LOW_PRIORITY</span>] [<span class="keyword">IGNORE</span>] table_reference</span><br><span class="line">    <span class="keyword">SET</span> col_name1=&#123;expr1|<span class="keyword">DEFAULT</span>&#125; [, col_name2=&#123;expr2|<span class="keyword">DEFAULT</span>&#125;] ...</span><br><span class="line">    [<span class="keyword">WHERE</span> where_condition]</span><br><span class="line">    [<span class="keyword">ORDER</span> <span class="keyword">BY</span> ...]</span><br><span class="line">    [<span class="keyword">LIMIT</span> <span class="keyword">row_count</span>]</span><br></pre></td></tr></table></figure></p>
<p>那就绕一绕。<br>不用 offset，而是通过更改 outdate_time 的值，让他们获得不同的行数据。<br>我们的程序是要求 10s 算作过期，那么 11s、20s、30s 肯定也算过期吧。那就这样写：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 在 10 到 30s 之间随机取值</span><br><span class="line">outdate_time = now() - (random(10, 30))s</span><br><span class="line">sql.query('<span class="keyword">update</span> user_block_status <span class="keyword">set</span> updated_time=<span class="keyword">now</span>()，</span><br><span class="line"> <span class="keyword">id</span>=<span class="keyword">LAST_INSERT_ID</span>(<span class="keyword">id</span>) <span class="keyword">where</span> updated_time &lt; ?  <span class="keyword">order</span> <span class="keyword">by</span> updated_time <span class="keyword">asc</span>  <span class="keyword">limit</span> <span class="number">1</span><span class="string">',</span></span><br><span class="line"><span class="string">  [outdate_time])</span></span><br><span class="line"><span class="string">where updated_time &lt; now() - 10s 与 where updated_time &lt; now() - 12s 与 where updated_time &lt; now() - 15s</span></span><br><span class="line"><span class="string">//（不要在 where 条件里面写计算，这只是示例） 还是有可能锁定同一条数据。但至少，这个方案既利用上了行级锁，也不会造成多个 worker 处理同一 user_id 的 资源浪费。</span></span><br></pre></td></tr></table></figure></p>
<p><strong>方案6</strong><br>锁的问题差不多就这么解决了。<br>我们再回头看看，发现还有个 io 问题可以再弄弄。现在还是 3 个 io 嘛。<br>其实到了现在这步，begin_transaction 可以去掉了。因为我们只有一个涉及写锁的操作在里面，这个操作本身作为单一语句， 就已经是原子性的了。<br>但由于我们利用了 LAST_INSERT_ID，所以我们要保证 update 语句和它之后的 select 语句在同一个 connection 中。<br>很多的 mysql 库实现都是用了连接池的，所以同一段代码中的两条 sql 有可能会利用两条 connection， 导致得到我们非预期的 user_id。<br>但就我们的业务来说，LAST_INSERT_ID 混了其实是没关系的。每个 worker 始终还是会得到一个 unique 的 user_id。 这就够了。那么我们也不必加一些多余的逻辑，保证这两条语句取到同一个 connection。<br>这时，io 操作从 3，降低到了 2。<br>那么，有没有可能降到 1 呢。<br>其实也可以啊…………因为基本所有 mysql 库都支持 multistatements 特性。<br>我们可以在一条 query 写两个语句，返回接口会是一个数组，分别表示这两个语句的值。<br>类似这样，sql.query(‘update …..; select ….;’)。这是支持的。而且这么一来， 同一 connection 的问题也解决了。避免为以后留坑。<br>重写方案<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">outdate_time = now() - (random(10, 30))s</span><br><span class="line">result = sql.query('<span class="keyword">update</span> user_block_status <span class="keyword">set</span> updated_time=<span class="keyword">now</span>()，</span><br><span class="line"> user_id=<span class="keyword">LAST_INSERT_ID</span>(user_id) <span class="keyword">where</span> updated_time &lt; ?  <span class="keyword">order</span> <span class="keyword">by</span> updated_time <span class="keyword">asc</span> <span class="keyword">limit</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">select</span> * <span class="keyword">from</span> user_block_status <span class="keyword">where</span> user_id = <span class="keyword">LAST_INSERT_ID</span>()<span class="string">',</span></span><br><span class="line"><span class="string">  [outdate_time])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// do something with result[1].user_id</span></span><br></pre></td></tr></table></figure></p>
<p>。。。。。。。。。。。。。<br>还是有坑的。。。。。。。。。。。。。。。<br>如果 where updated_time &lt; ? 一条都不命中，那么会发生什么结果？<br>首先，update 没有改变任何行。而 LAST_INSERT_ID 还是会返回一个合理的 id，有可能是真正的 LAST_INSERT_ID， 也可能是这条 connection 中上次手工设置的。<br>在这里可以多说一下 LAST_INSERT_ID 的特性。默认情况下，LAST_INSERT_ID() 不带参数会返回最新插入那条的 id。 带参数的情况下 LAST_INSERT_ID(id) 本身的返回值就是参数，然后在接下来的调用中，如果不发生任何 insert，那么 值会在 connection 中一直保持。如果发生了 insert，就会被更新。<br>如果不处理这个 update nothing 的异常情况，当队列全部被处理完的时候， 我们的 worker 会一直工作，不会停下来。所以我们要在取 LAST_INSERT_ID 的值时， 判断一下上一条 update 语句到底有没有发生作用。<br>这时候我们需要用到另一个跟 LAST_INSERT_ID 一起出现在文档中的函数，<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROW_COUNT(): The number of rows updated</span><br></pre></td></tr></table></figure></p>
<p>判断一下 ROW_COUNT，如果是 0 的话，就条件不符，这时候我们在程序里面拿到的值就是空。<br>最终方案<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">outdate_time = now() - (random(10, 30))s</span><br><span class="line">result = sql.query('<span class="keyword">update</span> user_block_status <span class="keyword">set</span> updated_time=<span class="keyword">now</span>()，</span><br><span class="line">  user_id=<span class="keyword">LAST_INSERT_ID</span>(user_id) <span class="keyword">where</span> updated_time &lt; ?  <span class="keyword">order</span> <span class="keyword">by</span> updated_time <span class="keyword">asc</span> <span class="keyword">limit</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">select</span> * <span class="keyword">from</span> user_block_status <span class="keyword">where</span> user_id = <span class="keyword">LAST_INSERT_ID</span>()</span><br><span class="line">    <span class="keyword">and</span> <span class="keyword">ROW_COUNT</span>() &lt;&gt; <span class="number">0</span><span class="string">',</span></span><br><span class="line"><span class="string">  [outdate_time])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// do something with result[1].user_id</span></span><br></pre></td></tr></table></figure></p>
<p>当然，mysql 用来解决这种队列问题可能不是一个好的方案。队列相关的知识，我还在努力学习中。<br>参考资料：</p>
<ul>
<li><a href="http://www.cnblogs.com/zhoujinyi/p/3437475.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhoujinyi/p/3437475.html</a></li>
</ul>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/information-functions.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/information-functions.html</a></li>
</ul>
<p>转载自 <a href="https://ruby-china.org/topics/27814" target="_blank" rel="noopener">https://ruby-china.org/topics/27814</a></p>
<p>附：虽然用的是 ruby 语言，但其中最关键的还是 sql 语句。最近做个基于 laravel 的应用中使用到了队列的概念，因为对并发要求不高，所以直接用了 MariaDB，记下源码留作备用：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>\<span class="title">api</span>\<span class="title">v1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>\<span class="title">Controller</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Http</span>\<span class="title">Request</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">DB</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">server</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">create</span><span class="params">(Request $request)</span> </span>&#123;</span><br><span class="line">        $inputFilters = [</span><br><span class="line">            <span class="string">"gid"</span> =&gt; [<span class="string">"filter"</span> =&gt; FILTER_VALIDATE_INT, <span class="string">"options"</span> =&gt; [<span class="string">'min_range'</span> =&gt; <span class="number">1</span>]],</span><br><span class="line">            <span class="string">"sid"</span> =&gt; [<span class="string">"filter"</span> =&gt; FILTER_VALIDATE_INT, <span class="string">"options"</span> =&gt; [<span class="string">'min_range'</span> =&gt; <span class="number">1</span>]]</span><br><span class="line">        ];</span><br><span class="line">        $inputData = $request-&gt;all();</span><br><span class="line">        $insertData = filter_var_array($inputData, $inputFilters);</span><br><span class="line">        <span class="keyword">foreach</span> ($insertData <span class="keyword">as</span> $value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!$value) &#123;</span><br><span class="line">                <span class="keyword">return</span> response()-&gt;json([<span class="string">"errno"</span> =&gt; <span class="number">-1</span>], <span class="number">500</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        DB::table(<span class="string">'srv'</span>)</span><br><span class="line">            -&gt;where([</span><br><span class="line">                [<span class="string">'conf'</span>, <span class="string">'='</span>, $insertData[<span class="string">"gid"</span>]],</span><br><span class="line">                [<span class="string">'state'</span>, <span class="string">'='</span>, <span class="string">'0'</span>],</span><br><span class="line">                [<span class="string">'power'</span>, <span class="string">'='</span>, <span class="string">'0'</span>]</span><br><span class="line">            ])</span><br><span class="line">            -&gt;orderBy(<span class="string">'id'</span>, <span class="string">'desc'</span>)</span><br><span class="line">            -&gt;take(<span class="number">1</span>)</span><br><span class="line">            -&gt;update([</span><br><span class="line">                <span class="string">'state'</span> =&gt; <span class="number">1</span>,</span><br><span class="line">                <span class="string">'power'</span> =&gt; <span class="number">1</span>,</span><br><span class="line">                <span class="string">'sid'</span> =&gt; $insertData[<span class="string">"sid"</span>],</span><br><span class="line">                <span class="string">'id'</span> =&gt; DB::raw(<span class="string">'LAST_INSERT_ID(id)'</span>)</span><br><span class="line">            ]);</span><br><span class="line">        $data = DB::table(<span class="string">'srv'</span>)</span><br><span class="line">                    -&gt;where([</span><br><span class="line">                        [<span class="string">'id'</span>, <span class="string">'='</span>, DB::raw(<span class="string">'LAST_INSERT_ID()'</span>)],</span><br><span class="line">                        [DB::raw(<span class="string">'ROW_COUNT()'</span>), <span class="string">'&lt;&gt;'</span>, <span class="number">0</span>]</span><br><span class="line">                    ])</span><br><span class="line">                    -&gt;first();</span><br><span class="line">        <span class="keyword">if</span> (!$data) &#123;</span><br><span class="line">            <span class="keyword">return</span> response()-&gt;json([<span class="string">"errno"</span> =&gt; <span class="number">-2</span>], <span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response()-&gt;json([<span class="string">"errno"</span> =&gt; <span class="number">0</span>, <span class="string">"data"</span> =&gt; $data]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Web-开发/">Web 开发</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2016/12/27/一个简单的 MySQL 队列问题/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">下一页</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2018 403 Forbidden
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>