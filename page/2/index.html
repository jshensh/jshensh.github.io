<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 2 页 | 博客</title>

  
  <meta name="author" content="403 Forbidden">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="博客"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="博客" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">博客</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/about.html">关于</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2017/10/28/PHP无限级分类实现（递归+非递归）/"><span>PHP无限级分类实现（递归+非递归）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/10/28/PHP无限级分类实现（递归+非递归）/" rel="bookmark">
        <time class="entry-date published" datetime="2017-10-28T04:21:16.000Z">
          2017-10-28
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by PhpStorm.</span></span><br><span class="line"><span class="comment"> * User: qishou</span></span><br><span class="line"><span class="comment"> * Date: 15-8-2</span></span><br><span class="line"><span class="comment"> * Time: 上午12:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//准备数组，代替从数据库中检索出的数据(共有三个必须字段id,name,pid)</span></span><br><span class="line">header(<span class="string">"content-type:text/html;charset=utf-8"</span>);</span><br><span class="line">$categories = <span class="keyword">array</span>(</span><br><span class="line">    <span class="keyword">array</span>(<span class="string">'id'</span>=&gt;<span class="number">1</span>,<span class="string">'name'</span>=&gt;<span class="string">'电脑'</span>,<span class="string">'pid'</span>=&gt;<span class="number">0</span>),</span><br><span class="line">    <span class="keyword">array</span>(<span class="string">'id'</span>=&gt;<span class="number">2</span>,<span class="string">'name'</span>=&gt;<span class="string">'手机'</span>,<span class="string">'pid'</span>=&gt;<span class="number">0</span>),</span><br><span class="line">    <span class="keyword">array</span>(<span class="string">'id'</span>=&gt;<span class="number">3</span>,<span class="string">'name'</span>=&gt;<span class="string">'笔记本'</span>,<span class="string">'pid'</span>=&gt;<span class="number">1</span>),</span><br><span class="line">    <span class="keyword">array</span>(<span class="string">'id'</span>=&gt;<span class="number">4</span>,<span class="string">'name'</span>=&gt;<span class="string">'台式机'</span>,<span class="string">'pid'</span>=&gt;<span class="number">1</span>),</span><br><span class="line">    <span class="keyword">array</span>(<span class="string">'id'</span>=&gt;<span class="number">5</span>,<span class="string">'name'</span>=&gt;<span class="string">'智能机'</span>,<span class="string">'pid'</span>=&gt;<span class="number">2</span>),</span><br><span class="line">    <span class="keyword">array</span>(<span class="string">'id'</span>=&gt;<span class="number">6</span>,<span class="string">'name'</span>=&gt;<span class="string">'功能机'</span>,<span class="string">'pid'</span>=&gt;<span class="number">2</span>),</span><br><span class="line">    <span class="keyword">array</span>(<span class="string">'id'</span>=&gt;<span class="number">7</span>,<span class="string">'name'</span>=&gt;<span class="string">'超级本'</span>,<span class="string">'pid'</span>=&gt;<span class="number">3</span>),</span><br><span class="line">    <span class="keyword">array</span>(<span class="string">'id'</span>=&gt;<span class="number">8</span>,<span class="string">'name'</span>=&gt;<span class="string">'游戏本'</span>,<span class="string">'pid'</span>=&gt;<span class="number">3</span>),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*======================非递归实现========================*/</span></span><br><span class="line">$tree = <span class="keyword">array</span>();</span><br><span class="line"><span class="comment">//第一步，将分类id作为数组key,并创建children单元</span></span><br><span class="line"><span class="keyword">foreach</span>($categories <span class="keyword">as</span> $category)&#123;</span><br><span class="line">    $tree[$category[<span class="string">'id'</span>]] = $category;</span><br><span class="line">    $tree[$category[<span class="string">'id'</span>]][<span class="string">'children'</span>] = <span class="keyword">array</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二步，利用引用，将每个分类添加到父类children数组中，这样一次遍历即可形成树形结构。</span></span><br><span class="line"><span class="keyword">foreach</span>($tree <span class="keyword">as</span> $key=&gt;$item)&#123;</span><br><span class="line">    <span class="keyword">if</span>($item[<span class="string">'pid'</span>] != <span class="number">0</span>)&#123;</span><br><span class="line">        $tree[$item[<span class="string">'pid'</span>]][<span class="string">'children'</span>][] = &amp;$tree[$key];<span class="comment">//注意：此处必须传引用否则结果不对</span></span><br><span class="line">        <span class="keyword">if</span>($tree[$key][<span class="string">'children'</span>] == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">unset</span>($tree[$key][<span class="string">'children'</span>]); <span class="comment">//如果children为空，则删除该children元素（可选）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">////第三步，删除无用的非根节点数据</span></span><br><span class="line"><span class="keyword">foreach</span>($tree <span class="keyword">as</span> $key=&gt;$category)&#123;</span><br><span class="line">    <span class="keyword">if</span>($category[<span class="string">'pid'</span>] != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">unset</span>($tree[$key]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print_r($tree);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*======================递归实现========================*/</span></span><br><span class="line">$tree = $categories;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_attr</span><span class="params">($a,$pid)</span></span>&#123;</span><br><span class="line">    $tree = <span class="keyword">array</span>();                                <span class="comment">//每次都声明一个新数组用来放子元素</span></span><br><span class="line">    <span class="keyword">foreach</span>($a <span class="keyword">as</span> $v)&#123;</span><br><span class="line">        <span class="keyword">if</span>($v[<span class="string">'pid'</span>] == $pid)&#123;                      <span class="comment">//匹配子记录</span></span><br><span class="line">            $v[<span class="string">'children'</span>] = get_attr($a,$v[<span class="string">'id'</span>]); <span class="comment">//递归获取子记录</span></span><br><span class="line">            <span class="keyword">if</span>($v[<span class="string">'children'</span>] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">unset</span>($v[<span class="string">'children'</span>]);             <span class="comment">//如果子元素为空则unset()进行删除，说明已经到该分支的最后一个元素了（可选）</span></span><br><span class="line">            &#125;</span><br><span class="line">            $tree[] = $v;                           <span class="comment">//将记录存入新数组</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $tree;                                  <span class="comment">//返回新数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;"</span>;</span><br><span class="line"></span><br><span class="line">print_r(get_attr($tree,<span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p>转载自 <a href="http://blog.csdn.net/qishouzhang/article/details/47204359" target="_blank" rel="noopener">http://blog.csdn.net/qishouzhang/article/details/47204359</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Web-开发/">Web 开发</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2017/10/28/PHP无限级分类实现（递归+非递归）/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/03/20/aria2配置示例/"><span>aria2配置示例</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/03/20/aria2配置示例/" rel="bookmark">
        <time class="entry-date published" datetime="2017-03-20T07:16:30.000Z">
          2017-03-20
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>其实面对man的存在，写什么总结完全没有必要，一切宝藏都在<a href="http://aria2.sourceforge.net/manual/en/html/aria2c.html" target="_blank" rel="noopener">manual</a>。不过反正不会有人会读就是了。那我就写一下吧</p>
<p>##基础<br>首先，aria2或者叫做aria2c，它是一个下载器，嗯。<br>常用的两种模式是直接下载，比如 aria2c “<a href="http://host/file.zip&quot;" target="_blank" rel="noopener">http://host/file.zip&quot;</a> 这样，当它完成后就退出了，就像wget（估计你们也不知道吧）那样。<br>另一种就是rpc server模式，特点就是，它启动之后什么都不干，然后等着从rpc接口添加任务，下载完也不退出，而是一直等着。对，就像迅雷干的那样，当然，它不会上传你硬盘上的数据。<br>因为第一种方式要每次都敲命令，除非像我是原生nix，没有命令行就没法用电脑，估计也没什么用，于是常用的就是第二种。一般启动命令是 aria2c –enable-rpc –rpc-listen-all=true –rpc-allow-origin-all -c -D 。但是，其实*这个命令是不好的！不要使用这种启动方式。<br>首先，用命令方式导致配置不方便修改保存，-D导致无法看到出错信息。<br><strong>推荐启动方式是使用配置文件</strong> $HOME/.aria2/aria2.conf 。嗯，我知道路由上这个地址是无法修改或者重启后会丢失的，那么你可以放到别的地方，然后 aria2c –conf-path= 注意  填完整路径，因为鬼知道这个程序是从那个路径启动的。-D (用于后台执行, 这样ssh断开连接后程序不会退出） 只有在确认OK之后在启动脚本中使用。</p>
<p><strong>以下方案都基于配置文件方式</strong></p>
<p>##图形界面<br>aria2是没有图形界面的，已知相对好用的图形界面有：</p>
<ul>
<li><a href="https://github.com/binux/yaaw" target="_blank" rel="noopener">binux/yaaw</a></li>
</ul>
<ul>
<li><a href="https://github.com/ziahamza/webui-aria2" target="_blank" rel="noopener">ziahamza/webui-aria2</a></li>
</ul>
<p><strong>请使用chrome，firefox等现代浏览器访问</strong>。这两个东西都可以直接使用，除了看英文不爽以外，有什么必要下载回来使用？（吐槽：难道你们就不觉得webui-aria2的title总是被压成好几行，诡异的配色（对，说的就是那个蓝色背景，深蓝颜色的 Use custom IP and port settings 按钮）不难看吗？）<br>图形界面基本都基于RPC模式，所以一定<strong>确定开启了RPC，IP端口可访问，并且在管理器中填写了正确的地址</strong>。</p>
<p>##配置<br><strong>请将所有配置置于配置文件中<br>只有在确认配置无误后再加上 -D 选项<br>请阅读出错信息!</strong></p>
<p>###RPC<br>需要1.14及以上版本<br><a href="http://aria2.sourceforge.net/manual/en/html/aria2c.html#rpc-options" target="_blank" rel="noopener">http://aria2.sourceforge.net/manual/en/html/aria2c.html#rpc-options</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#允许rpc</span><br><span class="line">enable-rpc=true</span><br><span class="line">#允许所有来源, web界面跨域权限需要</span><br><span class="line">rpc-allow-origin-all=true</span><br><span class="line">#允许非外部访问</span><br><span class="line">rpc-listen-all=true</span><br><span class="line">#RPC端口, 仅当默认端口被占用时修改</span><br><span class="line">#rpc-listen-port=6800</span><br></pre></td></tr></table></figure></p>
<p>如果启动时出现 Initializing EpollEventPoll failed. 或相似错误, 在配置中加上 event-poll=select</p>
<p><strong>使用token验证（建议使用，需要1.18.4以上版本，帐号密码方式将在后续版本中停用！）</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># token验证</span><br><span class="line">rpc-secret=secret</span><br></pre></td></tr></table></figure></p>
<p>在YAAW中使用 <a href="http://token:secret@hostname:port/jsonrpc" target="_blank" rel="noopener">http://token:secret@hostname:port/jsonrpc</a> 的地址格式设置secret.<br>如果需要使用密码验证（需要1.15.2以上，1.18.6以下版本）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#用户名</span><br><span class="line">rpc-user=username</span><br><span class="line">#密码</span><br><span class="line">rpc-passwd=passwd</span><br></pre></td></tr></table></figure></p>
<p>在YAAW中使用 <a href="http://username:passwd@hostname:port/jsonrpc" target="_blank" rel="noopener">http://username:passwd@hostname:port/jsonrpc</a> 的地址格式设置密码.<br>对于RPC模式来说, 界面和后端是分离的, 只要给后端设置密码即可. 前端认证什么的是毫无意义的.<br>如果你比较新潮, 在YAAW中也可以用 ws:// 为前缀,只用websocket连接aria2c, 如果你不知道websocket是什么. 那就算了.</p>
<p>###速度相关<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#最大同时下载数(任务数), 路由建议值: 3</span><br><span class="line">max-concurrent-downloads=5</span><br><span class="line">#断点续传</span><br><span class="line">continue=true</span><br><span class="line">#同服务器连接数</span><br><span class="line">max-connection-per-server=5</span><br><span class="line">#最小文件分片大小, 下载线程数上限取决于能分出多少片, 对于小文件重要</span><br><span class="line">min-split-size=10M</span><br><span class="line">#单文件最大线程数, 路由建议值: 5</span><br><span class="line">split=10</span><br><span class="line">#下载速度限制</span><br><span class="line">max-overall-download-limit=0</span><br><span class="line">#单文件速度限制</span><br><span class="line">max-download-limit=0</span><br><span class="line">#上传速度限制</span><br><span class="line">max-overall-upload-limit=0</span><br><span class="line">#单文件速度限制</span><br><span class="line">max-upload-limit=0</span><br><span class="line">#断开速度过慢的连接</span><br><span class="line">#lowest-speed-limit=0</span><br><span class="line">#验证用，需要1.16.1之后的release版本</span><br><span class="line">#referer=*</span><br></pre></td></tr></table></figure></p>
<p>###进度保存相关<br>aria2c只有在正常退出时(ctrl-c), 突然断电是无法保存进度的. 在第一次使用的时候会出现会话文件不存在的错误, 手动创建一个空文件即可. 如果您编写的是自动启动脚本，在启动aria2前加上 touch aria2.session 这句命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input-file=/some/where/aria2.session</span><br><span class="line">save-session=/some/where/aria2.session</span><br><span class="line">#定时保存会话，需要1.16.1之后的release版</span><br><span class="line">#save-session-interval=60</span><br></pre></td></tr></table></figure></p>
<p>###磁盘相关<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#文件保存路径, 默认为当前启动位置</span><br><span class="line">dir=/some/where</span><br><span class="line">#文件缓存, 使用内置的文件缓存, 如果你不相信Linux内核文件缓存和磁盘内置缓存时使用, 需要1.16及以上版本</span><br><span class="line">#disk-cache=0</span><br><span class="line">#另一种Linux文件缓存方式, 使用前确保您使用的内核支持此选项, 需要1.15及以上版本(?)</span><br><span class="line">#enable-mmap=true</span><br><span class="line">#文件预分配, 能有效降低文件碎片, 提高磁盘性能. 缺点是预分配时间较长</span><br><span class="line">#所需时间 none &lt; falloc ? trunc &lt;&lt; prealloc, falloc和trunc需要文件系统和内核支持</span><br><span class="line">file-allocation=prealloc</span><br></pre></td></tr></table></figure></p>
<p>###BT相关<br><a href="http://aria2.sourceforge.net/manual/en/html/aria2c.html#bittorrent-specific-options" target="_blank" rel="noopener">http://aria2.sourceforge.net/manual/en/html/aria2c.html#bittorrent-specific-options</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#启用本地节点查找</span><br><span class="line">bt-enable-lpd=true</span><br><span class="line">#添加额外的tracker</span><br><span class="line">#bt-tracker=&lt;URI&gt;,…</span><br><span class="line">#单种子最大连接数</span><br><span class="line">#bt-max-peers=55</span><br><span class="line">#强制加密, 防迅雷必备</span><br><span class="line">#bt-require-crypto=true</span><br><span class="line">#当下载的文件是一个种子(以.torrent结尾)时, 自动下载BT</span><br><span class="line">follow-torrent=true</span><br><span class="line">#BT监听端口, 当端口屏蔽时使用</span><br><span class="line">#listen-port=6881-6999</span><br><span class="line">aria2亦可以用于PT下载, 下载的关键在于伪装</span><br><span class="line">#不确定是否需要，为保险起见，need more test</span><br><span class="line">enable-dht=false</span><br><span class="line">bt-enable-lpd=false</span><br><span class="line">enable-peer-exchange=false</span><br><span class="line">#修改特征</span><br><span class="line">user-agent=uTorrent/2210(25130)</span><br><span class="line">peer-id-prefix=-UT2210-</span><br><span class="line">#修改做种设置, 允许做种</span><br><span class="line">seed-ratio=0</span><br><span class="line">#保存会话</span><br><span class="line">force-save=true</span><br><span class="line">bt-hash-check-seed=true</span><br><span class="line">bt-seed-unverified=true</span><br><span class="line">bt-save-metadata=true</span><br><span class="line">#定时保存会话，需要1.16.1之后的某个release版本（比如1.16.2）</span><br><span class="line">#save-session-interval=60</span><br></pre></td></tr></table></figure></p>
<p>##常见问题</p>
<p>###Internal server error<br>手动访问你的JSON-RPC地址 <a href="http://hostname:port/jsonrpc?jsoncallback=1" target="_blank" rel="noopener">http://hostname:port/jsonrpc?jsoncallback=1</a> 如果没有返回, 请确认aria2是否启动以及连通性. 如果aria2在路由器后或没有公网IP, 请做好端口映射.</p>
<p>###如何使用迅雷离线<br><a href="http://binux.github.com/ThunderLixianExporter/" target="_blank" rel="noopener">http://binux.github.com/ThunderLixianExporter/</a><br>安装后, 在迅雷离线的右上角的设置中设置RPC地址.<br>提供chrome插件: <a href="https://chrome.google.com/webstore/detail/thunderlixianassistant/eehlmkfpnagoieibahhcghphdbjcdmen" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/thunderlixianassistant/eehlmkfpnagoieibahhcghphdbjcdmen</a></p>
<p>###如何使用旋风离线(QQ离线)<br><a href="http://userscripts.org/scripts/show/142624" target="_blank" rel="noopener">http://userscripts.org/scripts/show/142624</a><br>安装脚本后, 在旋风离线页面使用.</p>
<p>转载自 <a href="https://binux.blog/2012/12/aria2-examples/" target="_blank" rel="noopener">https://binux.blog/2012/12/aria2-examples/</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/VPS-技术/">VPS 技术</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2017/03/20/aria2配置示例/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/03/17/Managing Hierarchical Data in MySQL/"><span>Managing Hierarchical Data in MySQL</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/03/17/Managing Hierarchical Data in MySQL/" rel="bookmark">
        <time class="entry-date published" datetime="2017-03-16T20:50:14.000Z">
          2017-03-17
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><strong>引言</strong><br>大多数用户都曾在数据库中处理过分层数据(hierarchical data)，认为分层数据的管理不是关系数据库的目的。之所以这么认为，是因为关系数据库中的表没有层次关系，只是简单的平面化的列表；而分层数据具有父－子关系，显然关系数据库中的表不能自然地表现出其分层的特性。<br>我们认为，分层数据是每项只有一个父项和零个或多个子项（根项除外，根项没有父项）的数据集合。分层数据存在于许多基于数据库的应用程序中，包括论坛和邮件列表中的分类、商业组织图表、内容管理系统的分类、产品分类。我们打算使用下面一个虚构的电子商店的产品分类：<br><a href="/uploads/2017/03/1.png"><img src="/uploads/2017/03/1.png" alt=""></a><br>这些分类层次与上面提到的一些例子中的分类层次是相类似的。在本文中我们将从传统的邻接表(adjacency list)模型出发，阐述2种在MySQL中处理分层数据的模型。</p>
<p><strong>邻接表模型</strong><br>上述例子的分类数据将被存储在下面的数据表中（我给出了全部的数据表创建、数据插入的代码，你可以跟着做）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE category(</span><br><span class="line">category_id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">name VARCHAR(20) NOT NULL,</span><br><span class="line">parent INT DEFAULT NULL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO category</span><br><span class="line">VALUES(1,&apos;ELECTRONICS&apos;,NULL),(2,&apos;TELEVISIONS&apos;,1),(3,&apos;TUBE&apos;,2),</span><br><span class="line">(4,&apos;LCD&apos;,2),(5,&apos;PLASMA&apos;,2),(6,&apos;PORTABLE ELECTRONICS&apos;,1),</span><br><span class="line">(7,&apos;MP3 PLAYERS&apos;,6),(8,&apos;FLASH&apos;,7),</span><br><span class="line">(9,&apos;CD PLAYERS&apos;,6),(10,&apos;2 WAY RADIOS&apos;,6);</span><br><span class="line"></span><br><span class="line">SELECT * FROM category ORDER BY category_id;</span><br><span class="line"></span><br><span class="line">+-------------+----------------------+--------+</span><br><span class="line">| category_id | name                 | parent |</span><br><span class="line">+-------------+----------------------+--------+</span><br><span class="line">|           1 | ELECTRONICS          |   NULL |</span><br><span class="line">|           2 | TELEVISIONS          |      1 |</span><br><span class="line">|           3 | TUBE                 |      2 |</span><br><span class="line">|           4 | LCD                  |      2 |</span><br><span class="line">|           5 | PLASMA               |      2 |</span><br><span class="line">|           6 | PORTABLE ELECTRONICS |      1 |</span><br><span class="line">|           7 | MP3 PLAYERS          |      6 |</span><br><span class="line">|           8 | FLASH                |      7 |</span><br><span class="line">|           9 | CD PLAYERS           |      6 |</span><br><span class="line">|          10 | 2 WAY RADIOS         |      6 |</span><br><span class="line">+-------------+----------------------+--------+</span><br><span class="line">10 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>在邻接表模型中，数据表中的每项包含了指向其父项的指示器。在此例中，最上层项的父项为空值(NULL)。邻接表模型的优势在于它很简单，可以很容易地看出FLASH是MP3 PLAYERS的子项，哪个是portable electronics的子项，哪个是electronics的子项。虽然，在客户端编码中邻接表模型处理起来也相当的简单，但是如果是纯SQL编码的话，该模型会有很多问题。</p>
<p><strong>检索整树</strong><br>通常在处理分层数据时首要的任务是，以某种缩进形式来呈现一棵完整的树。为此，在纯SQL编码中通常的做法是使用自连接(self-join)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SELECT t1.name AS lev1, t2.name as lev2, t3.name as lev3, t4.name as lev4</span><br><span class="line">FROM category AS t1</span><br><span class="line">LEFT JOIN category AS t2 ON t2.parent = t1.category_id</span><br><span class="line">LEFT JOIN category AS t3 ON t3.parent = t2.category_id</span><br><span class="line">LEFT JOIN category AS t4 ON t4.parent = t3.category_id</span><br><span class="line">WHERE t1.name = &apos;ELECTRONICS&apos;;</span><br><span class="line"></span><br><span class="line">+-------------+----------------------+--------------+-------+</span><br><span class="line">| lev1        | lev2                 | lev3         | lev4  |</span><br><span class="line">+-------------+----------------------+--------------+-------+</span><br><span class="line">| ELECTRONICS | TELEVISIONS          | TUBE         | NULL  |</span><br><span class="line">| ELECTRONICS | TELEVISIONS          | LCD          | NULL  |</span><br><span class="line">| ELECTRONICS | TELEVISIONS          | PLASMA       | NULL  |</span><br><span class="line">| ELECTRONICS | PORTABLE ELECTRONICS | MP3 PLAYERS  | FLASH |</span><br><span class="line">| ELECTRONICS | PORTABLE ELECTRONICS | CD PLAYERS   | NULL  |</span><br><span class="line">| ELECTRONICS | PORTABLE ELECTRONICS | 2 WAY RADIOS | NULL  |</span><br><span class="line">+-------------+----------------------+--------------+-------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p><strong>检索所有叶子节点</strong><br>我们可以用左连接(LEFT JOIN)来检索出树中所有叶子节点(没有孩子节点的节点）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SELECT t1.name FROM</span><br><span class="line">category AS t1 LEFT JOIN category as t2</span><br><span class="line">ON t1.category_id = t2.parent</span><br><span class="line">WHERE t2.category_id IS NULL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+--------------+</span><br><span class="line">| name         |</span><br><span class="line">+--------------+</span><br><span class="line">| TUBE         |</span><br><span class="line">| LCD          |</span><br><span class="line">| PLASMA       |</span><br><span class="line">| FLASH        |</span><br><span class="line">| CD PLAYERS   |</span><br><span class="line">| 2 WAY RADIOS |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure></p>
<p><strong>检索单一路径</strong><br>通过自连接，我们也可以检索出单一路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT t1.name AS lev1, t2.name as lev2, t3.name as lev3, t4.name as lev4</span><br><span class="line">FROM category AS t1</span><br><span class="line">LEFT JOIN category AS t2 ON t2.parent = t1.category_id</span><br><span class="line">LEFT JOIN category AS t3 ON t3.parent = t2.category_id</span><br><span class="line">LEFT JOIN category AS t4 ON t4.parent = t3.category_id</span><br><span class="line">WHERE t1.name = &apos;ELECTRONICS&apos; AND t4.name = &apos;FLASH&apos;;</span><br><span class="line"></span><br><span class="line">+-------------+----------------------+-------------+-------+</span><br><span class="line">| lev1        | lev2                 | lev3        | lev4  |</span><br><span class="line">+-------------+----------------------+-------------+-------+</span><br><span class="line">| ELECTRONICS | PORTABLE ELECTRONICS | MP3 PLAYERS | FLASH |</span><br><span class="line">+-------------+----------------------+-------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure></p>
<p>这种方法的主要局限是你需要为每层数据添加一个自连接，随着层次的增加，自连接变得越来越复杂，检索的性能自然而然的也就下降了。</p>
<p><strong>邻接表模型的局限性</strong><br>用纯SQL编码实现邻接表模型有一定的难度。在我们检索某分类的路径之前，我们需要知道该分类所在的层次。另外，我们在删除节点的时候要特别小心，因为潜在的可能会孤立一棵子树（当删除portable electronics分类时，所有他的子分类都成了孤儿）。部分局限性可以通过使用客户端代码或者存储过程来解决，我们可以从树的底部开始向上迭代来获得一颗树或者单一路径，我们也可以在删除节点的时候使其子节点指向一个新的父节点，来防止孤立子树的产生。</p>
<p><strong>嵌套集合(Nested Set)模型</strong><br>我想在这篇文章中重点阐述一种不同的方法，俗称为嵌套集合模型。在嵌套集合模型中，我们将以一种新的方式来看待我们的分层数据，不再是线与点了，而是嵌套容器。我试着以嵌套容器的方式画出了electronics分类图：<br><a href="/uploads/2017/03/2.png"><img src="/uploads/2017/03/2.png" alt=""></a><br>从上图可以看出我们依旧保持了数据的层次，父分类包围了其子分类。在数据表中，我们通过使用表示节点的嵌套关系的左值(left value)和右值(right value)来表现嵌套集合模型中数据的分层特性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE nested_category (</span><br><span class="line"> category_id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line"> name VARCHAR(20) NOT NULL,</span><br><span class="line"> lft INT NOT NULL,</span><br><span class="line"> rgt INT NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO nested_category</span><br><span class="line">VALUES(1,&apos;ELECTRONICS&apos;,1,20),(2,&apos;TELEVISIONS&apos;,2,9),(3,&apos;TUBE&apos;,3,4),</span><br><span class="line">(4,&apos;LCD&apos;,5,6),(5,&apos;PLASMA&apos;,7,8),(6,&apos;PORTABLE ELECTRONICS&apos;,10,19),</span><br><span class="line">(7,&apos;MP3 PLAYERS&apos;,11,14),(8,&apos;FLASH&apos;,12,13),</span><br><span class="line">(9,&apos;CD PLAYERS&apos;,15,16),(10,&apos;2 WAY RADIOS&apos;,17,18);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT * FROM nested_category ORDER BY category_id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+-------------+----------------------+-----+-----+</span><br><span class="line">| category_id | name                 | lft | rgt |</span><br><span class="line">+-------------+----------------------+-----+-----+</span><br><span class="line">|           1 | ELECTRONICS          |   1 |  20 |</span><br><span class="line">|           2 | TELEVISIONS          |   2 |   9 |</span><br><span class="line">|           3 | TUBE                 |   3 |   4 |</span><br><span class="line">|           4 | LCD                  |   5 |   6 |</span><br><span class="line">|           5 | PLASMA               |   7 |   8 |</span><br><span class="line">|           6 | PORTABLE ELECTRONICS |  10 |  19 |</span><br><span class="line">|           7 | MP3 PLAYERS          |  11 |  14 |</span><br><span class="line">|           8 | FLASH                |  12 |  13 |</span><br><span class="line">|           9 | CD PLAYERS           |  15 |  16 |</span><br><span class="line">|          10 | 2 WAY RADIOS         |  17 |  18 |</span><br><span class="line">+-------------+----------------------+-----+-----+</span><br></pre></td></tr></table></figure></p>
<p>我们使用了lft和rgt来代替left和right，是因为在MySQL中left和right是保留字。<a href="http://dev.mysql.com/doc/mysql/en/reserved-words.html" target="_blank" rel="noopener">http://dev.mysql.com/doc/mysql/en/reserved-words.html</a>，有一份详细的MySQL保留字清单。<br>那么，我们怎样决定左值和右值呢？我们从外层节点的最左侧开始，从左到右编号：<br><a href="/uploads/2017/03/3.png"><img src="/uploads/2017/03/3.png" alt=""></a><br>这样的编号方式也同样适用于典型的树状结构：<br><a href="/uploads/2017/03/4.png"><img src="/uploads/2017/03/4.png" alt=""></a><br>当我们为树状的结构编号时，我们从左到右，一次一层，为节点赋右值前先从左到右遍历其子节点给其子节点赋左右值。这种方法被称作改进的<strong>先序遍历算法</strong>。</p>
<p><strong>检索整树</strong><br>我们可以通过自连接把父节点连接到子节点上来检索整树，是因为子节点的lft值总是在其父节点的lft值和rgt值之间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">SELECT node.name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">AND parent.name = &apos;ELECTRONICS&apos;</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+----------------------+</span><br><span class="line">| name                 |</span><br><span class="line">+----------------------+</span><br><span class="line">| ELECTRONICS          |</span><br><span class="line">| TELEVISIONS          |</span><br><span class="line">| TUBE                 |</span><br><span class="line">| LCD                  |</span><br><span class="line">| PLASMA               |</span><br><span class="line">| PORTABLE ELECTRONICS |</span><br><span class="line">| MP3 PLAYERS          |</span><br><span class="line">| FLASH                |</span><br><span class="line">| CD PLAYERS           |</span><br><span class="line">| 2 WAY RADIOS         |</span><br><span class="line">+----------------------+</span><br></pre></td></tr></table></figure></p>
<p>不像先前邻接表模型的例子，这个查询语句不管树的层次有多深都能很好的工作。在BETWEEN的子句中我们没有去关心node的rgt值，是因为使用node的rgt值得出的父节点总是和使用lft值得出的是相同的。</p>
<p><strong>检索所有叶子节点</strong><br>检索出所有的叶子节点，使用嵌套集合模型的方法比邻接表模型的LEFT JOIN方法简单多了。如果你仔细得看了nested_category表，你可能已经注意到叶子节点的左右值是连续的。要检索出叶子节点，我们只要查找满足rgt=lft+1的节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT name</span><br><span class="line">FROM nested_category</span><br><span class="line">WHERE rgt = lft + 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+--------------+</span><br><span class="line">| name         |</span><br><span class="line">+--------------+</span><br><span class="line">| TUBE         |</span><br><span class="line">| LCD          |</span><br><span class="line">| PLASMA       |</span><br><span class="line">| FLASH        |</span><br><span class="line">| CD PLAYERS   |</span><br><span class="line">| 2 WAY RADIOS |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure></p>
<p><strong>检索单一路径</strong><br>在嵌套集合模型中，我们可以不用多个自连接就可以检索出单一路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT parent.name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">AND node.name = &apos;FLASH&apos;</span><br><span class="line">ORDER BY parent.lft;</span><br><span class="line"></span><br><span class="line">+----------------------+</span><br><span class="line">| name                 |</span><br><span class="line">+----------------------+</span><br><span class="line">| ELECTRONICS          |</span><br><span class="line">| PORTABLE ELECTRONICS |</span><br><span class="line">| MP3 PLAYERS          |</span><br><span class="line">| FLASH                |</span><br><span class="line">+----------------------+</span><br></pre></td></tr></table></figure></p>
<p><strong>检索节点的深度</strong><br>我们已经知道怎样去呈现一棵整树，但是为了更好的标识出节点在树中所处层次，我们怎样才能检索出节点在树中的深度呢？我们可以在先前的查询语句上增加COUNT函数和GROUP BY子句来实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SELECT node.name, (COUNT(parent.name) - 1) AS depth</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">GROUP BY node.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line">+----------------------+-------+</span><br><span class="line">| name                 | depth |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| ELECTRONICS          |     0 |</span><br><span class="line">| TELEVISIONS          |     1 |</span><br><span class="line">| TUBE                 |     2 |</span><br><span class="line">| LCD                  |     2 |</span><br><span class="line">| PLASMA               |     2 |</span><br><span class="line">| PORTABLE ELECTRONICS |     1 |</span><br><span class="line">| MP3 PLAYERS          |     2 |</span><br><span class="line">| FLASH                |     3 |</span><br><span class="line">| CD PLAYERS           |     2 |</span><br><span class="line">| 2 WAY RADIOS         |     2 |</span><br><span class="line">+----------------------+-------+</span><br></pre></td></tr></table></figure></p>
<p>我们可以根据depth值来缩进分类名字，使用CONCAT和REPEAT字符串函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SELECT CONCAT( REPEAT(&apos; &apos;, COUNT(parent.name) - 1), node.name) AS name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">GROUP BY node.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line">+-----------------------+</span><br><span class="line">| name                  |</span><br><span class="line">+-----------------------+</span><br><span class="line">| ELECTRONICS           |</span><br><span class="line">|  TELEVISIONS          |</span><br><span class="line">|   TUBE                |</span><br><span class="line">|   LCD                 |</span><br><span class="line">|   PLASMA              |</span><br><span class="line">|  PORTABLE ELECTRONICS |</span><br><span class="line">|   MP3 PLAYERS         |</span><br><span class="line">|    FLASH              |</span><br><span class="line">|   CD PLAYERS          |</span><br><span class="line">|   2 WAY RADIOS        |</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure></p>
<p>当然，在客户端应用程序中你可能会用depth值来直接展示数据的层次。Web开发者会遍历该树，随着depth值的增加和减少来添加</p>
<ul>
<li>和</li>
</ul>
<p>标签。</p>
<p><strong>检索子树的深度</strong><br>当我们需要子树的深度信息时，我们不能限制自连接中的node或parent，因为这么做会打乱数据集的顺序。因此，我们添加了第三个自连接作为子查询，来得出子树新起点的深度值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">SELECT node.name, (COUNT(parent.name) - (sub_tree.depth + 1)) AS depth</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">	nested_category AS parent,</span><br><span class="line">	nested_category AS sub_parent,</span><br><span class="line">	(</span><br><span class="line">		SELECT node.name, (COUNT(parent.name) - 1) AS depth</span><br><span class="line">		FROM nested_category AS node,</span><br><span class="line">		nested_category AS parent</span><br><span class="line">		WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">		AND node.name = &apos;PORTABLE ELECTRONICS&apos;</span><br><span class="line">		GROUP BY node.name</span><br><span class="line">		ORDER BY node.lft</span><br><span class="line">	)AS sub_tree</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">	AND node.lft BETWEEN sub_parent.lft AND sub_parent.rgt</span><br><span class="line">	AND sub_parent.name = sub_tree.name</span><br><span class="line">GROUP BY node.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+----------------------+-------+</span><br><span class="line">| name                 | depth |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| PORTABLE ELECTRONICS |     0 |</span><br><span class="line">| MP3 PLAYERS          |     1 |</span><br><span class="line">| FLASH                |     2 |</span><br><span class="line">| CD PLAYERS           |     1 |</span><br><span class="line">| 2 WAY RADIOS         |     1 |</span><br><span class="line">+----------------------+-------+</span><br></pre></td></tr></table></figure></p>
<p>这个查询语句可以检索出任一节点子树的深度值，包括根节点。这里的深度值跟你指定的节点有关。</p>
<p><strong>检索节点的直接子节点</strong><br>可以想象一下，你在零售网站上呈现电子产品的分类。当用户点击分类后，你将要呈现该分类下的产品，同时也需列出该分类下的直接子分类，而不是该分类下的全部分类。为此，我们只呈现该节点及其直接子节点，不再呈现更深层次的节点。例如，当呈现PORTABLEELECTRONICS分类时，我们同时只呈现MP3 PLAYERS、CD PLAYERS和2 WAY RADIOS分类，而不呈现FLASH分类。</p>
<p>要实现它非常的简单，在先前的查询语句上添加HAVING子句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">SELECT node.name, (COUNT(parent.name) - (sub_tree.depth + 1)) AS depth</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">	nested_category AS parent,</span><br><span class="line">	nested_category AS sub_parent,</span><br><span class="line">	(</span><br><span class="line">		SELECT node.name, (COUNT(parent.name) - 1) AS depth</span><br><span class="line">		FROM nested_category AS node,</span><br><span class="line">		nested_category AS parent</span><br><span class="line">		WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">		AND node.name = &apos;PORTABLE ELECTRONICS&apos;</span><br><span class="line">		GROUP BY node.name</span><br><span class="line">		ORDER BY node.lft</span><br><span class="line">	)AS sub_tree</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">	AND node.lft BETWEEN sub_parent.lft AND sub_parent.rgt</span><br><span class="line">	AND sub_parent.name = sub_tree.name</span><br><span class="line">GROUP BY node.name</span><br><span class="line">HAVING depth &lt;= 1</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line">+----------------------+-------+</span><br><span class="line">| name                 | depth |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| PORTABLE ELECTRONICS |     0 |</span><br><span class="line">| MP3 PLAYERS          |     1 |</span><br><span class="line">| CD PLAYERS           |     1 |</span><br><span class="line">| 2 WAY RADIOS         |     1 |</span><br><span class="line">+----------------------+-------+</span><br></pre></td></tr></table></figure></p>
<p>如果你不希望呈现父节点，你可以更改<strong>HAVING depth &lt;= 1</strong>为<strong>HAVING depth = 1</strong>。</p>
<p><strong>嵌套集合模型中集合函数的应用</strong><br>让我们添加一个产品表，我们可以使用它来示例集合函数的应用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE product(</span><br><span class="line">product_id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">name VARCHAR(40),</span><br><span class="line">category_id INT NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO product(name, category_id) VALUES(&apos;20&quot; TV&apos;,3),(&apos;36&quot; TV&apos;,3),</span><br><span class="line">(&apos;Super-LCD 42&quot;&apos;,4),(&apos;Ultra-Plasma 62&quot;&apos;,5),(&apos;Value Plasma 38&quot;&apos;,5),</span><br><span class="line">(&apos;Power-MP3 5gb&apos;,7),(&apos;Super-Player 1gb&apos;,8),(&apos;Porta CD&apos;,9),(&apos;CD To go!&apos;,9),</span><br><span class="line">(&apos;Family Talk 360&apos;,10);</span><br><span class="line"></span><br><span class="line">SELECT * FROM product;</span><br><span class="line"></span><br><span class="line">+------------+-------------------+-------------+</span><br><span class="line">| product_id | name              | category_id |</span><br><span class="line">+------------+-------------------+-------------+</span><br><span class="line">|          1 | 20&quot; TV            |           3 |</span><br><span class="line">|          2 | 36&quot; TV            |           3 |</span><br><span class="line">|          3 | Super-LCD 42&quot;     |           4 |</span><br><span class="line">|          4 | Ultra-Plasma 62&quot;  |           5 |</span><br><span class="line">|          5 | Value Plasma 38&quot;  |           5 |</span><br><span class="line">|          6 | Power-MP3 128mb   |           7 |</span><br><span class="line">|          7 | Super-Shuffle 1gb |           8 |</span><br><span class="line">|          8 | Porta CD          |           9 |</span><br><span class="line">|          9 | CD To go!         |           9 |</span><br><span class="line">|         10 | Family Talk 360   |          10 |</span><br><span class="line">+------------+-------------------+-------------+</span><br></pre></td></tr></table></figure></p>
<p>现在，让我们写一个查询语句，在检索分类树的同时，计算出各分类下的产品数量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">SELECT parent.name, COUNT(product.name)</span><br><span class="line">FROM nested_category AS node ,</span><br><span class="line">nested_category AS parent,</span><br><span class="line">product</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">AND node.category_id = product.category_id</span><br><span class="line">GROUP BY parent.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+----------------------+---------------------+</span><br><span class="line">| name                 | COUNT(product.name) |</span><br><span class="line">+----------------------+---------------------+</span><br><span class="line">| ELECTRONICS          |                  10 |</span><br><span class="line">| TELEVISIONS          |                   5 |</span><br><span class="line">| TUBE                 |                   2 |</span><br><span class="line">| LCD                  |                   1 |</span><br><span class="line">| PLASMA               |                   2 |</span><br><span class="line">| PORTABLE ELECTRONICS |                   5 |</span><br><span class="line">| MP3 PLAYERS          |                   2 |</span><br><span class="line">| FLASH                |                   1 |</span><br><span class="line">| CD PLAYERS           |                   2 |</span><br><span class="line">| 2 WAY RADIOS         |                   1 |</span><br><span class="line">+----------------------+---------------------+</span><br></pre></td></tr></table></figure></p>
<p>这条查询语句在检索整树的查询语句上增加了COUNT和GROUP BY子句，同时在WHERE子句中引用了product表和一个自连接。</p>
<p><strong>新增节点</strong><br>到现在，我们已经知道了如何去查询我们的树，是时候去关注一下如何增加一个新节点来更新我们的树了。让我们再一次观察一下我们的嵌套集合图：<br><a href="/uploads/2017/03/5.png"><img src="/uploads/2017/03/5.png" alt=""></a><br>当我们想要在TELEVISIONS和PORTABLE ELECTRONICS节点之间新增一个节点，新节点的lft和rgt 的 值为10和11，所有该节点的右边节点的lft和rgt值都将加2，之后我们再添加新节点并赋相应的lft和rgt值。在MySQL 5中可以使用存储过程来完成，我假设当前大部分读者使用的是MySQL 4.1版本，因为这是最新的稳定版本。所以，我使用了锁表（LOCK TABLES）语句来隔离查询：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLE nested_category WRITE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT @myRight := rgt FROM nested_category</span><br><span class="line">WHERE name = &apos;TELEVISIONS&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UPDATE nested_category SET rgt = rgt + 2 WHERE rgt &gt; @myRight;</span><br><span class="line">UPDATE nested_category SET lft = lft + 2 WHERE lft &gt; @myRight;</span><br><span class="line"></span><br><span class="line">INSERT INTO nested_category(name, lft, rgt) VALUES(&apos;GAME CONSOLES&apos;, @myRight + 1, @myRight + 2);</span><br><span class="line"></span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure></p>
<p>我们可以检验一下新节点插入的正确性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SELECT CONCAT( REPEAT( &apos; &apos;, (COUNT(parent.name) - 1) ), node.name) AS name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">GROUP BY node.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+-----------------------+</span><br><span class="line">| name                  |</span><br><span class="line">+-----------------------+</span><br><span class="line">| ELECTRONICS           |</span><br><span class="line">|  TELEVISIONS          |</span><br><span class="line">|   TUBE                |</span><br><span class="line">|   LCD                 |</span><br><span class="line">|   PLASMA              |</span><br><span class="line">|  GAME CONSOLES        |</span><br><span class="line">|  PORTABLE ELECTRONICS |</span><br><span class="line">|   MP3 PLAYERS         |</span><br><span class="line">|    FLASH              |</span><br><span class="line">|   CD PLAYERS          |</span><br><span class="line">|   2 WAY RADIOS        |</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure></p>
<p>如果我们想要在叶子节点下增加节点，我们得稍微修改一下查询语句。让我们在2 WAYRADIOS叶子节点下添加FRS节点吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLE nested_category WRITE;</span><br><span class="line"></span><br><span class="line">SELECT @myLeft := lft FROM nested_category</span><br><span class="line"></span><br><span class="line">WHERE name = &apos;2 WAY RADIOS&apos;;</span><br><span class="line"></span><br><span class="line">UPDATE nested_category SET rgt = rgt + 2 WHERE rgt &gt; @myLeft;</span><br><span class="line">UPDATE nested_category SET lft = lft + 2 WHERE lft &gt; @myLeft;</span><br><span class="line"></span><br><span class="line">INSERT INTO nested_category(name, lft, rgt) VALUES(&apos;FRS&apos;, @myLeft + 1, @myLeft + 2);</span><br><span class="line"></span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，我们扩大了新产生的父节点(2 WAY RADIOS节点）的右值及其所有它的右边节点的左右值，之后置新增节点于新父节点之下。正如你所看到的，我们新增的节点已经完全融入了嵌套集合中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">SELECT CONCAT( REPEAT( &apos; &apos;, (COUNT(parent.name) - 1) ), node.name) AS name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">GROUP BY node.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+-----------------------+</span><br><span class="line">| name                  |</span><br><span class="line">+-----------------------+</span><br><span class="line">| ELECTRONICS           |</span><br><span class="line">|  TELEVISIONS          |</span><br><span class="line">|   TUBE                |</span><br><span class="line">|   LCD                 |</span><br><span class="line">|   PLASMA              |</span><br><span class="line">|  GAME CONSOLES        |</span><br><span class="line">|  PORTABLE ELECTRONICS |</span><br><span class="line">|   MP3 PLAYERS         |</span><br><span class="line">|    FLASH              |</span><br><span class="line">|   CD PLAYERS          |</span><br><span class="line">|   2 WAY RADIOS        |</span><br><span class="line">|    FRS                |</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure></p>
<p><strong>删除节点</strong><br>最后还有个基础任务，删除节点。删除节点的处理过程跟节点在分层数据中所处的位置有关，删除一个叶子节点比删除一个子节点要简单得多，因为删除子节点的时候，我们需要去处理孤立节点。<br>删除一个叶子节点的过程正好是新增一个叶子节点的逆过程，我们在删除节点的同时该节点右边所有节点的左右值和该父节点的右值都会减去该节点的宽度值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLE nested_category WRITE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT @myLeft := lft, @myRight := rgt, @myWidth := rgt - lft + 1</span><br><span class="line">FROM nested_category</span><br><span class="line">WHERE name = &apos;GAME CONSOLES&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELETE FROM nested_category WHERE lft BETWEEN @myLeft AND @myRight;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UPDATE nested_category SET rgt = rgt - @myWidth WHERE rgt &gt; @myRight;</span><br><span class="line">UPDATE nested_category SET lft = lft - @myWidth WHERE lft &gt; @myRight;</span><br><span class="line"></span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure></p>
<p>我们再一次检验一下节点已经成功删除,而且没有打乱数据的层次：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SELECT CONCAT( REPEAT( &apos; &apos;, (COUNT(parent.name) - 1) ), node.name) AS name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">GROUP BY node.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+-----------------------+</span><br><span class="line">| name                  |</span><br><span class="line">+-----------------------+</span><br><span class="line">| ELECTRONICS           |</span><br><span class="line">|  TELEVISIONS          |</span><br><span class="line">|   TUBE                |</span><br><span class="line">|   LCD                 |</span><br><span class="line">|   PLASMA              |</span><br><span class="line">|  PORTABLE ELECTRONICS |</span><br><span class="line">|   MP3 PLAYERS         |</span><br><span class="line">|    FLASH              |</span><br><span class="line">|   CD PLAYERS          |</span><br><span class="line">|   2 WAY RADIOS        |</span><br><span class="line">|    FRS                |</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure></p>
<p>这个方法可以完美地删除节点及其子节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLE nested_category WRITE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT @myLeft := lft, @myRight := rgt, @myWidth := rgt - lft + 1</span><br><span class="line">FROM nested_category</span><br><span class="line">WHERE name = &apos;MP3 PLAYERS&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELETE FROM nested_category WHERE lft BETWEEN @myLeft AND @myRight;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UPDATE nested_category SET rgt = rgt - @myWidth WHERE rgt &gt; @myRight;</span><br><span class="line">UPDATE nested_category SET lft = lft - @myWidth WHERE lft &gt; @myRight;</span><br><span class="line"></span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure></p>
<p>再次验证我们已经成功的删除了一棵子树：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SELECT CONCAT( REPEAT( &apos; &apos;, (COUNT(parent.name) - 1) ), node.name) AS name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">GROUP BY node.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+-----------------------+</span><br><span class="line">| name                  |</span><br><span class="line">+-----------------------+</span><br><span class="line">| ELECTRONICS           |</span><br><span class="line">|  TELEVISIONS          |</span><br><span class="line">|   TUBE                |</span><br><span class="line">|   LCD                 |</span><br><span class="line">|   PLASMA              |</span><br><span class="line">|  PORTABLE ELECTRONICS |</span><br><span class="line">|   CD PLAYERS          |</span><br><span class="line">|   2 WAY RADIOS        |</span><br><span class="line">|    FRS                |</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure></p>
<p>有时，我们只删除该节点，而不删除该节点的子节点。在一些情况下，你希望改变其名字为占位符，直到替代名字的出现，比如你开除了一个主管（需要更换主管）。在另外一些情况下，你希望子节点挂到该删除节点的父节点下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLE nested_category WRITE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT @myLeft := lft, @myRight := rgt, @myWidth := rgt - lft + 1</span><br><span class="line">FROM nested_category</span><br><span class="line">WHERE name = &apos;PORTABLE ELECTRONICS&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELETE FROM nested_category WHERE lft = @myLeft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UPDATE nested_category SET rgt = rgt - 1, lft = lft - 1 WHERE lft BETWEEN @myLeft AND @myRight;</span><br><span class="line">UPDATE nested_category SET rgt = rgt - 2 WHERE rgt &gt; @myRight;</span><br><span class="line">UPDATE nested_category SET lft = lft - 2 WHERE lft &gt; @myRight;</span><br><span class="line"></span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，我们对该节点所有右边节点的左右值都减去了2（因为不考虑其子节点，该节点的宽度为2），对该节点的子节点的左右值都减去了1（弥补由于失去父节点的左值造成的裂缝）。我们再一次确认，那些节点是否都晋升了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SELECT CONCAT( REPEAT( &apos; &apos;, (COUNT(parent.name) - 1) ), node.name) AS name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">GROUP BY node.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+---------------+</span><br><span class="line">| name          |</span><br><span class="line">+---------------+</span><br><span class="line">| ELECTRONICS   |</span><br><span class="line">|  TELEVISIONS  |</span><br><span class="line">|   TUBE        |</span><br><span class="line">|   LCD         |</span><br><span class="line">|   PLASMA      |</span><br><span class="line">|  CD PLAYERS   |</span><br><span class="line">|  2 WAY RADIOS |</span><br><span class="line">|   FRS         |</span><br><span class="line">+---------------+</span><br></pre></td></tr></table></figure></p>
<p>有时，当删除节点的时候，把该节点的一个子节点挂载到该节点的父节点下，而其他节点挂到该节点父节点的兄弟节点下，考虑到篇幅这种情况不在这里解说了。</p>
<p><strong>最后的思考</strong><br>我希望这篇文章对你有所帮助，SQL中的嵌套集合的观念大约有十年的历史了，在网上和一些书中都能找到许多相关信息。在我看来，讲述分层数据的管理最全面的，是来自一本名叫《Joe Celko’s Trees and Hierarchies in SQL for Smarties》的书，此书的作者是在高级SQL领域倍受尊敬的Joe Celko。Joe Celko被认为是嵌套集合模型的创造者，更是该领域内的多产作家。我把Celko的书当作无价之宝，并极力地推荐它。在这本书中涵盖了在此文中没有提及的一些高级话题，也提到了其他一些关于邻接表和嵌套集合模型下管理分层数据的方法。<br>在随后的参考书目章节中，我列出了一些网络资源，也许对你研究分层数据的管理会有所帮助，其中包括一些PHP相关的资源（处理嵌套集合的PHP库）。如果你还在使用邻接表模型，你该去试试嵌套集合模型了，在Storing Hierarchical Data in a Database 文中下方列出的一些资源链接中能找到一些样例代码，可以去试验一下。</p>
<p>转自 <a href="http://www.cnblogs.com/phaibin/archive/2009/06/09/1499687.html" target="_blank" rel="noopener">http://www.cnblogs.com/phaibin/archive/2009/06/09/1499687.html</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Web-开发/">Web 开发</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2017/03/17/Managing Hierarchical Data in MySQL/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2017/03/11/PHP 无极分类生成树状数组/"><span>PHP 无极分类生成树状数组</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/03/11/PHP 无极分类生成树状数组/" rel="bookmark">
        <time class="entry-date published" datetime="2017-03-11T06:35:49.000Z">
          2017-03-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$arr=[</span><br><span class="line">   [<span class="string">'id'</span> =&gt; <span class="number">1</span>, <span class="string">'text'</span> =&gt; <span class="string">'Parent 1'</span>, <span class="string">'pid'</span> =&gt; <span class="number">0</span>],</span><br><span class="line">   [<span class="string">'id'</span> =&gt; <span class="number">2</span>, <span class="string">'text'</span> =&gt; <span class="string">'Parent 2'</span>, <span class="string">'pid'</span> =&gt; <span class="number">0</span>],</span><br><span class="line">   [<span class="string">'id'</span> =&gt; <span class="number">3</span>, <span class="string">'text'</span> =&gt; <span class="string">'Parent 3'</span>, <span class="string">'pid'</span> =&gt; <span class="number">0</span>],</span><br><span class="line">   [<span class="string">'id'</span> =&gt; <span class="number">4</span>, <span class="string">'text'</span> =&gt; <span class="string">'Child 1'</span>, <span class="string">'pid'</span> =&gt; <span class="number">1</span>],</span><br><span class="line">   [<span class="string">'id'</span> =&gt; <span class="number">5</span>, <span class="string">'text'</span> =&gt; <span class="string">'Parent 4'</span>, <span class="string">'pid'</span> =&gt; <span class="number">0</span>],</span><br><span class="line">   [<span class="string">'id'</span> =&gt; <span class="number">6</span>, <span class="string">'text'</span> =&gt; <span class="string">'Child 2'</span>, <span class="string">'pid'</span> =&gt; <span class="number">1</span>],</span><br><span class="line">   [<span class="string">'id'</span> =&gt; <span class="number">7</span>, <span class="string">'text'</span> =&gt; <span class="string">'Child 3'</span>, <span class="string">'pid'</span> =&gt; <span class="number">1</span>],</span><br><span class="line">   [<span class="string">'id'</span> =&gt; <span class="number">8</span>, <span class="string">'text'</span> =&gt; <span class="string">'Parent 5'</span>, <span class="string">'pid'</span> =&gt; <span class="number">0</span>],</span><br><span class="line">   [<span class="string">'id'</span> =&gt; <span class="number">9</span>, <span class="string">'text'</span> =&gt; <span class="string">'Child 1'</span>, <span class="string">'pid'</span> =&gt; <span class="number">2</span>],</span><br><span class="line">   [<span class="string">'id'</span> =&gt; <span class="number">10</span>, <span class="string">'text'</span> =&gt; <span class="string">'Child 4'</span>, <span class="string">'pid'</span> =&gt; <span class="number">1</span>],</span><br><span class="line">   [<span class="string">'id'</span> =&gt; <span class="number">11</span>, <span class="string">'text'</span> =&gt; <span class="string">'Child 1'</span>, <span class="string">'pid'</span> =&gt; <span class="number">5</span>],</span><br><span class="line">   [<span class="string">'id'</span> =&gt; <span class="number">12</span>, <span class="string">'text'</span> =&gt; <span class="string">'GrandChild 1'</span>, <span class="string">'pid'</span> =&gt; <span class="number">10</span>]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">createTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> $table = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">tree</span><span class="params">($pid = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        $tree = <span class="keyword">array</span>();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">self</span>::$table <span class="keyword">as</span> $row) &#123;</span><br><span class="line">            <span class="keyword">if</span> ($row[<span class="string">'pid'</span>] === $pid) &#123;</span><br><span class="line">                $tmp = <span class="keyword">self</span>::tree($row[<span class="string">'id'</span>]);</span><br><span class="line">                <span class="keyword">if</span> ($tmp) &#123;</span><br><span class="line">                    $row[<span class="string">'children'</span>] = $tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                $tree[] = $row;                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $tree;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">($table)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">self</span>::$table = $table;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>::tree();        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump(createTree::get($arr));</span><br></pre></td></tr></table></figure>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Web-开发/">Web 开发</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2017/03/11/PHP 无极分类生成树状数组/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/12/27/一个简单的 MySQL 队列问题/"><span>一个简单的 MySQL 队列问题</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/12/27/一个简单的 MySQL 队列问题/" rel="bookmark">
        <time class="entry-date published" datetime="2016-12-26T23:47:23.000Z">
          2016-12-27
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>最近有个朋友要实现队列任务方面的工作，我们就 mysql(innodb) 的事务和锁的特性聊了一些有趣的话题。<br>其中，最终的解决方案来自大神 <a href="https://github.com/fengmk2" target="_blank" rel="noopener">https://github.com/fengmk2</a> 之前的一个队列实现。 我做了一个小改进，使得之前表级锁的表现可以恢复到行级锁水平。</p>
<p>任务的大致描述是这样的：<br>有一个表，里面存了很多的用户id，大概100w条，表的结构简化如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user_block_status &#123;</span><br><span class="line">  user_id <span class="built_in">bigint</span> // 用户的<span class="keyword">id</span></span><br><span class="line">  <span class="keyword">status</span> <span class="built_in">int</span> // 用户的状态。<span class="number">1</span> ok <span class="number">2</span> <span class="keyword">not</span> ok</span><br><span class="line">  updated_time <span class="keyword">timestamp</span> // 更新时间戳</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个表里面，每隔10秒就要去检查用户是否存在违规页面。如果存在的话，则需要把 status 置为 2，默认是 1。<br>有 100 个 worker 会并发地从表里面读取 user_id，所以我们要设计一个策略，使得这 100 个 worker 在并发时， 读到的是独立的 100 个条目。</p>
<p><strong>方案1</strong><br>一开始的方案是这样的：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 这一句不一定会发请求，可能会优化成跟接下来的第一个 query 一起发出</span><br><span class="line">sql.begin_transaction</span><br><span class="line"></span><br><span class="line">// 第一次io发生。</span><br><span class="line">// 如果一个用户在 10s 内没有被更新，那么取出来</span><br><span class="line">// 这时候由于程序拿得到 user_id 的值，所以网络io是发生了的。否则拿不到 user_id 的值</span><br><span class="line">outdate_time = now() - 10s</span><br><span class="line">line = sql.query('<span class="keyword">select</span> user_id <span class="keyword">where</span> updated_time &lt; ? <span class="keyword">order</span> <span class="keyword">by</span> updated_time <span class="keyword">asc</span> <span class="keyword">limit</span> <span class="number">1</span><span class="string">', [outdate_time])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 第二次 io 发生</span></span><br><span class="line"><span class="string">// 更新这一行的 updated_time，免得被其他worker重复读取</span></span><br><span class="line"><span class="string">user_id = line.user_id</span></span><br><span class="line"><span class="string">sql.query('</span><span class="keyword">update</span> user_block_status <span class="keyword">set</span> updated_time=<span class="keyword">now</span>() <span class="keyword">where</span> user_id = ?<span class="string">',</span></span><br><span class="line"><span class="string">  [user_id])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 第三次 io 发生</span></span><br><span class="line"><span class="string">sql.commit</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// do something with user_id</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，这个地方我们发起了 3 次 io 请求。当然，请求数不是很关键，因为请求数以及对应的时间是一个恒定量， 而随着 worker 的增加，这一块并不会带来额外的性能瓶颈。但由于我们使用了事务，所以当 worker 由 100 增加到 1000 的时候，数据库由于存在大量的事务操作，这些事务都需要掌握写锁，所以有潜在的写锁排队问题。<br>而且关键是，方案是不可行的，根本没有起到队列的效果。<br>为什么呢？我们假设网络io无限快，而数据库每条语句的执行时间是1s，那么我们这个事务的执行时间是 2s。 这时如果 3 个 worker 并发地在同一秒（00:00）执行，那么假设 worker1 读到的 user_id 是 10086， 由于读锁是共享的，worker2 和 worker3 读到的 user_id 也是 10086。这时他们三个都想要更新 10086 的值， 而 worker1 抢先加了写锁，所以 worker2 和 worker3 就需要等待 worker1 的事务执行完毕， 才能重新获得 10086 的写锁并进行写入。 所以当 worker2 执行的时候，是 00:02 的时候，当 worker3 执行的时候，是 00:04 的时刻。 而且由于他们都是在对 10086 进行更新，所以没有起到队列的效果。<br>这里的查询条件太特殊，导致所有并发的事务需要的都是同一条数据， 这时候 innodb 行级锁的特性也没有发挥出来。<br>这个方案不仅并发时的表现类似表级锁的特性，而且也没有达到队列的效果。</p>
<p><strong>方案2</strong><br>将 update 语句在先，select 语句在后。<br>update 语句改成<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">outdate_time = now() - 10s</span><br><span class="line">result = sql.query('<span class="keyword">update</span> user_block_status <span class="keyword">set</span> updated_time=<span class="keyword">now</span>() <span class="keyword">where</span> updated_time &lt; ?   <span class="keyword">order</span> <span class="keyword">by</span> updated_time <span class="keyword">asc</span> <span class="keyword">limit</span> <span class="number">1</span><span class="string">',</span></span><br><span class="line"><span class="string">  [outdate_time])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## each worker can get different result.user_id</span></span><br></pre></td></tr></table></figure></p>
<p>这样在 update 的时候，3 个 worker 会排队，分别更新不同的 user_id 条目。然后返回来的 也是不同的 user_id。<br>可关键是，update 语句并不会将被 update 了的 id 返回给程序，所以我们后面的 select 语句拿不到对应的 user_id。 这个方案先否决。</p>
<p><strong>方案3</strong><br>方案1的基础上，在 select 语句中，手工地干扰一下，使得不同的 worker 取到不同的条目<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">outdate_time = now() - 10s</span><br><span class="line">random_number = random_int(0, worker_count * 2)</span><br><span class="line">line = sql.query('<span class="keyword">select</span> user_id <span class="keyword">where</span> updated_time &lt; ?  <span class="keyword">order</span> <span class="keyword">by</span> updated_time <span class="keyword">asc</span> <span class="keyword">limit</span> <span class="number">1</span> <span class="keyword">offset</span> ?<span class="string">',</span></span><br><span class="line"><span class="string">  [outdate_time, random_number])</span></span><br></pre></td></tr></table></figure></p>
<p>这时，我们的 worker 有很大的几率可以取出不同 user_id。但这里也还有个问题就是，很可能两个 worker 的 random_number 是同一个值。那么就发生了两次重复读取，不过对于我们的业务来说，重复读取只会造成资源的浪费， 而不会带来数据一致性的问题。只要尽量减少重复读的几率，那么这个方案就是可被接受的。<br>其中 worker_count * 2 是拍脑袋决定的数，如果数据库中始终有大量需要处理的数据，可以加大点。</p>
<p><strong>方案4</strong><br>方案3还是挺不完美的，虽然能解决问题，但是从概念上来说，我们需要的是队列。 队列的意思就是：排队！排队！排队！<br>方案3只是从业务逻辑层面出发，做出了一些规避，模拟了我们需要的效果。<br>那么回到方案2，其实方案2是更接近队列的。因为不同的 worker 真正在等待另一个 worker 更新东西。 可方案2无奈的是，我们拿不到被更新的id。那么有没有办法拿到呢？<br>其实是有的，用 mysql 的 LAST_INSERT_ID() 函数。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LAST_INSERT_ID(): Value of the AUTOINCREMENT column for the last <span class="keyword">INSERT</span></span><br></pre></td></tr></table></figure></p>
<p>关于这个函数可以看看 <a href="https://dev.mysql.com/doc/refman/5.7/en/information-functions.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/information-functions.html</a> 这里的详细介绍。<br>这个函数本来的含义是，拿到 AUTO_INCREMENT 那一列的最新值。也就是我们最新 insert 进表的那个 id。 但实际上，它也可以作为一个 sql 语句中的变量来使用，它可以被赋值，然后取出。 而且它的作用域是同一 connection 内，这样我们多个 worker 如果对 LAST_INSERT_ID 赋了不同的值， 也不会互相干扰，因为不同的 worker 使用不同的 connection。<br>这时，我们的查询在方案2的基础上就变成：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sql.begin_transaction</span><br><span class="line"></span><br><span class="line">outdate_time = now() - 10s</span><br><span class="line">sql.query('<span class="keyword">update</span> user_block_status <span class="keyword">set</span> updated_time=<span class="keyword">now</span>()，</span><br><span class="line"> <span class="keyword">id</span>=<span class="keyword">LAST_INSERT_ID</span>(<span class="keyword">id</span>) <span class="keyword">where</span> updated_time &lt; ?  <span class="keyword">order</span> <span class="keyword">by</span> updated_time <span class="keyword">asc</span> <span class="keyword">limit</span> <span class="number">1</span><span class="string">',</span></span><br><span class="line"><span class="string">  [outdate_time])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">line = sql.query('</span><span class="keyword">select</span> user_id <span class="keyword">where</span> <span class="keyword">id</span> = <span class="keyword">LAST_INSERT_ID</span>()<span class="string">')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## do sth with line.user_id</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">sql.commit</span></span><br></pre></td></tr></table></figure></p>
<p>ok，已经能排队了，业务上已经可以满足了。<br>目前性能上说，网络io还是三个，而且，【行级锁】没有被利用的特定依然存在。 写锁依然要排队，为什么这么说？因为不管 worker 有多少个，当他们并发的时候，where 条件都始终把它们 指向同一行数据，所以还是要为了同一行数据排队。即使目前我们已经达成了【排队之后，互相更新不同条目】这个目的。<br>方案4就总的性价比来说，目前跟方案3相比，还不一定谁好谁坏。 方案4的性能在于多个worker抢一个锁，大家总是等；方案3是无脑乱取，造成资源浪费，降低worker的效率，浪费机器。<br>什么情况下方案3好？ 如果总是有一大堆数据没有被处理的话，那么把方案3的乱取范围开大点，就能更好避免浪费。 而当一大堆数据等待处理的时候，方案4却不停在排队，这就等于堵住了。<br>还有一种情况就是，方案4的写锁排队已经成为瓶颈。但其实这跟上面是一回事，当总是有一大堆 worker 来取 东西的话，说明就是有一大堆数据没有被处理。否则开那么多 worker 干嘛。<br>什么情况下方案4好？ 前提就是，写锁排队并不成为瓶颈。如果要处理的数据并不是那么多，那么使用方案4的话，可以降低我们需要的 worker 数量，节约机器。 而且 worker 数量评估可以更加理性。</p>
<p><strong>方案5</strong><br>那么，我们把方案3的 offset 思想加进来吧。可惜啊可惜，update 语法只支持 limit，不支持 offset。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> [<span class="keyword">LOW_PRIORITY</span>] [<span class="keyword">IGNORE</span>] table_reference</span><br><span class="line">    <span class="keyword">SET</span> col_name1=&#123;expr1|<span class="keyword">DEFAULT</span>&#125; [, col_name2=&#123;expr2|<span class="keyword">DEFAULT</span>&#125;] ...</span><br><span class="line">    [<span class="keyword">WHERE</span> where_condition]</span><br><span class="line">    [<span class="keyword">ORDER</span> <span class="keyword">BY</span> ...]</span><br><span class="line">    [<span class="keyword">LIMIT</span> <span class="keyword">row_count</span>]</span><br></pre></td></tr></table></figure></p>
<p>那就绕一绕。<br>不用 offset，而是通过更改 outdate_time 的值，让他们获得不同的行数据。<br>我们的程序是要求 10s 算作过期，那么 11s、20s、30s 肯定也算过期吧。那就这样写：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 在 10 到 30s 之间随机取值</span><br><span class="line">outdate_time = now() - (random(10, 30))s</span><br><span class="line">sql.query('<span class="keyword">update</span> user_block_status <span class="keyword">set</span> updated_time=<span class="keyword">now</span>()，</span><br><span class="line"> <span class="keyword">id</span>=<span class="keyword">LAST_INSERT_ID</span>(<span class="keyword">id</span>) <span class="keyword">where</span> updated_time &lt; ?  <span class="keyword">order</span> <span class="keyword">by</span> updated_time <span class="keyword">asc</span>  <span class="keyword">limit</span> <span class="number">1</span><span class="string">',</span></span><br><span class="line"><span class="string">  [outdate_time])</span></span><br><span class="line"><span class="string">where updated_time &lt; now() - 10s 与 where updated_time &lt; now() - 12s 与 where updated_time &lt; now() - 15s</span></span><br><span class="line"><span class="string">//（不要在 where 条件里面写计算，这只是示例） 还是有可能锁定同一条数据。但至少，这个方案既利用上了行级锁，也不会造成多个 worker 处理同一 user_id 的 资源浪费。</span></span><br></pre></td></tr></table></figure></p>
<p><strong>方案6</strong><br>锁的问题差不多就这么解决了。<br>我们再回头看看，发现还有个 io 问题可以再弄弄。现在还是 3 个 io 嘛。<br>其实到了现在这步，begin_transaction 可以去掉了。因为我们只有一个涉及写锁的操作在里面，这个操作本身作为单一语句， 就已经是原子性的了。<br>但由于我们利用了 LAST_INSERT_ID，所以我们要保证 update 语句和它之后的 select 语句在同一个 connection 中。<br>很多的 mysql 库实现都是用了连接池的，所以同一段代码中的两条 sql 有可能会利用两条 connection， 导致得到我们非预期的 user_id。<br>但就我们的业务来说，LAST_INSERT_ID 混了其实是没关系的。每个 worker 始终还是会得到一个 unique 的 user_id。 这就够了。那么我们也不必加一些多余的逻辑，保证这两条语句取到同一个 connection。<br>这时，io 操作从 3，降低到了 2。<br>那么，有没有可能降到 1 呢。<br>其实也可以啊…………因为基本所有 mysql 库都支持 multistatements 特性。<br>我们可以在一条 query 写两个语句，返回接口会是一个数组，分别表示这两个语句的值。<br>类似这样，sql.query(‘update …..; select ….;’)。这是支持的。而且这么一来， 同一 connection 的问题也解决了。避免为以后留坑。<br>重写方案<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">outdate_time = now() - (random(10, 30))s</span><br><span class="line">result = sql.query('<span class="keyword">update</span> user_block_status <span class="keyword">set</span> updated_time=<span class="keyword">now</span>()，</span><br><span class="line"> user_id=<span class="keyword">LAST_INSERT_ID</span>(user_id) <span class="keyword">where</span> updated_time &lt; ?  <span class="keyword">order</span> <span class="keyword">by</span> updated_time <span class="keyword">asc</span> <span class="keyword">limit</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">select</span> * <span class="keyword">from</span> user_block_status <span class="keyword">where</span> user_id = <span class="keyword">LAST_INSERT_ID</span>()<span class="string">',</span></span><br><span class="line"><span class="string">  [outdate_time])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// do something with result[1].user_id</span></span><br></pre></td></tr></table></figure></p>
<p>。。。。。。。。。。。。。<br>还是有坑的。。。。。。。。。。。。。。。<br>如果 where updated_time &lt; ? 一条都不命中，那么会发生什么结果？<br>首先，update 没有改变任何行。而 LAST_INSERT_ID 还是会返回一个合理的 id，有可能是真正的 LAST_INSERT_ID， 也可能是这条 connection 中上次手工设置的。<br>在这里可以多说一下 LAST_INSERT_ID 的特性。默认情况下，LAST_INSERT_ID() 不带参数会返回最新插入那条的 id。 带参数的情况下 LAST_INSERT_ID(id) 本身的返回值就是参数，然后在接下来的调用中，如果不发生任何 insert，那么 值会在 connection 中一直保持。如果发生了 insert，就会被更新。<br>如果不处理这个 update nothing 的异常情况，当队列全部被处理完的时候， 我们的 worker 会一直工作，不会停下来。所以我们要在取 LAST_INSERT_ID 的值时， 判断一下上一条 update 语句到底有没有发生作用。<br>这时候我们需要用到另一个跟 LAST_INSERT_ID 一起出现在文档中的函数，<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROW_COUNT(): The number of rows updated</span><br></pre></td></tr></table></figure></p>
<p>判断一下 ROW_COUNT，如果是 0 的话，就条件不符，这时候我们在程序里面拿到的值就是空。<br>最终方案<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">outdate_time = now() - (random(10, 30))s</span><br><span class="line">result = sql.query('<span class="keyword">update</span> user_block_status <span class="keyword">set</span> updated_time=<span class="keyword">now</span>()，</span><br><span class="line">  user_id=<span class="keyword">LAST_INSERT_ID</span>(user_id) <span class="keyword">where</span> updated_time &lt; ?  <span class="keyword">order</span> <span class="keyword">by</span> updated_time <span class="keyword">asc</span> <span class="keyword">limit</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">select</span> * <span class="keyword">from</span> user_block_status <span class="keyword">where</span> user_id = <span class="keyword">LAST_INSERT_ID</span>()</span><br><span class="line">    <span class="keyword">and</span> <span class="keyword">ROW_COUNT</span>() &lt;&gt; <span class="number">0</span><span class="string">',</span></span><br><span class="line"><span class="string">  [outdate_time])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// do something with result[1].user_id</span></span><br></pre></td></tr></table></figure></p>
<p>当然，mysql 用来解决这种队列问题可能不是一个好的方案。队列相关的知识，我还在努力学习中。<br>参考资料：</p>
<ul>
<li><a href="http://www.cnblogs.com/zhoujinyi/p/3437475.html" target="_blank" rel="noopener">http://www.cnblogs.com/zhoujinyi/p/3437475.html</a></li>
</ul>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/information-functions.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/information-functions.html</a></li>
</ul>
<p>转载自 <a href="https://ruby-china.org/topics/27814" target="_blank" rel="noopener">https://ruby-china.org/topics/27814</a></p>
<p>附：虽然用的是 ruby 语言，但其中最关键的还是 sql 语句。最近做个基于 laravel 的应用中使用到了队列的概念，因为对并发要求不高，所以直接用了 MariaDB，记下源码留作备用：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>\<span class="title">api</span>\<span class="title">v1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>\<span class="title">Controller</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Http</span>\<span class="title">Request</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">DB</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">server</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">create</span><span class="params">(Request $request)</span> </span>&#123;</span><br><span class="line">        $inputFilters = [</span><br><span class="line">            <span class="string">"gid"</span> =&gt; [<span class="string">"filter"</span> =&gt; FILTER_VALIDATE_INT, <span class="string">"options"</span> =&gt; [<span class="string">'min_range'</span> =&gt; <span class="number">1</span>]],</span><br><span class="line">            <span class="string">"sid"</span> =&gt; [<span class="string">"filter"</span> =&gt; FILTER_VALIDATE_INT, <span class="string">"options"</span> =&gt; [<span class="string">'min_range'</span> =&gt; <span class="number">1</span>]]</span><br><span class="line">        ];</span><br><span class="line">        $inputData = $request-&gt;all();</span><br><span class="line">        $insertData = filter_var_array($inputData, $inputFilters);</span><br><span class="line">        <span class="keyword">foreach</span> ($insertData <span class="keyword">as</span> $value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!$value) &#123;</span><br><span class="line">                <span class="keyword">return</span> response()-&gt;json([<span class="string">"errno"</span> =&gt; <span class="number">-1</span>], <span class="number">500</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        DB::table(<span class="string">'srv'</span>)</span><br><span class="line">            -&gt;where([</span><br><span class="line">                [<span class="string">'conf'</span>, <span class="string">'='</span>, $insertData[<span class="string">"gid"</span>]],</span><br><span class="line">                [<span class="string">'state'</span>, <span class="string">'='</span>, <span class="string">'0'</span>],</span><br><span class="line">                [<span class="string">'power'</span>, <span class="string">'='</span>, <span class="string">'0'</span>]</span><br><span class="line">            ])</span><br><span class="line">            -&gt;orderBy(<span class="string">'id'</span>, <span class="string">'desc'</span>)</span><br><span class="line">            -&gt;take(<span class="number">1</span>)</span><br><span class="line">            -&gt;update([</span><br><span class="line">                <span class="string">'state'</span> =&gt; <span class="number">1</span>,</span><br><span class="line">                <span class="string">'power'</span> =&gt; <span class="number">1</span>,</span><br><span class="line">                <span class="string">'sid'</span> =&gt; $insertData[<span class="string">"sid"</span>],</span><br><span class="line">                <span class="string">'id'</span> =&gt; DB::raw(<span class="string">'LAST_INSERT_ID(id)'</span>)</span><br><span class="line">            ]);</span><br><span class="line">        $data = DB::table(<span class="string">'srv'</span>)</span><br><span class="line">                    -&gt;where([</span><br><span class="line">                        [<span class="string">'id'</span>, <span class="string">'='</span>, DB::raw(<span class="string">'LAST_INSERT_ID()'</span>)],</span><br><span class="line">                        [DB::raw(<span class="string">'ROW_COUNT()'</span>), <span class="string">'&lt;&gt;'</span>, <span class="number">0</span>]</span><br><span class="line">                    ])</span><br><span class="line">                    -&gt;first();</span><br><span class="line">        <span class="keyword">if</span> (!$data) &#123;</span><br><span class="line">            <span class="keyword">return</span> response()-&gt;json([<span class="string">"errno"</span> =&gt; <span class="number">-2</span>], <span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> response()-&gt;json([<span class="string">"errno"</span> =&gt; <span class="number">0</span>, <span class="string">"data"</span> =&gt; $data]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Web-开发/">Web 开发</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2016/12/27/一个简单的 MySQL 队列问题/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/12/23/jQuery(selector).html() 过滤 script tag 的解决方法/"><span>jQuery(selector).html() 过滤 script tag 的解决方法</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/12/23/jQuery(selector).html() 过滤 script tag 的解决方法/" rel="bookmark">
        <time class="entry-date published" datetime="2016-12-23T09:59:20.000Z">
          2016-12-23
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>　　之前用 pjax 做个项目，使用了 .html() 方法将获取到的数据插入 container。但是却发现其会自动过滤 script tag，现找到解决方法 (<a href="http://stackoverflow.com/questions/4079179/jquery-html-strips-out-script-tags" target="_blank" rel="noopener">jquery html() strips out script tags</a>)，在此记录一下<br>　　以下是我应用到项目里的部分代码，对 stackoverflow 的答案多进行了一次判断<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).on(<span class="string">"pjax:end"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> responseDom = $(data.responseText);</span><br><span class="line">    <span class="keyword">if</span> (!$(event.target).filter(<span class="string">"script"</span>).length) &#123;</span><br><span class="line">        responseDom.filter(<span class="string">'script'</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.src) &#123;</span><br><span class="line">                <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>), i, attrName, attrValue, attrs = <span class="keyword">this</span>.attributes;</span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; attrs.length; i++) &#123;</span><br><span class="line">                    attrName = attrs[i].name;</span><br><span class="line">                    attrValue = attrs[i].value;</span><br><span class="line">                    script[attrName] = attrValue;</span><br><span class="line">                &#125;</span><br><span class="line">                event.target.appendChild(script);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                $.globalEval(<span class="keyword">this</span>.text || <span class="keyword">this</span>.textContent || <span class="keyword">this</span>.innerHTML || <span class="string">''</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Web-开发/">Web 开发</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2016/12/23/jQuery(selector).html() 过滤 script tag 的解决方法/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/10/27/安装 Laravel，撞墙，采用 Packageist 的中国镜像/"><span>安装 Laravel，撞墙，采用 Packageist 的中国镜像</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/10/27/安装 Laravel，撞墙，采用 Packageist 的中国镜像/" rel="bookmark">
        <time class="entry-date published" datetime="2016-10-26T19:11:00.000Z">
          2016-10-27
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>参考：</p>
<ul>
<li><a href="https://laravel.com/docs/5.2" target="_blank" rel="noopener">https://laravel.com/docs/5.2</a> – 英文手册</li>
</ul>
<ul>
<li><a href="http://laravel-china.org/docs/5.1" target="_blank" rel="noopener">http://laravel-china.org/docs/5.1</a> – 中文手册</li>
</ul>
<ul>
<li><a href="http://pkg.phpcomposer.com/" target="_blank" rel="noopener">http://pkg.phpcomposer.com/</a> – Packagist / Composer 中国全量镜像内（绕过垃圾的墙）</li>
</ul>
<p><strong>安装 Laravel，创建 blog 项目</strong><br>安装方法有两种：</p>
<ol>
<li>全局安装 Laravel Installer，然后用下面的指令创建新项目： laravel new blog</li>
</ol>
<ol start="2">
<li>不安装啥，直接用 Composer 创建新项目：composer create-project –prefer-dist laravel/laravel blog</li>
</ol>
<p>看起来第一种方案比较好，然而：<br>！说明！由于墙的存在，全局安装 Laravel Installer 的方案可能不会成功。</p>
<p><strong>全局安装 Laravel Installer</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer global require "laravel/installer"</span><br></pre></td></tr></table></figure></p>
<p><strong>执行命令</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">laravel new blog</span><br></pre></td></tr></table></figure></p>
<p>悲剧了，出现错误：<br>cURL error 7: Failed to connect to cabinet.laravel.com port 80: Timed out……<br>直接用 Composer 创建 Laravel 项目</p>
<p>参照网上的方案，先执行加速 composer 的执行（用国内的镜像，好人呐！）：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer config -g repo.packagist composer https://packagist.phpcomposer.com</span><br></pre></td></tr></table></figure></p>
<p>然后执行<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer global require "laravel/installer"</span><br></pre></td></tr></table></figure></p>
<p>创建项目</p>
<p>转载自 <a href="http://blog.sina.com.cn/s/blog_6262a50e0102ws9z.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_6262a50e0102ws9z.html</a>，有删改</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Web-开发/">Web 开发</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2016/10/27/安装 Laravel，撞墙，采用 Packageist 的中国镜像/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/10/23/CentOS 7 grub Linux 修改默认的启动操作系统/"><span>CentOS 7 grub Linux 修改默认的启动操作系统</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/10/23/CentOS 7 grub Linux 修改默认的启动操作系统/" rel="bookmark">
        <time class="entry-date published" datetime="2016-10-23T07:36:42.000Z">
          2016-10-23
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>可以用下面的方法修改grub默认的启动OS。</p>
<p><strong>查看当前的启动内核</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grub2-editenvlist</span><br><span class="line">saved_entry=CentOS Linux(3.10.0-123.20.1.el7.x86_64) 7 (Core)</span><br></pre></td></tr></table></figure></p>
<p><strong>查找要默认启动的操作系统名字</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat /etc/grub2.cfg | grep 3.4.44</span><br><span class="line">menuentry &apos;CentOS Linux (3.4.44) 7(Core)&apos; --class centos --class gnu-linux --class gnu --class os--unrestricted $menuentry_id_option&apos;gnulinux-3.10.0-123.el7.x86_64-advanced-e3146a2a-a237-4081-ba08-dbf258de434a&apos;&#123;</span><br><span class="line">        linux16 /vmlinuz-3.4.44 root=/dev/mapper/centos-rootro rd.lvm.lv=centos/swap vconsole.font=latarcyrheb-sun16 rd.lvm.lv=centos/rootcrashkernel=auto  vconsole.keymap=us rhgbquiet LANG=en_US.UTF-8</span><br><span class="line">        initrd16 /initramfs-3.4.44.img</span><br></pre></td></tr></table></figure></p>
<p><strong>设置新的默认启动操作系统选项</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grub2-set-default  &quot;CentOSLinux (3.4.44) 7 (Core)&quot;</span><br></pre></td></tr></table></figure></p>
<p><strong>查看是否生效</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grub2-editenv list</span><br><span class="line">saved_entry=CentOS Linux (3.4.44) 7 (Core)</span><br></pre></td></tr></table></figure></p>
<p>转载自 <a href="http://blog.csdn.net/wjw7869/article/details/47302107" target="_blank" rel="noopener">http://blog.csdn.net/wjw7869/article/details/47302107</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/VPS-技术/">VPS 技术</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2016/10/23/CentOS 7 grub Linux 修改默认的启动操作系统/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/09/10/CentOS 7 主机名的修改/"><span>CentOS 7 主机名的修改</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/09/10/CentOS 7 主机名的修改/" rel="bookmark">
        <time class="entry-date published" datetime="2016-09-10T09:58:55.000Z">
          2016-09-10
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>如何在CentOS 7上修改主机名</p>
<p>在CentOS中，有三种定义的主机名:静态的（static），瞬态的（transient），和灵活的（pretty）。“静态”主机名也称为内核主机名，是系统在启动时从/etc/hostname自动初始化的主机名。“瞬态”主机名是在系统运行时临时分配的主机名，例如，通过DHCP或mDNS服务器分配。静态主机名和瞬态主机名都遵从作为互联网域名同样的字符限制规则。而另一方面，“灵活”主机名则允许使用自由形式（包括特殊/空白字符）的主机名，以展示给终端用户（如Linuxidc）。</p>
<p>在CentOS 7中，有个叫hostnamectl的命令行工具，它允许你查看或修改与主机名相关的配置。</p>
<p>1.要查看主机名相关的设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# hostnamectl  </span><br><span class="line"></span><br><span class="line">  Static hostname: localhost.localdomain</span><br><span class="line">        Icon name: computer</span><br><span class="line">          Chassis: n/a</span><br><span class="line">        Machine ID: 80a4fa4970614cf6be9597ecd6f097a9</span><br><span class="line">          Boot ID: 28420e272e1847a583718262758bd0f7</span><br><span class="line">    Virtualization: vmware</span><br><span class="line">  Operating System: CentOS Linux 7 (Core)</span><br><span class="line">      CPE OS Name: cpe:/o:centos:centos:7</span><br><span class="line">            Kernel: Linux 3.10.0-123.el7.x86_64</span><br><span class="line">      Architecture: x86_64</span><br></pre></td></tr></table></figure></p>
<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# hostnamectl status</span><br><span class="line">  Static hostname: localhost.localdomain</span><br><span class="line">        Icon name: computer</span><br><span class="line">          Chassis: n/a</span><br><span class="line">        Machine ID: 80a4fa4970614cf6be9597ecd6f097a9</span><br><span class="line">          Boot ID: 28420e272e1847a583718262758bd0f7</span><br><span class="line">    Virtualization: vmware</span><br><span class="line">  Operating System: CentOS Linux 7 (Core)</span><br><span class="line">      CPE OS Name: cpe:/o:centos:centos:7</span><br><span class="line">            Kernel: Linux 3.10.0-123.el7.x86_64</span><br><span class="line">      Architecture: x86_64</span><br></pre></td></tr></table></figure>
<p>2.只查看静态、瞬态或灵活主机名，分别使用“–static”，“–transient”或“–pretty”选项。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# hostnamectl --static</span><br><span class="line">localhost.localdomain</span><br><span class="line">[root@localhost ~]# hostnamectl --transient</span><br><span class="line">localhost.localdomain</span><br><span class="line">[root@localhost ~]# hostnamectl --pretty</span><br></pre></td></tr></table></figure></p>
<p>3.要同时修改所有三个主机名：静态、瞬态和灵活主机名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# hostnamectl set-hostname Linuxidc</span><br><span class="line">[root@localhost ~]# hostnamectl --pretty</span><br><span class="line">Linuxidc</span><br><span class="line">[root@localhost ~]# hostnamectl --static</span><br><span class="line">Linuxidc</span><br><span class="line">[root@localhost ~]# hostnamectl --transient</span><br><span class="line">Linuxidc</span><br></pre></td></tr></table></figure></p>
<p>就像上面展示的那样，在修改静态/瞬态主机名时，任何特殊字符或空白字符会被移除，而提供的参数中的任何大写字母会自动转化为小写。一旦修改了静态主机名，/etc/hostname 将被自动更新。然而，/etc/hosts 不会更新以保存所做的修改，所以你每次在修改主机名后一定要手动更新/etc/hosts，之后再重启CentOS 7。否则系统再启动时会很慢。</p>
<p>4.手动更新/etc/hosts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br><span class="line"></span><br><span class="line">127.0.0.1      Linuxidc  hunk_zhu</span><br><span class="line">#127.0.0.1  localhost localhost.localdomain localhost4 localhost4.localdomain</span><br><span class="line">::1        localhost localhost.localdomain localhost6 localhost6.localdomai</span><br></pre></td></tr></table></figure></p>
<p>5.重启CentOS 7 之后（reboot -f ），<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@Linuxidc ~]# hostname</span><br><span class="line">Linuxidc</span><br><span class="line">[root@hunk_zhu ~]# hostnamectl --transient </span><br><span class="line">Linuxidc</span><br><span class="line">[root@hunk_zhu ~]# hostnamectl --static</span><br><span class="line">Linuxidc</span><br><span class="line">[root@hunk_zhu ~]# hostnamectl --pretty</span><br><span class="line">Linuxidc</span><br></pre></td></tr></table></figure></p>
<p>6.如果你只想修改特定的主机名（静态，瞬态或灵活），你可以使用“–static”，“–transient”或“–pretty”选项。<br>例如，要永久修改主机名，你可以修改静态主机名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# hostnamectl --static set-hostname Linuxidc</span><br><span class="line">重启CentOS 7 之后（reboot -f ），</span><br><span class="line">[root@Linuxidc ~]# hostnamectl --static</span><br><span class="line">Linuxidc</span><br><span class="line">[root@Hunk_zhu ~]# hostnamectl --transient</span><br><span class="line">Linuxidc</span><br><span class="line">[root@Hunk_zhu ~]# hostnamectl --pretty</span><br><span class="line">Linuxidc</span><br><span class="line">[root@Hunk_zhu ~]# hostname</span><br></pre></td></tr></table></figure></p>
<p>其实，你不必重启机器以激活永久主机名修改。上面的命令会立即修改内核主机名。注销并重新登入后在命令行提示来观察新的静态主机名。</p>
<p>转载自 <a href="http://www.linuxidc.com/Linux/2014-11/109238.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2014-11/109238.htm</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/VPS-技术/">VPS 技术</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2016/09/10/CentOS 7 主机名的修改/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/09/10/编译wndr4300 openwrt 15.05固件/"><span>编译wndr4300 openwrt 15.05固件</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/09/10/编译wndr4300 openwrt 15.05固件/" rel="bookmark">
        <time class="entry-date published" datetime="2016-09-10T06:59:05.000Z">
          2016-09-10
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>为wndr4300编译openwrt 15.05系统，内容如下:</p>
<p>操作环境 ubuntu 14.04 64位</p>
<ol>
<li><p>安装依赖包</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install subversion build-essential libncurses5-dev zlib1g-dev gawk git ccache gettext libssl-dev xsltproc</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载源码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /home</span><br><span class="line">git clone git://git.openwrt.org/15.05/openwrt.git</span><br><span class="line">cd openwrt</span><br><span class="line">git checkout 15.05</span><br><span class="line">./scripts/feeds update -a</span><br><span class="line">./scripts/feeds install luci</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译 获取官方配置</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://downloads.openwrt.org/chaos_calmer/15.05/ar71xx/nand/config.diff</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>将 config.diffg 文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_TARGET_ar71xx_nand_R6100=y</span><br></pre></td></tr></table></figure></p>
<p>修改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_TARGET_ar71xx_nand_WNDR4300=y</span><br></pre></td></tr></table></figure></p>
<p>生成配置<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat config.diff &gt;&gt; .config</span><br><span class="line">make defconfig</span><br></pre></td></tr></table></figure></p>
<p>修改 /root 为128MB<br>修改 target/linux/ar71xx/image/Makefile 文件, 修改 wndr4300_mtdlayout 中 23552k(ubi) 为 120832k(ubi)， 25600k@0x6c0000(firmware) 为 122880k@0x6c0000(firmware)</p>
<p>也可以使用配置向导<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure></p>
<p>运行编译<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make V=99</span><br></pre></td></tr></table></figure></p>
<ol start="4">
<li>生成文件位置<br>最后文件生成在 bin 目录下： openwrt/bin/ar71xx/openwrt-15.05-ar71xx-nand-wndr4300-squashfs-sysupgrade.tar openwrt/bin/ar71xx/openwrt-15.05-ar71xx-nand-wndr4300-ubi-factory.img</li>
</ol>
<p>转载自 <a href="http://www.jayclub.net/make-wndr4300-openwrt-15-05.html" target="_blank" rel="noopener">http://www.jayclub.net/make-wndr4300-openwrt-15-05.html</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/openwrt/">openwrt</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2016/09/10/编译wndr4300 openwrt 15.05固件/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>




<nav class="pagination">
  
  <a href="/" class="pagination-prev">上一页</a>
  
  
  <a href="/page/3/" class="pagination-next">下一页</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2021 403 Forbidden
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>