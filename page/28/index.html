<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 28 页 | 博客</title>

  
  <meta name="author" content="403 Forbidden">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="博客"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="博客" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">博客</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/about.html">关于</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2013/05/13/Windows 系统慢？这并非技术原因/"><span>Windows 系统慢？这并非技术原因</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2013/05/13/Windows 系统慢？这并非技术原因/" rel="bookmark">
        <time class="entry-date published" datetime="2013-05-12T18:02:39.000Z">
          2013-05-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><a href="/uploads/2013/05/wpid-slow-pc-11.jpg"><img src="/uploads/2013/05/wpid-slow-pc-11.jpg" alt="image"></a></p>
<p>开发者 Marc Bevand 在 Hackernews 发了一篇短帖，简要解释了 Windows 运行速度为何比其它系统慢。随后，一位声称参与 Windows NT 内核开发的微软员工进行了回复，从公司内部管理和人才流失两个方面进行了解释。但由于某种原因，这篇回复被删除了。<br>Marc Bevand 认为此回复很有价值，在获得该员工的许可后，他在个人博客发表了这篇回复。该员工认为，从许多方面来说，Windows 比其它系统慢，而且差距还在加大。<br>我们偶尔会看到一些天真的人试图去改善问题。这些人几乎总是失败。我们能够改善系统性能而且去做的时候，是因为特别情况，那些有能力分配资源的人相信这会影响到商业目标，但是这种工作是西西弗斯式的。在系统级的性能改进上，没有正式或非正式的项目。我们开始关心安全的时候，是因为 SP3 之前的 Windows XP 对自身生意是一种生存上的威胁。我们的低性能对于自身生意没有生存上的威胁。<br>无论是项目主管、测试人员还是产品经理，对于外部补丁都是公开的敌对态度。他们没有动力去接受来自外部的一些变革，“你永远能找到理由说‘不’，你很少有动力去说‘是’”。另外，员工们很少有动力去寻求改变，只有做出重大的改进，才能够获得领导关心或者有升职的可能，“增量改进只能让人们厌烦，而且对你的职位不利。” 因此，员工们在经过一段时间后，都学会了按部就班工作，不再去想着创新了。<br>除了管理上的原因，另一个原因是公司很难留住人才，“Google 和其它大公司不断挖走我们最好、最有经验的开发者，而我们雇佣了刚出校门的年轻人来替代他们”。 这些人通常很聪明，但是他们不了解系统的具体细节，更重要的是，对于那些已经在运作的东西，他们不想做出任何改变。当他们想要改善系统的时候，更倾向于增加新东西而不是改善已有的东西，结果是许多旧功能无法得到改进。<br>综合起来，这位员工认为，微软并不缺乏真正一流的开发者，而且 NT 内核在许多方面都比 Linux 要好，但是这些人不断退休，或者去了其它公司，而且很少有人能够代替他们。“我们用来凑人数的是那些朝九晚五有孩子的人、急着取悦人的 H-1B 持证者，以及被 Google 抛弃的人。偶尔，我们能够召来能人，就像是犯了个错，但是这并不够。还在思考我们为什么落后？腐败已经进驻了。”<br>该员工的回复引起了非常多的关注，以至于他自己有些担忧。于是，他联系了 Marc Bevand，并且发表了一篇声明，以详细解释自己文章的各种失当之处。他表示，“所有这些事情已经超出控制了。我太严酷了，而且我并未想要将其当做某种大规模的揭秘，这只是一些抱怨。对于那些微软外部的人在政体研究上的胃口，我并不赞同。我应该更加深入地思考我的帖子。对于这份误导人的所谓内部印象，我希望做出道歉”。<br>或许该员工的抱怨过于主观，但是其提到的问题，其实已经有过报道，比如《名利场》曾有一篇文章，认为微软的管理体制扼杀了创新萌芽。在科技行业竞争日益激烈的时候，微软或许已经到了正视问题，做出激进改变的时刻了。<br>图片来自 <a href="http://mashable.com/2013/01/21/speed-up-your-pc/" target="_blank" rel="noopener">Mashable</a><br>原文链接：<a href="http://www.ifanr.com/290500" target="_blank" rel="noopener">爱范儿</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/资讯/">资讯</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2013/05/13/Windows 系统慢？这并非技术原因/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2013/05/12/360石晓虹：针对移动Apps的DDoS攻击将成重大威胁/"><span>360石晓虹：针对移动Apps的DDoS攻击将成重大威胁</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2013/05/12/360石晓虹：针对移动Apps的DDoS攻击将成重大威胁/" rel="bookmark">
        <time class="entry-date published" datetime="2013-05-12T08:21:00.000Z">
          2013-05-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>(CSDN报道 子曰/文)  5月11日，在2013第八届中国互联网创业者大会现场，CSDN记者采访了360公司副总裁石晓虹博士。对话中石晓虹博士谈到了如何做网站安全检测和防御、360“库带计划”最新进展以及时下移动互联网领域面临的安全挑战等热点话题。<br>据了解，360通过在线的安全检测工具webscan.360.cn为站长们提供漏洞识别、安全报告及修复方案，以及 wangzhan.360.cn  360网站卫士提供漏洞防御措施，现在已经可以实现抵御1600万次DNS查询攻击、200G DDoS流量攻击、5万僵尸网络CC攻击、1000余种漏洞攻击行为。前者用户超过50万，有2万以上的站长通过360网站卫士来抵御漏洞和攻击。以上服务均免费提供。</p>
<p><a href="/uploads/2013/05/wpid-518fa32c3859f.jpg"><img src="/uploads/2013/05/wpid-518fa32c3859f.jpg" alt="image"></a></p>
<p>360网站安全检测<br>360还为IDC厂商、云建站平台、建站软件、CDN服务商、DNS服务商、域名交易平台等站长服务平台开放API，帮助他们的产品接入360网站安全服务。<br>另外，由于大量的网站漏洞是源于开发者的开发技能、架构设计实力、历史累积等一系列深层原因，对此，石晓虹建议开发者要在观念上重视网站安全问题，并利用相关的源代码检测工具辅助开发，优化架构设计，尽量在源头防止安全事故的发生。<br>自上月网站系统漏洞悬赏项目“库带计划”上线以来，首月已收集到264个开源建站系统漏洞，并协助厂商修复了漏洞，涉及Discuz！、ShopEx、ECShop、PHPWind、PHPCMS、DEDECMS等客户量众多的知名建站系统。在首月收集的全部漏洞中，高危漏洞占35%、中危漏洞52.4%、低危漏洞12.6%。</p>
<p><a href="/uploads/2013/05/wpid-518fa47136cf5.jpg"><img src="/uploads/2013/05/wpid-518fa47136cf5.jpg" alt="image"></a></p>
<p>“库带计划”首月收集的漏洞类型<br>石晓虹表示在360在收到漏洞提交后，会按照业界规范操作流程知悉相关厂商，“主流开源建站系统厂商回复还是很快的，会尽快发布相关漏洞补丁，但很多站长重视程度不够，还未能在第一时间做网站更新”。<br>随着移动Apps的普及，在谈到移动互联网安全形势时，石晓虹表示通过移动智能设备来发动对Apps的DDoS会越来越普遍，并成为一种新的威胁，尤其在手游、电商等竞争激烈的行业应用上。另外，移动互联网领域目前已初步形成黑色产业链，黑客通过刷机、应用市场、预装等多种方式窃取用户个人信息和钱财。据统计，360去年拦截到的伪装APP达到13万个，某些热门应用的盗版Apps数量甚至是正版的几十倍。</p>
<p>P.S. 我想说。。要备案才能用</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/建站相关/">建站相关</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2013/05/12/360石晓虹：针对移动Apps的DDoS攻击将成重大威胁/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2013/05/12/老板我想辞职：因为小米100万元征集一张壁纸/"><span>老板我想辞职：因为小米100万元征集一张壁纸</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2013/05/12/老板我想辞职：因为小米100万元征集一张壁纸/" rel="bookmark">
        <time class="entry-date published" datetime="2013-05-12T00:33:18.000Z">
          2013-05-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>时间：2013-05-10 17:18 作者：张宁<br>在上个月，罗永浩发微博一百万年薪招聘研发总监，在业界引起激烈讨论。移动互联网行业充满了生机和赚钱的机会。即使你不懂开发，不懂运营，甚至不懂什么是LBS或者积分墙，照样可以赚一大笔。今天，小米宣布了百万壁纸征集活动，6月3日即将开放提交入口。一张壁纸如何赚100万？以下是提交作品尺寸及要求：</p>
<ol>
<li>需要提交锁屏壁纸和桌面壁纸，两者必须是一套。</li>
<li>锁屏壁纸尺寸为1920<em>1080，桌面壁纸尺寸为1920</em>2160。尺寸不合格的作品视为无效作品。</li>
<li>提交作品的格式必须为png或jpg。</li>
<li>题材内容不限，但不得上传黄赌毒色情暴力以及违反法律法规的不健康内容。</li>
<li>作者需要保留所有设计稿源文件，获奖后向主办方提供源文件及版权授权。</li>
</ol>
<p><a href="/uploads/2013/05/wpid-518cb8367527c.jpg"><img src="/uploads/2013/05/wpid-518cb8367527c.jpg" alt="image"></a></p>
<p>未来，这样一张昂贵的壁纸，在小米的商店中将如何定价？小米在怎样的背景下，作了这项活动？无论怎样，很多做美工的朋友在微博上发言，表示赞同，美工和设计人员的劳动成果得到了尊重。感兴趣的朋友可以关注小米的百万壁纸征集活动。（责编/张宁）</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/奇闻异事/">奇闻异事</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2013/05/12/老板我想辞职：因为小米100万元征集一张壁纸/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2013/05/12/WordPress 3.5.1 for BAE/"><span>WordPress 3.5.1 for BAE</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2013/05/12/WordPress 3.5.1 for BAE/" rel="bookmark">
        <time class="entry-date published" datetime="2013-05-11T23:52:13.000Z">
          2013-05-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>声明一下，这份移植版 WordPress 不是我修改的。。。我没这个本事。。。有问题别找我。。。我就更新了一个插件，加上了评论回复邮件通知功能而已。。。<br>
        
          <p><a class="excerpt-btn" href="/2013/05/12/WordPress 3.5.1 for BAE/"><span>阅读全文</span></a></p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/程序发布/">程序发布</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2013/05/12/WordPress 3.5.1 for BAE/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2013/05/12/WordPress for BAE 不使用插件实现评论回复邮件提醒功能/"><span>WordPress for BAE 不使用插件实现评论回复邮件提醒功能</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2013/05/12/WordPress for BAE 不使用插件实现评论回复邮件提醒功能/" rel="bookmark">
        <time class="entry-date published" datetime="2013-05-11T18:50:34.000Z">
          2013-05-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>表示这是博主原创。。。转载请注明原文链接<br>该方法<strong>仅限在 BAE 版 WordPress 上使用</strong><br>当然如果要在普通版本的 WordPress 上实现功能的话，请自行修改 wp_mail 那一行</p>
<p>找到你网站根目录下的 wp-comments-post.php ，在里面找这样一行代码<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$location = <span class="keyword">empty</span>($_POST[<span class="string">'redirect_to'</span>]) ? get_comment_link($comment_id) : $_POST[<span class="string">'redirect_to'</span>] . <span class="string">'#comment-'</span> . $comment_id;</span><br></pre></td></tr></table></figure></p>
<p>在前面加入<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="keyword">empty</span>($comment_parent)) &#123;</span><br><span class="line">$get_comment_parent = get_comment($comment_parent);</span><br><span class="line">$mail_subject=$comment-&gt;comment_author.<span class="string">' 回复了您的评论 - '</span>.get_option(<span class="string">'blogname'</span>);</span><br><span class="line">$mail_message=<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">您在《'</span>.$post-&gt;post_title.<span class="string">'》发表的评论内容：  </span></span><br><span class="line"><span class="string">'</span>.</span><br><span class="line">$get_comment_parent-&gt;comment_content.<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'</span>.</span><br><span class="line"><span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">由 '</span>.$comment-&gt;comment_author.<span class="string">' 于 '</span>.$comment-&gt;comment_date.<span class="string">' 回复您的评论内容：  </span></span><br><span class="line"><span class="string">'</span>.</span><br><span class="line">$comment-&gt;comment_content.<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'</span>.</span><br><span class="line"><span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">点击链接查看或回复：  </span></span><br><span class="line"><span class="string">'</span>.</span><br><span class="line"><span class="string">'['</span>.get_comment_link($comment_id).<span class="string">']('</span>.get_comment_link($comment_id).<span class="string">')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'</span>;</span><br><span class="line"><span class="keyword">if</span> ($comment-&gt;comment_author_email !== $get_comment_parent-&gt;comment_author_email) &#123;</span><br><span class="line">wp_mail($get_comment_parent-&gt;comment_author_email,$mail_subject,<span class="string">''</span>.$mail_message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>保存，上传覆盖原文件即可</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/程序发布/">程序发布</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2013/05/12/WordPress for BAE 不使用插件实现评论回复邮件提醒功能/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2013/05/10/表示本博客已搬迁到 Baidu app engine/"><span>表示本博客已搬迁到 Baidu app engine</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2013/05/10/表示本博客已搬迁到 Baidu app engine/" rel="bookmark">
        <time class="entry-date published" datetime="2013-05-10T04:02:26.000Z">
          2013-05-10
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>速度怎么样亲们 :)</p>
<p>图片测试</p>
        
          <p><a class="excerpt-btn" href="/2013/05/10/表示本博客已搬迁到 Baidu app engine/"><span>阅读全文</span></a></p>
        
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/杂七杂八/">杂七杂八</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2013/05/10/表示本博客已搬迁到 Baidu app engine/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2013/05/08/详解 JavaScript 中的 this(转载)/"><span>详解 JavaScript 中的 this(转载)</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2013/05/08/详解 JavaScript 中的 this(转载)/" rel="bookmark">
        <time class="entry-date published" datetime="2013-05-08T03:43:52.000Z">
          2013-05-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>其实如果完全掌握了this的工作原理，自然就不会走进这些坑。来看下以下这些情况中的this分别会指向什么：<br>1.全局代码中的this</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(x);<span class="comment">// 全局变量x值为2</span></span><br></pre></td></tr></table></figure>
<p>全局范围内的this将会指向全局对象，在浏览器中即使window。<br>2.作为单纯的函数调用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fooCoder</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.x = x;</span><br><span class="line">&#125;</span><br><span class="line">fooCoder(<span class="number">2</span>);</span><br><span class="line">alert(x);<span class="comment">// 全局变量x值为2</span></span><br></pre></td></tr></table></figure></p>
<p>这里this指向了全局对象，即window。在严格模式中，则是undefined。<br>3.作为对象的方法调用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"clever coder"</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name : <span class="string">"foocoder"</span>,</span><br><span class="line">hello : <span class="function"><span class="keyword">function</span>(<span class="params">sth</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">" says "</span> + sth);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">person.hello(<span class="string">"hello world"</span>);</span><br></pre></td></tr></table></figure></p>
<p>输出 foocoder says hello world。this指向person对象，即当前对象。<br>4.作为构造函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> FooCoder();</span><br></pre></td></tr></table></figure></p>
<p>函数内部的this指向新创建的对象。<br>5.内部函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"clever coder"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name : <span class="string">"foocoder"</span>,</span><br><span class="line">hello : <span class="function"><span class="keyword">function</span>(<span class="params">sth</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> sayhello = <span class="function"><span class="keyword">function</span>(<span class="params">sth</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">" says "</span> + sth);</span><br><span class="line">&#125;;</span><br><span class="line">sayhello(</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.hello(<span class="string">"hello world"</span>);<span class="comment">//clever coder says hello world</span></span><br></pre></td></tr></table></figure></p>
<p>在内部函数中，this没有按预想的绑定到外层函数对象上，而是绑定到了全局对象。这里普遍被认为是JavaScript语言的设计错误，因为没有人想让内部函数中的this指向全局对象。一般的处理方式是将this作为变量保存下来，一般约定为that或者self：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"clever coder"</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">name : <span class="string">"foocoder"</span>,</span><br><span class="line">hello : <span class="function"><span class="keyword">function</span>(<span class="params">sth</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">var</span> sayhello = <span class="function"><span class="keyword">function</span>(<span class="params">sth</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(that.name + <span class="string">" says "</span> + sth);</span><br><span class="line">&#125;;</span><br><span class="line">sayhello(sth);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">person.hello(<span class="string">"hello world"</span>);<span class="comment">//foocoder says hello world</span></span><br></pre></td></tr></table></figure>
<p>6.使用call和apply设置this<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.hello.call(person, <span class="string">"world"</span>);</span><br></pre></td></tr></table></figure></p>
<p>apply和call类似，只是后面的参数是通过一个数组传入，而不是分开传入。两者的方法定义：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call( thisArg [，arg1，arg2，… ] );  <span class="comment">// 参数列表，arg1，arg2，...</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply(thisArg [，argArray] );     <span class="comment">// 参数数组，argArray</span></span><br></pre></td></tr></table></figure>
<p>两者都是将某个函数绑定到某个具体对象上使用，自然此时的this会被显式的设置为第一个参数。<br>简单地总结<br>简单地总结以上几点，可以发现，其实只有第六点是让人疑惑的。<br>其实就可以总结为以下几点：<br>当函数作为对象的方法调用时，this指向该对象。<br>当函数作为淡出函数调用时，this指向全局对象（严格模式时，为undefined）<br>构造函数中的this指向新创建的对象<br>嵌套函数中的this不会继承上层函数的this，如果需要，可以用一个变量保存上层函数的this。<br>再总结的简单点，如果在函数中使用了this，只有在该函数直接被某对象调用时，该this才指向该对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj.foocoder();</span><br><span class="line">foocoder.call(obj, ...);</span><br><span class="line">foocoder.apply(obj, …);</span><br></pre></td></tr></table></figure>
<p>更进一步<br>我们可能经常会写这样的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#some-ele"</span>).click = obj.handler;</span><br></pre></td></tr></table></figure></p>
<p>如果在handler中用了this，this会绑定在obj上么？显然不是，赋值以后，函数是在回调中执行的，this会绑定到$(“#some-div”)元素上。这就需要理解函数的执行环境。本文不打算长篇赘述函数的执行环境，可以参考《javascript高级程序设计》中对执行环境和作用域链的相关介绍。这里要指出的时，理解js函数的执行环境，会更好地理解this。<br>那我们如何能解决回调函数绑定的问题？ES5中引入了一个新的方法，<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bind():</span><br><span class="line">fun.bind(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure></p>
<p>thisArg</p>
<p>当绑定函数被调用时,该参数会作为原函数运行时的this指向.当使用new 操作符调用绑定函数时,该参数无效.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arg1, arg2, ...</span><br></pre></td></tr></table></figure>
<p>当绑定函数被调用时,这些参数加上绑定函数本身的参数会按照顺序作为原函数运行时的参数.<br>该方法创建一个新函数，称为绑定函数，绑定函数会以创建它时传入bind方法的第一个参数作为this，传入bind方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数.<br>显然bind方法可以很好地解决上述问题。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#some-ele"</span>).click(person.hello.bind(person));</span><br><span class="line"><span class="comment">//相应元素被点击时，输出foocoder says hello world</span></span><br></pre></td></tr></table></figure></p>
<p>其实该方法也很容易模拟，我们看下Prototype.js中bind方法的源码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fn = <span class="keyword">this</span>, args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>), object = args.shift();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(object,</span><br><span class="line">      args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>明白了么？<br>相信看完全文以后，this不再是坑 </p>
<p>原文作者：foocoder</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Web-开发/">Web 开发</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2013/05/08/详解 JavaScript 中的 this(转载)/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2013/05/08/Linux流量监控工具 - iftop (最全面的iftop教程)(转载)/"><span>Linux流量监控工具 - iftop (最全面的iftop教程)(转载)</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2013/05/08/Linux流量监控工具 - iftop (最全面的iftop教程)(转载)/" rel="bookmark">
        <time class="entry-date published" datetime="2013-05-07T23:52:52.000Z">
          2013-05-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>在类Unix系统中可以使用top查看系统资源、进程、内存占用等信息。查看网络状态可以使用netstat、nmap等工具。若要查看实时的网络流量，监控TCP/IP连接等，则可以使用iftop。</p>
<p><strong>一、iftop是什么？</strong></p>
<p>iftop是类似于top的实时流量监控工具。<br>官方网站：<a href="http://www.ex-parrot.com/~pdw/iftop/" target="_blank" rel="noopener">http://www.ex-parrot.com/~pdw/iftop/</a></p>
<p><strong>二、iftop有什么用？</strong></p>
<p>iftop可以用来监控网卡的实时流量（可以指定网段）、反向解析IP、显示端口信息等，详细的将会在后面的使用参数中说明。</p>
<p><strong>三、安装iftop</strong></p>
<p><strong><strong>安装方法1、**</strong></strong>编译安装**</p>
<p>如果采用编译安装可以到<a href="http://www.ex-parrot.com/~pdw/iftop/" target="_blank" rel="noopener">iftop官网</a>下载最新的源码包。<br>安装前需要已经安装好基本的编译所需的环境，比如make、gcc、autoconf等。安装iftop还需要安装libpcap和libcurses。<br><strong>CentOS上安装所需依赖包：</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install flex byacc libpcap ncurses ncurses-devel libpcap-devel</span><br></pre></td></tr></table></figure></p>
<p><strong>Debian上安装所需依赖包：</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install flex byacc libpcap0.8 libncurses5</span><br></pre></td></tr></table></figure></p>
<p>下载iftop<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.ex-parrot.com/pdw/iftop/download/iftop-0.17.tar.gz</span><br><span class="line">tar zxvf iftop-0.17.tar.gz</span><br><span class="line">cd iftop-0.17</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p>
<p><strong>安装方法2：(懒人办法，最简单)</strong></p>
<p>直接省略上面的步骤<br>CentOS系统：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install flex byacc libpcap ncurses ncurses-devel</span><br><span class="line">wget ftp://fr2.rpmfind.net/linux/dag/redhat/el5/en/i386/dag/RPMS/iftop-0.17-1.el5.rf.i386.rpm</span><br><span class="line">rpm -ivh iftop-0.17-1.el5.rf.i386.rpm</span><br></pre></td></tr></table></figure></p>
<p>Debian系统 运行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install iftop</span><br></pre></td></tr></table></figure></p>
<p><strong>四、运行iftop</strong></p>
<p>直接运行： iftop<br>效果如下图：</p>
<p><a href="/uploads/2013/05/20140112212729.jpg"><img src="/uploads/2013/05/20140112212729.jpg" alt="20140112212729"></a></p>
<p><strong>五、相关参数及说明</strong></p>
<p><strong>1、iftop界面相关说明</strong></p>
<p>界面上面显示的是类似刻度尺的刻度范围，为显示流量图形的长条作标尺用的。<br>中间的&lt;_ _=”_”&gt;这两个左右箭头，表示的是流量的方向。<br> TX：发送流量<br> RX：接收流量<br> TOTAL：总流量<br> Cumm：运行iftop到目前时间的总流量<br> peak：流量峰值<br> rates：分别表示过去 2s 10s 40s 的平均流量</p>
<h3 id="2、iftop相关参数"><a href="#2、iftop相关参数" class="headerlink" title="2、iftop相关参数"></a>2、iftop相关参数</h3><h3 id="常用的参数"><a href="#常用的参数" class="headerlink" title="常用的参数"></a>常用的参数</h3><p> -i设定监测的网卡，如：# iftop -i eth1<br> -B 以bytes为单位显示流量(默认是bits)，如：# iftop -B<br> -n使host信息默认直接都显示IP，如：# iftop -n<br> -N使端口信息默认直接都显示端口号，如: # iftop -N<br> -F显示特定网段的进出流量，如# iftop -F 10.10.1.0/24或# iftop -F 10.10.1.0/255.255.255.0<br> -h（display this message），帮助，显示参数信息<br> -p使用这个参数后，中间的列表显示的本地主机信息，出现了本机以外的IP信息;<br> -b使流量图形条默认就显示;<br> -f这个暂时还不太会用，过滤计算包用的;<br> -P使host信息及端口信息默认就都显示;<br> -m设置界面最上边的刻度的最大值，刻度分五个大段显示，例：# iftop -m 100M</p>
<h3 id="进入iftop画面后的一些操作命令-注意大小写"><a href="#进入iftop画面后的一些操作命令-注意大小写" class="headerlink" title="进入iftop画面后的一些操作命令(注意大小写)"></a>进入iftop画面后的一些操作命令(注意大小写)</h3><p> 按h切换是否显示帮助;<br> 按n切换显示本机的IP或主机名;<br> 按s切换是否显示本机的host信息;<br> 按d切换是否显示远端目标主机的host信息;<br> 按t切换显示格式为2行/1行/只显示发送流量/只显示接收流量;<br> 按N切换显示端口号或端口服务名称;<br> 按S切换是否显示本机的端口信息;<br> 按D切换是否显示远端目标主机的端口信息;<br> 按p切换是否显示端口信息;<br> 按P切换暂停/继续显示;<br> 按b切换是否显示平均流量图形条;<br> 按B切换计算2秒或10秒或40秒内的平均流量;<br> 按T切换是否显示每个连接的总流量;<br> 按l打开屏幕过滤功能，输入要过滤的字符，比如ip,按回车后，屏幕就只显示这个IP相关的流量信息;<br> 按L切换显示画面上边的刻度;刻度不同，流量图形条会有变化;<br> 按j或按k可以向上或向下滚动屏幕显示的连接记录;<br> 按1或2或3可以根据右侧显示的三列流量数据进行排序;<br> 按&lt;根据左边的本机名或IP排序br&gt; 按&gt;根据远端目标主机的主机名或IP排序;<br> 按o切换是否固定只显示当前的连接;<br> 按f可以编辑过滤代码，这是翻译过来的说法，我还没用过这个！<br> 按!可以使用shell命令，这个没用过！没搞明白啥命令在这好用呢！<br> 按q退出监控。</p>
<h2 id="六、常见问题"><a href="#六、常见问题" class="headerlink" title="六、常见问题"></a>六、常见问题</h2><p> 1、make: yacc: Command not found<br> make: *** [grammar.c] Error 127<br> 解决方法：apt-get install byacc / yum install byacc<br> 2、configure: error: Curses! Foiled again!<br> (Can’t find a curses library supporting mvchgat.)<br> Consider installing ncurses.<br> 解决方法：apt-get install libncurses5-dev /  yum install ncurses-devel</p>
<p>转载自 <a href="http://www.vpser.net/manage/iftop.html" target="_blank" rel="noopener">http://www.vpser.net/manage/iftop.html</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/VPS-技术/">VPS 技术</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2013/05/08/Linux流量监控工具 - iftop (最全面的iftop教程)(转载)/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2013/05/07/PHP利用curl伪造IP和来路(转载)/"><span>PHP利用curl伪造IP和来路(转载)</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2013/05/07/PHP利用curl伪造IP和来路(转载)/" rel="bookmark">
        <time class="entry-date published" datetime="2013-05-07T05:02:29.000Z">
          2013-05-07
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><a href="/uploads/2013/05/20120101065534935.jpg"><img src="/uploads/2013/05/20120101065534935-300x93.jpg" alt="20120101065534935"></a><br>效果如图<br>伪造的文件：1.php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$ch = curl_init();</span><br><span class="line">curl_setopt($ch, CURLOPT_URL, &quot;http://localhost/2.php&quot;);</span><br><span class="line">curl_setopt($ch, CURLOPT_HTTPHEADER, array(&apos;X-FORWARDED-FOR:8.8.8.8&apos;, &apos;CLIENT-IP:8.8.8.8&apos;));  //构造IP</span><br><span class="line">curl_setopt($ch, CURLOPT_REFERER, &quot;http://www.xssxss.com/ &quot;);   //构造来路</span><br><span class="line">curl_setopt($ch, CURLOPT_HEADER, 1);</span><br><span class="line">$out = curl_exec($ch);</span><br><span class="line">curl_close($ch);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p>
<p>查看效果的脚本2.php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function getClientIp() &#123;</span><br><span class="line">    if (!empty($_SERVER[&quot;HTTP_CLIENT_IP&quot;]))</span><br><span class="line">        $ip = $_SERVER[&quot;HTTP_CLIENT_IP&quot;];</span><br><span class="line">    else if (!empty($_SERVER[&quot;HTTP_X_FORWARDED_FOR&quot;]))</span><br><span class="line">        $ip = $_SERVER[&quot;HTTP_X_FORWARDED_FOR&quot;];</span><br><span class="line">    else if (!empty($_SERVER[&quot;REMOTE_ADDR&quot;]))</span><br><span class="line">        $ip = $_SERVER[&quot;REMOTE_ADDR&quot;];</span><br><span class="line">    else</span><br><span class="line">        $ip = &quot;err&quot;;</span><br><span class="line">    return $ip;</span><br><span class="line">&#125;</span><br><span class="line">echo &quot;IP: &quot; . getClientIp() . &quot;&quot;;</span><br><span class="line">echo &quot;referer: &quot; . $_SERVER[&quot;HTTP_REFERER&quot;];</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p>
<p> 原文链接：<a href="http://www.2cto.com/kf/201201/115774.html" target="_blank" rel="noopener">http://www.2cto.com/kf/201201/115774.html</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Web-开发/">Web 开发</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2013/05/07/PHP利用curl伪造IP和来路(转载)/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2013/05/07/FBI密码挑战，你能解开吗？/"><span>FBI密码挑战，你能解开吗？</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2013/05/07/FBI密码挑战，你能解开吗？/" rel="bookmark">
        <time class="entry-date published" datetime="2013-05-07T03:29:03.000Z">
          2013-05-07
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>时间：2013-05-06 15:00 作者：夏梦竹<br>最近几年，FBI官网都会推出一个新的密码破解挑战赛，据说是为了激发青少年对FBI工作的好奇心而设立。与以往不同的是，这次加入了代码。下面的这幅图就是今年的密码破译游戏，一起看看你能破解吗？</p>
<p><a href="/uploads/2013/05/wpid-5187545894947.jpg"><img src="/uploads/2013/05/wpid-5187545894947.jpg" alt="image"></a></p>
<p>你能破解吗？<br>尽管破解了FBI也不会聘你做探员，但至少可以显摆一下各位精湛的大脑，不管怎样，大家试试吧。<br>想要了解更多关于恐怖分子、间谍和不法分子利用他们的通信类型密码和代码吗？请参阅“Analysis of Criminal Codes and Ciphers”，你也可以查看以往著名案件的”密码破解“法：A 400-Year History。<br>一起来回顾下过去精彩的密码破解案例：</p>
<p><a href="/uploads/2013/05/wpid-518755436a64a.jpg"><img src="/uploads/2013/05/wpid-518755436a64a.jpg" alt="image"></a></p>
<p><a href="/uploads/2013/05/wpid-518755d4ba70e.jpg"><img src="/uploads/2013/05/wpid-518755d4ba70e.jpg" alt="image"></a></p>
<p><a href="http://www.fbi.gov/news/stories/2009/december/code_122409" target="_blank" rel="noopener">December 2009</a><br><a href="http://www.fbi.gov/news/stories/2009/may/code_052309" target="_blank" rel="noopener">May 2009</a></p>
<p><a href="/uploads/2013/05/wpid-5187557d692a5.jpg"><img src="/uploads/2013/05/wpid-5187557d692a5.jpg" alt="image"></a></p>
<p><a href="/uploads/2013/05/wpid-518755960a57b.jpg"><img src="/uploads/2013/05/wpid-518755960a57b.jpg" alt="image"></a></p>
<p><a href="http://www.fbi.gov/news/stories/2008/december/code_122908" target="_blank" rel="noopener">December 2008</a><br><a href="http://www.fbi.gov/news/stories/2007/november/code112107" target="_blank" rel="noopener">November 2007</a></p>
<p>在笔者看来还是蛮难的，反正我是看不懂，谁有本事来破解一下？如果你实在想不出答案，也没关系，笔者稍后会公布答案！</p>
<p>P.S. 本文转载，原文如此，我不是笔者。。。别问我答案。。。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/奇闻异事/">奇闻异事</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2013/05/07/FBI密码挑战，你能解开吗？/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>




<nav class="pagination">
  
  <a href="/page/27/" class="pagination-prev">上一页</a>
  
  
  <a href="/page/29/" class="pagination-next">下一页</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2022 403 Forbidden
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>