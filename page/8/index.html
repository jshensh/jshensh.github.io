<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 8 页 | 博客</title>

  
  <meta name="author" content="403 Forbidden">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="博客"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="博客" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">博客</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/about.html">关于</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2015/07/28/设计模式六大原则/"><span>设计模式六大原则</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2015/07/28/设计模式六大原则/" rel="bookmark">
        <time class="entry-date published" datetime="2015-07-28T07:32:37.000Z">
          2015-07-28
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><strong>单一职责原则（Single Responsibility Principle）</strong><br>定义：不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。<br>问题由来：类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。<br>解决方案：遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。<br>    说到单一职责原则，很多人都会不屑一顾。因为它太简单了。稍有经验的程序员即使从来没有读过设计模式、从来没有听说过单一职责原则，在设计软件时也会自觉的遵守这一重要原则，因为这是常识。在软件编程中，谁也不希望因为修改了一个功能导致其他的功能发生故障。而避免出现这一问题的方法便是遵循单一职责原则。虽然单一职责原则如此简单，并且被认为是常识，但是即便是经验丰富的程序员写出的程序，也会有违背这一原则的代码存在。为什么会出现这种现象呢？因为有职责扩散。所谓职责扩散，就是因为某种原因，职责P被分化为粒度更细的职责P1和P2。<br>    比如：类T只负责一个职责P，这样设计是符合单一职责原则的。后来由于某种原因，也许是需求变更了，也许是程序的设计者境界提高了，需要将职责P细分为粒度更细的职责P1，P2，这时如果要使程序遵循单一职责原则，需要将类T也分解为两个类T1和T2，分别负责P1、P2两个职责。但是在程序已经写好的情况下，这样做简直太费时间了。所以，简单的修改类T，用它来负责两个职责是一个比较不错的选择，虽然这样做有悖于单一职责原则。<br>举例说明，用一个类描述动物呼吸这个场景：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breathe</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">        System.out.println(animal+<span class="string">"呼吸空气"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">        animal.breathe(<span class="string">"牛"</span>);</span><br><span class="line">        animal.breathe(<span class="string">"羊"</span>);</span><br><span class="line">        animal.breathe(<span class="string">"猪"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br>牛呼吸空气<br>羊呼吸空气<br>猪呼吸空气</p>
<p>程序上线后，发现问题了，并不是所有的动物都呼吸空气的，比如鱼就是呼吸水的。修改时如果遵循单一职责原则，需要将Animal类细分为陆生动物类Terrestrial，水生动物Aquatic，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Terrestrial</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breathe</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">        System.out.println(animal+<span class="string">"呼吸空气"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Aquatic</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breathe</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">        System.out.println(animal+<span class="string">"呼吸水"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Terrestrial terrestrial = <span class="keyword">new</span> Terrestrial();</span><br><span class="line">        terrestrial.breathe(<span class="string">"牛"</span>);</span><br><span class="line">        terrestrial.breathe(<span class="string">"羊"</span>);</span><br><span class="line">        terrestrial.breathe(<span class="string">"猪"</span>);</span><br><span class="line">        </span><br><span class="line">        Aquatic aquatic = <span class="keyword">new</span> Aquatic();</span><br><span class="line">        aquatic.breathe(<span class="string">"鱼"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br>牛呼吸空气<br>羊呼吸空气<br>猪呼吸空气<br>鱼呼吸水</p>
<p>我们会发现如果这样修改花销是很大的，除了将原来的类分解之外，还需要修改客户端。而直接修改类Animal来达成目的虽然违背了单一职责原则，但花销却小的多，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breathe</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"鱼"</span>.equals(animal))&#123;</span><br><span class="line">            System.out.println(animal+<span class="string">"呼吸水"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(animal+<span class="string">"呼吸空气"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">        animal.breathe(<span class="string">"牛"</span>);</span><br><span class="line">        animal.breathe(<span class="string">"羊"</span>);</span><br><span class="line">        animal.breathe(<span class="string">"猪"</span>);</span><br><span class="line">        animal.breathe(<span class="string">"鱼"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这种修改方式要简单的多。但是却存在着隐患：有一天需要将鱼分为呼吸淡水的鱼和呼吸海水的鱼，则又需要修改Animal类的breathe方法，而对原有代码的修改会对调用“猪”“牛”“羊”等相关功能带来风险，也许某一天你会发现程序运行的结果变为“牛呼吸水”了。这种修改方式直接在代码级别上违背了单一职责原则，虽然修改起来最简单，但隐患却是最大的。还有一种修改方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breathe</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">        System.out.println(animal+<span class="string">"呼吸空气"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breathe2</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">        System.out.println(animal+<span class="string">"呼吸水"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">        animal.breathe(<span class="string">"牛"</span>);</span><br><span class="line">        animal.breathe(<span class="string">"羊"</span>);</span><br><span class="line">        animal.breathe(<span class="string">"猪"</span>);</span><br><span class="line">        animal.breathe2(<span class="string">"鱼"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这种修改方式没有改动原来的方法，而是在类中新加了一个方法，这样虽然也违背了单一职责原则，但在方法级别上却是符合单一职责原则的，因为它并没有动原来方法的代码。这三种方式各有优缺点，那么在实际编程中，采用哪一中呢？其实这真的比较难说，需要根据实际情况来确定。我的原则是：只有逻辑足够简单，才可以在代码级别上违反单一职责原则；只有类中方法数量足够少，才可以在方法级别上违反单一职责原则；<br>    例如本文所举的这个例子，它太简单了，它只有一个方法，所以，无论是在代码级别上违反单一职责原则，还是在方法级别上违反，都不会造成太大的影响。实际应用中的类都要复杂的多，一旦发生职责扩散而需要修改类时，除非这个类本身非常简单，否则还是遵循单一职责原则的好。<br>    遵循单一职责原的优点有：<br>    可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；<br>    提高类的可读性，提高系统的可维护性；<br>    变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。<br>需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都需要遵循这一重要原则。</p>
<p><strong>里氏替换原则（Liskov Substitution Principle）</strong><br>肯定有不少人跟我刚看到这项原则的时候一样，对这个原则的名字充满疑惑。其实原因就是这项原则最早是在1988年，由麻省理工学院的一位姓里的女士（Barbara Liskov）提出来的。<br>定义1：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。<br>定义2：所有引用基类的地方必须能透明地使用其子类的对象。<br>问题由来：有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。<br>解决方案：当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。<br>    继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。<br>继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。<br>    举例说明继承的风险，我们需要完成一个两数相减的功能，由类A来负责。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        System.out.println(<span class="string">"100-50="</span>+a.func1(<span class="number">100</span>, <span class="number">50</span>));</span><br><span class="line">        System.out.println(<span class="string">"100-80="</span>+a.func1(<span class="number">100</span>, <span class="number">80</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br>100-50=50<br>100-80=20<br>后来，我们需要增加一个新的功能：完成两数相加，然后再与100求和，由类B来负责。即类B需要完成两个功能：<br>    两数相减。<br>    两数相加，然后再加100。<br>由于类A已经实现了第一个功能，所以类B继承类A后，只需要再完成第二个功能就可以了，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func1(a,b)+<span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        B a = <span class="keyword">new</span> B();</span><br><span class="line">        System.out.println(<span class="string">"100-50="</span>+b.func1(<span class="number">100</span>, <span class="number">50</span>));</span><br><span class="line">        System.out.println(<span class="string">"100-80="</span>+b.func1(<span class="number">100</span>, <span class="number">80</span>));</span><br><span class="line">        System.out.println(<span class="string">"100+20+100="</span>+b.func2(<span class="number">100</span>, <span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类B完成后，运行结果：<br>100-50=150<br>100-80=180<br>100+20+100=220<br>我们发现原本运行正常的相减功能发生了错误。原因就是类B在给方法起名时无意中重写了父类的方法，造成所有运行相减功能的代码全部调用了类B重写后的方法，造成原本运行正常的功能出现了错误。在本例中，引用基类A完成的功能，换成子类B之后，发生了异常。在实际编程中，我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。如果非要重写父类的方法，比较通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替。</p>
<p>里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义：<br>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。<br>子类中可以增加自己特有的方法。<br>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。<br>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。<br>看上去很不可思议，因为我们会发现在自己编程中常常会违反里氏替换原则，程序照样跑的好好的。所以大家都会产生这样的疑问，假如我非要不遵循里氏替换原则会有什么后果？<br>后果就是：你写的代码出问题的几率将会大大增加。</p>
<p><strong>依赖倒置原则（Dependence Inversion Principle）</strong><br>定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。<br>问题由来：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。<br>解决方案：将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。<br>    依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。<br>    依赖倒置原则的中心思想是面向接口编程，我们依旧用一个例子来说明面向接口编程比相对于面向实现编程好在什么地方。场景是这样的，母亲给孩子讲故事，只要给她一本书，她就可以照着书给孩子讲故事了。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"很久很久以前有一个阿拉伯的故事……"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mother</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">narrate</span><span class="params">(Book book)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"妈妈开始讲故事"</span>);</span><br><span class="line">        System.out.println(book.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Mother mother = <span class="keyword">new</span> Mother();</span><br><span class="line">        mother.narrate(<span class="keyword">new</span> Book());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果<br>妈妈开始讲故事<br>很久很久以前有一个阿拉伯的故事……<br>运行良好，假如有一天，需求变成这样：不是给书而是给一份报纸，让这位母亲讲一下报纸上的故事。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Newspaper</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"林书豪38+7领导尼克斯击败湖人……"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这位母亲却办不到，因为她居然不会读报纸上的故事，这太荒唐了，只是将书换成报纸，居然必须要修改Mother才能读。假如以后需求换成杂志呢？换成网页呢？还要不断地修改Mother，这显然不是好的设计。原因就是Mother与Book之间的耦合性太高了，必须降低他们之间的耦合度才行。<br>我们引入一个抽象的接口IReader。读物，只要是带字的都属于读物。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IReader</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Mother类与接口IReader发生依赖关系，而Book和Newspaper都属于读物的范畴，他们各自都去实现IReader接口，这样就符合依赖倒置原则了，代码修改为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Newspaper</span> <span class="keyword">implements</span> <span class="title">IReader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"林书豪17+9助尼克斯击败老鹰……"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">IReader</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"很久很久以前有一个阿拉伯的故事……"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mother</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">narrate</span><span class="params">(IReader reader)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"妈妈开始讲故事"</span>);</span><br><span class="line">        System.out.println(reader.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Mother mother = <span class="keyword">new</span> Mother();</span><br><span class="line">        mother.narrate(<span class="keyword">new</span> Book());</span><br><span class="line">        mother.narrate(<span class="keyword">new</span> Newspaper());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果<br>妈妈开始讲故事<br>很久很久以前有一个阿拉伯的故事……<br>妈妈开始讲故事<br>林书豪17+9助尼克斯击败老鹰……<br>    这样修改后，无论以后怎样扩展Client类，都不需要再修改Mother类了。这只是一个简单的例子，实际情况中，代表高层模块的Mother类将负责完成主要的业务逻辑，一旦需要对它进行修改，引入错误的风险极大。所以遵循依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。<br>    采用依赖倒置原则给多人并行开发带来了极大的便利，比如上例中，原本Mother类与Book类直接耦合时，Mother类必须等Book类编码完成后才可以进行编码，因为Mother类依赖于Book类。修改后的程序则可以同时开工，互不影响，因为Mother与Book类一点关系也没有。参与协作开发的人越多、项目越庞大，采用依赖导致原则的意义就越重大。现在很流行的TDD开发模式就是依赖倒置原则最成功的应用。<br>    传递依赖关系有三种方式，以上的例子中使用的方法是接口传递，另外还有两种传递方式：构造方法传递和setter方法传递，相信用过Spring框架的，对依赖的传递方式一定不会陌生。<br>    在实际编程中，我们一般需要做到如下3点：<br>    低层模块尽量都要有抽象类或接口，或者两者都有。<br>    变量的声明类型尽量是抽象类或接口。<br>    使用继承时遵循里氏替换原则。<br>总之，依赖倒置原则就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。</p>
<p><strong>接口隔离原则（Interface Segregation Principle）</strong><br>定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。<br>问题由来：类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。<br>解决方案：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。<br>举例来说明接口隔离原则：<br><a href="/uploads/2015/07/1.png"><img src="/uploads/2015/07/1-300x220.png" alt="1"></a><br>（图1  未遵循接口隔离原则的设计）<br>    这个图的意思是：类A依赖接口I中的方法1、方法2、方法3，类B是对类A依赖的实现。类C依赖接口I中的方法1、方法4、方法5，类D是对类C依赖的实现。对于类B和类D来说，虽然他们都存在着用不到的方法（也就是图中红色字体标记的方法），但由于实现了接口I，所以也必须要实现这些用不到的方法。对类图不熟悉的可以参照程序代码来理解，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I i)</span></span>&#123;</span><br><span class="line">        i.method1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I i)</span></span>&#123;</span><br><span class="line">        i.method2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I i)</span></span>&#123;</span><br><span class="line">        i.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">I</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"类B实现接口I的方法1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"类B实现接口I的方法2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"类B实现接口I的方法3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对于类A来说，method4和method5不是必需的，但是由于接口A中有这两个方法，</span></span><br><span class="line">    <span class="comment">//所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I i)</span></span>&#123;</span><br><span class="line">        i.method1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I i)</span></span>&#123;</span><br><span class="line">        i.method4();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I i)</span></span>&#123;</span><br><span class="line">        i.method5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">I</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"类D实现接口I的方法1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对于类C来说，method2和method3不是必需的，但是由于接口A中有这两个方法，</span></span><br><span class="line">    <span class="comment">//所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"类D实现接口I的方法4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"类D实现接口I的方法5"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        a.depend1(<span class="keyword">new</span> B());</span><br><span class="line">        a.depend2(<span class="keyword">new</span> B());</span><br><span class="line">        a.depend3(<span class="keyword">new</span> B());</span><br><span class="line">        </span><br><span class="line">        C c = <span class="keyword">new</span> C();</span><br><span class="line">        c.depend1(<span class="keyword">new</span> D());</span><br><span class="line">        c.depend2(<span class="keyword">new</span> D());</span><br><span class="line">        c.depend3(<span class="keyword">new</span> D()); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。如果将这个设计修改为符合接口隔离原则，就必须对接口I进行拆分。在这里我们将原有的接口I拆分为三个接口，拆分后的设计如图2所示：<br><a href="/uploads/2015/07/2.png"><img src="/uploads/2015/07/2-300x182.png" alt="2"></a><br>（图2  遵循接口隔离原则的设计）<br>照例贴出程序的代码，供不熟悉类图的朋友参考：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I1 i)</span></span>&#123;</span><br><span class="line">        i.method1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I2 i)</span></span>&#123;</span><br><span class="line">        i.method2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I2 i)</span></span>&#123;</span><br><span class="line">        i.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">I1</span>, <span class="title">I2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"类B实现接口I1的方法1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"类B实现接口I2的方法2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"类B实现接口I2的方法3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(I1 i)</span></span>&#123;</span><br><span class="line">        i.method1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(I3 i)</span></span>&#123;</span><br><span class="line">        i.method4();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(I3 i)</span></span>&#123;</span><br><span class="line">        i.method5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">I1</span>, <span class="title">I3</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"类D实现接口I1的方法1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"类D实现接口I3的方法4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"类D实现接口I3的方法5"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。本文例子中，将一个庞大的接口变更为3个专用的接口所采用的就是接口隔离原则。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。<br>    说到这里，很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。<br>    采用接口隔离原则对接口进行约束时，要注意以下几点：<br>    接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。<br>    为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。<br>    提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。<br>运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</p>
<p><strong>迪米特法则（Law Of Demeter）</strong><br>定义：一个对象应该对其他对象保持最少的了解。<br>问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。<br>解决方案：尽量降低类与类之间的耦合。<br>    自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。<br>    迪米特法则又叫最少知道原则，最早是在1987年由美国Northeastern University的Ian Holland提出。通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。迪米特法则还有一个更简单的定义：只与直接的朋友通信。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。<br>    举一个例子：有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工ID。先来看一下违反迪米特法则的设计。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//总公司员工</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分公司员工</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubEmployee</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubCompanyManager</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;SubEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;SubEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;SubEmployee&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">            SubEmployee emp = <span class="keyword">new</span> SubEmployee();</span><br><span class="line">            <span class="comment">//为分公司人员按顺序分配一个ID</span></span><br><span class="line">            emp.setId(<span class="string">"分公司"</span>+i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyManager</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">30</span>; i++)&#123;</span><br><span class="line">            Employee emp = <span class="keyword">new</span> Employee();</span><br><span class="line">            <span class="comment">//为总公司人员按顺序分配一个ID</span></span><br><span class="line">            emp.setId(<span class="string">"总公司"</span>+i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(SubCompanyManager sub)</span></span>&#123;</span><br><span class="line">        List&lt;SubEmployee&gt; list1 = sub.getAllEmployee();</span><br><span class="line">        <span class="keyword">for</span>(SubEmployee e:list1)&#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">        <span class="keyword">for</span>(Employee e:list2)&#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        CompanyManager e = <span class="keyword">new</span> CompanyManager();</span><br><span class="line">        e.printAllEmployee(<span class="keyword">new</span> SubCompanyManager());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在这个设计的主要问题出在CompanyManager中，根据迪米特法则，只与直接的朋友发生通信，而SubEmployee类并不是CompanyManager类的直接朋友（以局部变量出现的耦合不属于直接朋友），从逻辑上讲总公司只与他的分公司耦合就行了，与分公司的员工并没有任何联系，这样设计显然是增加了不必要的耦合。按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。修改后的代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubCompanyManager</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;SubEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;SubEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;SubEmployee&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">            SubEmployee emp = <span class="keyword">new</span> SubEmployee();</span><br><span class="line">            <span class="comment">//为分公司人员按顺序分配一个ID</span></span><br><span class="line">            emp.setId(<span class="string">"分公司"</span>+i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEmployee</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;SubEmployee&gt; list = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">        <span class="keyword">for</span>(SubEmployee e:list)&#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompanyManager</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">30</span>; i++)&#123;</span><br><span class="line">            Employee emp = <span class="keyword">new</span> Employee();</span><br><span class="line">            <span class="comment">//为总公司人员按顺序分配一个ID</span></span><br><span class="line">            emp.setId(<span class="string">"总公司"</span>+i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(SubCompanyManager sub)</span></span>&#123;</span><br><span class="line">        sub.printEmployee();</span><br><span class="line">        List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">        <span class="keyword">for</span>(Employee e:list2)&#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>修改后，为分公司增加了打印人员ID的方法，总公司直接调用来打印，从而避免了与分公司的员工发生耦合。<br>迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系，例如本例中，总公司就是通过分公司这个“中介”来与分公司的员工发生联系的。过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。</p>
<p><strong>开闭原则（Open Close Principle）</strong><br>定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。<br>问题由来：在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。<br>解决方案：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。<br>    开闭原则是面向对象设计中最基础的设计原则，它指导我们如何建立稳定灵活的系统。开闭原则可能是设计模式六项原则中定义最模糊的一个了，它只告诉我们对扩展开放，对修改关闭，可是到底如何才能做到对扩展开放，对修改关闭，并没有明确的告诉我们。以前，如果有人告诉我“你进行设计的时候一定要遵守开闭原则”，我会觉的他什么都没说，但貌似又什么都说了。因为开闭原则真的太虚了。<br>    在仔细思考以及仔细阅读很多设计模式的文章后，终于对开闭原则有了一点认识。其实，我们遵循设计模式前面5大原则，以及使用23种设计模式的目的就是遵循开闭原则。也就是说，只要我们对前面5项原则遵守的好了，设计出的软件自然是符合开闭原则的，这个开闭原则更像是前面五项原则遵守程度的“平均得分”，前面5项原则遵守的好，平均分自然就高，说明软件设计开闭原则遵守的好；如果前面5项原则遵守的不好，则说明开闭原则遵守的不好。<br>    其实笔者认为，开闭原则无非就是想表达这样一层意思：用抽象构建框架，用实现扩展细节。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。<br>    说到这里，再回想一下前面说的5项原则，恰恰是告诉我们用抽象构建框架，用实现扩展细节的注意事项而已：单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。<br>    最后说明一下如何去遵守这六个原则。对这六个原则的遵守并不是是和否的问题，而是多和少的问题，也就是说，我们一般不会说有没有遵守，而是说遵守程度的多少。任何事都是过犹不及，设计模式的六个设计原则也是一样，制定这六个原则的目的并不是要我们刻板的遵守他们，而需要根据实际情况灵活运用。对他们的遵守程度只要在一个合理的范围内，就算是良好的设计。我们用一幅图来说明一下。<br><a href="/uploads/2015/07/3.png"><img src="/uploads/2015/07/3-300x269.png" alt="3"></a><br>图中的每一条维度各代表一项原则，我们依据对这项原则的遵守程度在维度上画一个点，则如果对这项原则遵守的合理的话，这个点应该落在红色的同心圆内部；如果遵守的差，点将会在小圆内部；如果过度遵守，点将会落在大圆外部。一个良好的设计体现在图中，应该是六个顶点都在同心圆中的六边形。<br><a href="/uploads/2015/07/4.png"><img src="/uploads/2015/07/4-300x241.png" alt="4"></a><br>在上图中，设计1、设计2属于良好的设计，他们对六项原则的遵守程度都在合理的范围内；设计3、设计4设计虽然有些不足，但也基本可以接受；设计5则严重不足，对各项原则都没有很好的遵守；而设计6则遵守过渡了，设计5和设计6都是迫切需要重构的设计。</p>
<p>转载自 <a href="http://blog.csdn.net/zhengzhb/article/details/7296944" target="_blank" rel="noopener">http://blog.csdn.net/zhengzhb/article/details/7296944</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Web-开发/">Web 开发</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2015/07/28/设计模式六大原则/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2015/07/11/高效率去掉js数组中重复项/"><span>高效率去掉js数组中重复项</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2015/07/11/高效率去掉js数组中重复项/" rel="bookmark">
        <time class="entry-date published" datetime="2015-07-11T05:29:02.000Z">
          2015-07-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>Array类型并没有提供去重复的方法，如果要把数组的重复元素干掉，那得自己想办法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [], isRepeated;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">        isRepeated = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>, len = result.length; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == result[j]) &#123;   </span><br><span class="line">                isRepeated = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isRepeated) &#123;</span><br><span class="line">            result.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总体思路是把数组元素逐个搬运到另一个数组，搬运的过程中检查这个元素是否有重复，如果有就直接丢掉。从嵌套循环就可以看出，这种方法效率极低。我们可以 用一个hashtable的结构记录已有的元素，这样就可以避免内层循环。恰好，在Javascript中实现hashtable是极为简单的，改进如 下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [], hash = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, elem; (elem = arr[i]) != <span class="literal">null</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hash[elem]) &#123;</span><br><span class="line">            result.push(elem);</span><br><span class="line">            hash[elem] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"><span class="comment">//http://www.cnblogs.com/sosoft/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>转载自 <a href="http://www.cnblogs.com/sosoft/archive/2013/12/08/3463830.html" target="_blank" rel="noopener">http://www.cnblogs.com/sosoft/archive/2013/12/08/3463830.html</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Web-开发/">Web 开发</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2015/07/11/高效率去掉js数组中重复项/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2015/06/09/运维角度浅谈：MySQL数据库优化（转）/"><span>运维角度浅谈：MySQL数据库优化（转）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2015/06/09/运维角度浅谈：MySQL数据库优化（转）/" rel="bookmark">
        <time class="entry-date published" datetime="2015-06-09T06:23:00.000Z">
          2015-06-09
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>本博文主要谈MySQL数据库发展周期中所面临的问题及优化方案，暂且抛开前端应用不说，大致分为以下五个阶段：</p>
<p><strong>1、数据库表设计</strong><br>项目立项后，开发部根据产品部需求开发项目，开发工程师工作其中一部分就是对表结构设计。对于数据库来说，这点很重要，如果设计不当，会直接影响访问速度和用户体验。影响的因素很多，比如慢查询、低效的查询语句、没有适当建立索引、数据库堵塞（死锁）等。当然，有测试工程师的团队，会做压力测试，找bug。对于没有测试工程师的团队来说，大多数开发工程师初期不会太多考虑数据库设计是否合理，而是尽快完成功能实现和交付，等项目有一定访问量后，隐藏的问题就会暴露，这时再去修改就不是这么容易的事了。</p>
<p><strong>2、数据库部署</strong><br>该运维工程师出场了，项目初期访问量不会很大，所以单台部署足以应对在1500左右的QPS（每秒查询率）。考虑到高可用性，可采用MySQL主从复制+Keepalived做双击热备，常见集群软件有Keepalived、Heartbeat。<br>双机热备博文：<a href="http://lizhenliang.blog.51cto.com/7876557/1362313" target="_blank" rel="noopener">http://lizhenliang.blog.51cto.com/7876557/1362313</a></p>
<p><strong>3、数据库性能优化</strong><br>如果将MySQL部署到普通的X86服务器上，在不经过任何优化情况下，MySQL理论值正常可以处理2000左右QPS，经过优化后，有可能会提升到2500左右QPS，否则，访问量当达到1500左右并发连接时，数据库处理性能就会变慢，而且硬件资源还很富裕，这时就该考虑软件问题了。那么怎样让数据库最大化发挥性能呢？一方面可以单台运行多个MySQL实例让服务器性能发挥到最大化，另一方面是对数据库进行优化，往往操作系统和数据库默认配置都比较保守，会对数据库发挥有一定限制，可对这些配置进行适当的调整，尽可能的处理更多连接数。</p>
<p>具体优化有以下三个层面：<br><strong>3.1 数据库配置优化</strong><br>MySQL常用有两种存储引擎，一个是MyISAM，不支持事务处理，读性能处理快，表级别锁。另一个是InnoDB，支持事务处理（ACID），设计目标是为处理大容量数据发挥最大化性能，行级别锁。</p>
<p>表锁：开销小，锁定粒度大，发生死锁概率高，相对并发也低。<br>行锁：开销大，锁定粒度小，发生死锁概率低，相对并发也高。</p>
<p>为什么会出现表锁和行锁呢？主要是为了保证数据的完整性，举个例子，一个用户在操作一张表，其他用户也想操作这张表，那么就要等第一个用户操作完，其他用户才能操作，表锁和行锁就是这个作用。否则多个用户同时操作一张表，肯定会数据产生冲突或者异常。<br>根据以上看来，使用InnoDB存储引擎是最好的选择，也是MySQL5.5以后版本中默认存储引擎。每个存储引擎相关联参数比较多，以下列出主要影响数据库性能的参数。</p>
<p>公共参数默认值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">max_connections = 151</span><br><span class="line">#同时处理最大连接数，推荐设置最大连接数是上限连接数的80%左右</span><br><span class="line">sort_buffer_size = 2M</span><br><span class="line">#查询排序时缓冲区大小，只对order by和group by起作用，可增大此值为16M</span><br><span class="line">query_cache_limit = 1M</span><br><span class="line">#查询缓存限制，只有1M以下查询结果才会被缓存，以免结果数据较大把缓存池覆盖</span><br><span class="line">query_cache_size = 16M</span><br><span class="line">#查看缓冲区大小，用于缓存SELECT查询结果，下一次有同样SELECT查询将直接从缓存池返回结果，可适当成倍增加此值</span><br><span class="line">open_files_limit = 1024</span><br><span class="line">#打开文件数限制，如果show global status like &apos;open_files&apos;查看的值等于或者大于open_files_limit值时，程序会无法连接数据库或卡死</span><br></pre></td></tr></table></figure></p>
<p>MyISAM参数默认值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">key_buffer_size = 16M</span><br><span class="line">#索引缓存区大小，一般设置物理内存的30-40%</span><br><span class="line">read_buffer_size = 128K</span><br><span class="line">#读操作缓冲区大小，推荐设置16M或32M</span><br></pre></td></tr></table></figure></p>
<p>InnoDB参数默认值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">innodb_buffer_pool_size = 128M</span><br><span class="line">#索引和数据缓冲区大小，一般设置物理内存的60%-70%</span><br><span class="line">innodb_buffer_pool_instances = 1</span><br><span class="line">#缓冲池实例个数，推荐设置4个或8个</span><br><span class="line">innodb_flush_log_at_trx_commit = 1</span><br><span class="line">#关键参数，0代表大约每秒写入到日志并同步到磁盘，数据库故障会丢失1秒左右事务数据。1为每执行一条SQL后写入到日志并同步到磁盘，I/O开销大，执行完SQL要等待日志读写，效率低。2代表只把日志写入到系统缓存区，再每秒同步到磁盘，效率很高，如果服务器故障，才会丢失事务数据。对数据安全性要求不是很高的推荐设置2，性能高，修改后效果明显。</span><br><span class="line">innodb_file_per_table = OFF</span><br><span class="line">#默认是共享表空间，共享表空间idbdata文件不断增大，影响一定的I/O性能。推荐开启独立表空间模式，每个表的索引和数据都存在自己独立的表空间中，可以实现单表在不同数据库中移动。</span><br><span class="line">innodb_log_buffer_size = 8M</span><br><span class="line">#日志缓冲区大小，由于日志最长每秒钟刷新一次，所以一般不用超过16M</span><br></pre></td></tr></table></figure></p>
<p><strong>3.2 系统内核优化</strong><br>大多数MySQL都部署在linux系统上，所以操作系统的一些参数也会影响到MySQL性能，以下对linux内核进行适当优化。</p>
<p><strong>3.3 硬件配置</strong><br>加大物理内存，提高文件系统性能。linux内核会从内存中分配出缓存区（系统缓存和数据缓存）来存放热数据，通过文件系统延迟写入机制，等满足条件时（如缓存区大小到达一定百分比或者执行sync命令）才会同步到磁盘。也就是说物理内存越大，分配缓存区越大，缓存数据越多。当然，服务器故障会丢失一定的缓存数据。<br>SSD硬盘代替SAS硬盘，将RAID级别调整为RAID1+0，相对于RAID1和RAID5有更好的读写性能（IOPS），毕竟数据库的压力主要来自磁盘I/O方面。</p>
<p><strong>4、数据库架构扩展</strong><br>随着业务量越来越大，单台数据库服务器性能已无法满足业务需求，该考虑加机器了，该做集群了~~~。主要思想是分解单台数据库负载，突破磁盘I/O性能，热数据存放缓存中，降低磁盘I/O访问频率。</p>
<p><strong>4.1 主从复制与读写分离</strong><br>因为生产环境中，数据库大多都是读操作，所以部署一主多从架构，主数据库负责写操作，并做双击热备，多台从数据库做负载均衡，负责读操作，主流的负载均衡器有LVS、HAProxy、Nginx。怎么来实现读写分离呢？大多数企业是在代码层面实现读写分离，效率比较高。另一个种方式通过代理程序实现读写分离，企业中应用较少，常见代理程序有MySQL Proxy、Amoeba。在这样数据库集群架构中，大大增加数据库高并发能力，解决单台性能瓶颈问题。如果从数据库一台从库能处理2000 QPS，那么5台就能处理1w QPS，数据库横向扩展性也很容易。<br>有时，面对大量写操作的应用时，单台写性能达不到业务需求。如果做双主，就会遇到数据库数据不一致现象，产生这个原因是在应用程序不同的用户会有可能操作两台数据库，同时的更新操作造成两台数据库数据库数据发生冲突或者不一致。在单库时MySQL利用存储引擎机制表锁和行锁来保证数据完整性，怎样在多台主库时解决这个问题呢？有一套基于perl语言开发的主从复制管理工具，叫MySQL-MMM（Master-Master replication managerfor Mysql，Mysql主主复制管理器），这个工具最大的优点是在同一时间只提供一台数据库写操作，有效保证数据一致性。</p>
<p><strong>4.2 增加缓存</strong><br>给数据库增加缓存系统，把热数据缓存到内存中，如果内存缓存中有要请求的数据就不再去数据库中返回结果，提高读性能。缓存实现有本地缓存和分布式缓存，本地缓存是将数据缓存到本地服务器内存中或者文件中，速度快。分布式可以缓存海量数据，扩展容易，主流的分布式缓存系统有memcached、redis，memcached性能稳定，数据缓存在内存中，速度很快，QPS可达8w左右。如果想数据持久化那就用redis，性能不低于memcached。</p>
<p>工作过程：<br><a href="/uploads/2015/06/640.jpg"><img src="/uploads/2015/06/640.jpg" alt="640"></a></p>
<p><strong>4.3 分库</strong><br>分库是根据业务不同把相关的表切分到不同的数据库中，比如web、bbs、blog等库。如果业务量很大，还可将切分后的库做主从架构，进一步避免单个库压力过大。</p>
<p><strong>4.4 分表</strong><br>数据量的日剧增加，数据库中某个表有几百万条数据，导致查询和插入耗时太长，怎么能解决单表压力呢？你就该考虑是否把这个表拆分成多个小表，来减轻单个表的压力，提高处理效率，此方式称为分表。<br>分表技术比较麻烦，要修改程序代码里的SQL语句，还要手动去创建其他表，也可以用merge存储引擎实现分表，相对简单许多。分表后，程序是对一个总表进行操作，这个总表不存放数据，只有一些分表的关系，以及更新数据的方式，总表会根据不同的查询，将压力分到不同的小表上，因此提高并发能力和磁盘I/O性能。</p>
<p><strong>分表分为垂直拆分和水平拆分：</strong><br>垂直拆分：把原来的一个很多字段的表拆分多个表，解决表的宽度问题。你可以把不常用的字段单独放到一个表中，也可以把大字段独立放一个表中，或者把关联密切的字段放一个表中。<br>水平拆分：把原来一个表拆分成多个表，每个表的结构都一样，解决单表数据量大的问题。</p>
<p><strong>4.5 分区</strong><br>分区就是把一张表的数据分成多个区块，这些区块可以在一个磁盘上，也可以在不同的磁盘上，分区后，表面上还是一张表，但数据散列在多个位置，这样一来，多块硬盘同时处理不同的请求，从而提高磁盘I/O读写性能，实现比较简单。<br>注：增加缓存、分库、分表和分区主要由程序猿来实现。</p>
<p><strong>5、数据库维护</strong><br>数据库维护是运维工程师或者DBA主要工作，包括性能监控、性能分析、性能调优、数据库备份和恢复等。</p>
<p><strong>5.1 性能状态关键指标</strong></p>
<ul>
<li>QPS，Queries Per Second：每秒查询数，一台数据库每秒能够处理的查询次数；</li>
</ul>
<ul>
<li>TPS，Transactions Per Second：每秒处理事务数。</li>
</ul>
<p>通过show status查看运行状态，会有300多条状态信息记录，其中有几个值帮可以我们计算出QPS和TPS，如下：</p>
<ul>
<li>Uptime：服务器已经运行的实际，单位秒</li>
</ul>
<ul>
<li>Questions：已经发送给数据库查询数</li>
</ul>
<ul>
<li>Com_select：查询次数，实际操作数据库的</li>
</ul>
<ul>
<li>Com_insert：插入次数</li>
</ul>
<ul>
<li>Com_delete：删除次数</li>
</ul>
<ul>
<li>Com_update：更新次数</li>
</ul>
<ul>
<li>Com_commit：事务次数</li>
</ul>
<ul>
<li>Com_rollback：回滚次数</li>
</ul>
<p>那么，计算方法来了，基于Questions计算出QPS：</p>
<p>QPS = Questions / Uptime</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like 'Questions';</span><br><span class="line">mysql&gt; show global status like 'Uptime';</span><br></pre></td></tr></table></figure>
<p>基于Com_commit和Com_rollback计算出TPS：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status like 'Com_commit';</span><br><span class="line">mysql&gt; show global status like 'Com_rollback';</span><br><span class="line">mysql&gt; show global status like 'Uptime';</span><br><span class="line">TPS = (Com_commit + Com_rollback) / Uptime</span><br></pre></td></tr></table></figure></p>
<p>另一计算方式：基于Com_select、Com_insert、Com_delete、Com_update计算出QPS。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status where Variable_name in('com_select','com_insert','com_delete','com_update');</span><br><span class="line">等待1秒再执行，获取间隔差值，第二次每个变量值减去第一次对应的变量值，就是QPS</span><br></pre></td></tr></table></figure></p>
<p>TPS计算方法：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global status where Variable_name in('com_insert','com_delete','com_update');</span><br><span class="line">计算TPS，就不算查询操作了，计算出插入、删除、更新四个值即可。</span><br><span class="line">经网友对这两个计算方式的测试得出，当数据库中myisam表比较多时，使用Questions计算比较准确。当数据库中innodb表比较多时，则以Com_*计算比较准确。</span><br></pre></td></tr></table></figure></p>
<p><strong>5.2 开启慢查询日志</strong><br>MySQL开启慢查询日志，分析出哪条SQL语句比较慢，使用set设置变量，重启服务失效，可以在my.cnf添加参数永久生效。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global slow-query-log=on #开启慢查询功能</span><br><span class="line">mysql&gt; set global slow_query_log_file='/var/log/mysql/mysql-slow.log'; #指定慢查询日志文件位置</span><br><span class="line">mysql&gt; set global log_queries_not_using_indexes=on; #记录没有使用索引的查询</span><br><span class="line">mysql&gt; set global long_query_time=1; #只记录处理时间1s以上的慢查询</span><br></pre></td></tr></table></figure></p>
<p>分析慢查询日志，可以使用MySQL自带的mysqldumpslow工具，分析的日志较为简单。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> mysqldumpslow -t 3 /var/log/mysql/mysql-slow.log #查看最慢的前三个查询</span><br></pre></td></tr></table></figure></p>
<p>也可以使用percona公司的pt-query-digest工具，日志分析功能全面，可分析slow log、binlog、general log。</p>
<ul>
<li>分析慢查询日志：pt-query-digest /var/log/mysql/mysql-slow.log</li>
</ul>
<ul>
<li>分析binlog日志：mysqlbinlog mysql-bin.000001 &gt;mysql-bin.000001.sql</li>
</ul>
<ul>
<li>pt-query-digest –type=binlog mysql-bin.000001.sql</li>
</ul>
<ul>
<li>分析普通日志：pt-query-digest –type=genlog localhost.log</li>
</ul>
<p><strong>5.3 数据库备份</strong><br>备份数据库是最基本的工作，也是最重要的，否则后果很严重，你懂得！但由于数据库比较大，上百G，往往备份都很耗费时间，所以就该选择一个效率高的备份策略，对于数据量大的数据库，一般都采用增量备份。常用的备份工具有mysqldump、mysqlhotcopy、xtrabackup等，mysqldump比较适用于小的数据库，因为是逻辑备份，所以备份和恢复耗时都比较长。mysqlhotcopy和xtrabackup是物理备份，备份和恢复速度快，不影响数据库服务情况下进行热拷贝，建议使用xtrabackup，支持增量备份。<br>Xtrabackup备份工具使用博文：<a href="http://lizhenliang.blog.51cto.com/7876557/1612800" target="_blank" rel="noopener">http://lizhenliang.blog.51cto.com/7876557/1612800</a></p>
<p><strong>5.4 数据库修复</strong><br>有时候MySQL服务器突然断电、异常关闭，会导致表损坏，无法读取表数据。这时就可以用到MySQL自带的两个工具进行修复，myisamchk和mysqlcheck。</p>
<p>myisamchk：只能修复myisam表，需要停止数据库</p>
<p>常用参数：<br>-f –force 强制修复，覆盖老的临时文件，一般不使用<br>-r –recover 恢复模式<br>-q –quik 快速恢复<br>-a –analyze 分析表<br>-o –safe-recover 老的恢复模式，如果-r无法修复，可以使用此参数试试<br>-F –fast 只检查没有正常关闭的表</p>
<p>快速修复weibo数据库:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> cd /var/lib/mysql/weibo </span><br><span class="line"><span class="meta">#</span> myisamchk -r -q *.MYI</span><br></pre></td></tr></table></figure></p>
<p>mysqlcheck：myisam和innodb表都可以用，不需要停止数据库，如修复单个表，可在数据库后面添加表名，以空格分割。</p>
<p>常用参数：<br>-a –all-databases 检查所有的库<br>-r –repair 修复表<br>-c –check 检查表，默认选项<br>-a –analyze 分析表<br>-o –optimize 优化表<br>-q –quik 最快检查或修复表<br>-F –fast 只检查没有正常关闭的表</p>
<p>快速修复weibo数据库:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlcheck -r -q -uroot -p123 weibo</span><br></pre></td></tr></table></figure></p>
<p><strong>5.5 另外，查看CPU和I/O性能方法</strong></p>
<ul>
<li>查看CPU性能<a href="/uploads/2015/06/0.jpg"><img src="/uploads/2015/06/0-300x33.jpg" alt="0"></a></li>
</ul>
<ul>
<li>参数-P是显示CPU数，ALL为所有，也可以只显示第几颗<a href="/uploads/2015/06/1.jpg"><img src="/uploads/2015/06/1-300x58.jpg" alt="1"></a></li>
</ul>
<ul>
<li>查看I/O性能<a href="/uploads/2015/06/2.jpg"><img src="/uploads/2015/06/2-300x77.jpg" alt="2"></a></li>
</ul>
<p>参数-m是以M单位显示，默认K<br>%util：当达到100%时，说明I/O很忙。<br>await：请求在队列中等待时间，直接影响read时间。<br>I/O极限：IOPS（r/s+w/s）,一般在1200左右。（IOPS，每秒进行读写（I/O）操作次数）<br>I/O带宽：在顺序读写模式下SAS硬盘理论值在300M/s左右，SSD硬盘理论值在600M/s左右。</p>
<p>以上是本人使用MySQL三年来总结的一些主要优化方案，能力有限，有些不太全面，但这些基本能够满足中小型企业数据库需求。由于关系型数据库初衷设计限制，一些BAT公司海量数据放到关系型数据库中，在海量数据查询和分析方面已经达不到更好的性能。因此NoSQL火起来了，非关系型数据库，大数据量，具有高性能，同时也弥补了关系型数据库某方面不足，渐渐大多数公司已经将部分业务数据库存放到NoSQL中，如MongoDB、HBase等。数据存储方面采用分布式文件系统，如HDFS、GFS等。海量数据计算分析采用Hadoop、Spark、Storm等。这些都是与运维相关的前沿技术，也是在存储方面主要学习对象，小伙伴们共同加油吧！哪位博友有更好的优化方案，欢迎交流哦。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Web-开发/">Web 开发</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2015/06/09/运维角度浅谈：MySQL数据库优化（转）/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2015/06/03/Rolling cURL: PHP并发最佳实践/"><span>Rolling cURL: PHP并发最佳实践</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2015/06/03/Rolling cURL: PHP并发最佳实践/" rel="bookmark">
        <time class="entry-date published" datetime="2015-06-03T06:28:52.000Z">
          2015-06-03
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>在实际项目或者自己编写小工具(比如新闻聚合,商品价格监控,比价)的过程中, 通常需要从第3方网站或者API接口获取数据, 在需要处理1个URL队列时, 为了提高性能, 可以采用cURL提供的curl_multi_*族函数实现简单的并发.</p>
<p>本文将探讨两种具体的实现方法, 并对不同的方法做简单的性能对比.</p>
<p><strong>1. 经典cURL并发机制及其存在的问题</strong><br>经典的cURL实现机制在网上很容易找到, 比如参考<a href="http://php.net/manual/en/function.curl-multi-init.php" target="_blank" rel="noopener">PHP在线手册</a>的如下实现方式:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">classic_curl</span><span class="params">($urls, $delay)</span> </span>&#123;</span><br><span class="line">    $queue = curl_multi_init();</span><br><span class="line">    $map = <span class="keyword">array</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">foreach</span> ($urls <span class="keyword">as</span> $url) &#123;</span><br><span class="line">        <span class="comment">// create cURL resources</span></span><br><span class="line">        $ch = curl_init();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// set URL and other appropriate options</span></span><br><span class="line">        curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line"> </span><br><span class="line">        curl_setopt($ch, CURLOPT_TIMEOUT, <span class="number">1</span>);</span><br><span class="line">        curl_setopt($ch, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">        curl_setopt($ch, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line">        curl_setopt($ch, CURLOPT_NOSIGNAL, <span class="keyword">true</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// add handle</span></span><br><span class="line">        curl_multi_add_handle($queue, $ch);</span><br><span class="line">        $map[$url] = $ch;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    $active = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// execute the handles</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        $mrc = curl_multi_exec($queue, $active);</span><br><span class="line">    &#125; <span class="keyword">while</span> ($mrc == CURLM_CALL_MULTI_PERFORM);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> ($active &gt; <span class="number">0</span> &amp;&amp; $mrc == CURLM_OK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curl_multi_select($queue, <span class="number">0.5</span>) != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                $mrc = curl_multi_exec($queue, $active);</span><br><span class="line">            &#125; <span class="keyword">while</span> ($mrc == CURLM_CALL_MULTI_PERFORM);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    $responses = <span class="keyword">array</span>();</span><br><span class="line">    <span class="keyword">foreach</span> ($map <span class="keyword">as</span> $url=&gt;$ch) &#123;</span><br><span class="line">        $responses[$url] = callback(curl_multi_getcontent($ch), $delay);</span><br><span class="line">        curl_multi_remove_handle($queue, $ch);</span><br><span class="line">        curl_close($ch);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    curl_multi_close($queue);</span><br><span class="line">    <span class="keyword">return</span> $responses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先将所有的URL压入并发队列, 然后执行并发过程, 等待所有请求接收完之后进行数据的解析等后续处理. 在实际的处理过程中, 受网络传输的影响, 部分URL的内容会优先于其他URL返回, 但是经典cURL并发必须等待最慢的那个URL返回之后才开始处理, 等待也就意味着CPU的空闲和浪费. 如果URL队列很短, 这种空闲和浪费还处在可接受的范围, 但如果队列很长, 这种等待和浪费将变得不可接受.</p>
<p><strong>2. 改进的Rolling cURL并发方式</strong><br>仔细分析不难发现经典cURL并发还存在优化的空间, 优化的方式时当某个URL请求完毕之后尽可能快的去处理它, 边处理边等待其他的URL返回, 而不是等待那个最慢的接口返回之后才开始处理等工作, 从而避免CPU的空闲和浪费. 闲话不多说, 下面贴上具体的实现:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rolling_curl</span><span class="params">($urls, $delay)</span> </span>&#123;</span><br><span class="line">    $queue = curl_multi_init();</span><br><span class="line">    $map = <span class="keyword">array</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">foreach</span> ($urls <span class="keyword">as</span> $url) &#123;</span><br><span class="line">        $ch = curl_init();</span><br><span class="line"> </span><br><span class="line">        curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">        curl_setopt($ch, CURLOPT_TIMEOUT, <span class="number">1</span>);</span><br><span class="line">        curl_setopt($ch, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">        curl_setopt($ch, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line">        curl_setopt($ch, CURLOPT_NOSIGNAL, <span class="keyword">true</span>);</span><br><span class="line"> </span><br><span class="line">        curl_multi_add_handle($queue, $ch);</span><br><span class="line">        $map[(string) $ch] = $url;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    $responses = <span class="keyword">array</span>();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (($code = curl_multi_exec($queue, $active)) == CURLM_CALL_MULTI_PERFORM) ;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> ($code != CURLM_OK) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// a request was just completed -- find out which one</span></span><br><span class="line">        <span class="keyword">while</span> ($done = curl_multi_info_read($queue)) &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// get the info and content returned on the request</span></span><br><span class="line">            $info = curl_getinfo($done[<span class="string">'handle'</span>]);</span><br><span class="line">            $error = curl_error($done[<span class="string">'handle'</span>]);</span><br><span class="line">            $results = callback(curl_multi_getcontent($done[<span class="string">'handle'</span>]), $delay);</span><br><span class="line">            $responses[$map[(string) $done[<span class="string">'handle'</span>]]] = compact(<span class="string">'info'</span>, <span class="string">'error'</span>, <span class="string">'results'</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// remove the curl handle that just completed</span></span><br><span class="line">            curl_multi_remove_handle($queue, $done[<span class="string">'handle'</span>]);</span><br><span class="line">            curl_close($done[<span class="string">'handle'</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Block for data in / output; error handling is done by curl_multi_exec</span></span><br><span class="line">        <span class="keyword">if</span> ($active &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            curl_multi_select($queue, <span class="number">0.5</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">while</span> ($active);</span><br><span class="line"> </span><br><span class="line">    curl_multi_close($queue);</span><br><span class="line">    <span class="keyword">return</span> $responses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>3. 两种并发实现的性能对比</strong><br>改进前后的性能对比试验在LINUX主机上进行, 测试时使用的并发队列如下:</p>
<ul>
<li><a href="http://item.taobao.com/item.htm?id=14392877692" target="_blank" rel="noopener">http://item.taobao.com/item.htm?id=14392877692</a></li>
</ul>
<ul>
<li><a href="http://item.taobao.com/item.htm?id=16231676302" target="_blank" rel="noopener">http://item.taobao.com/item.htm?id=16231676302</a></li>
</ul>
<ul>
<li><a href="http://item.taobao.com/item.htm?id=17037160462" target="_blank" rel="noopener">http://item.taobao.com/item.htm?id=17037160462</a></li>
</ul>
<ul>
<li><a href="http://item.taobao.com/item.htm?id=5522416710" target="_blank" rel="noopener">http://item.taobao.com/item.htm?id=5522416710</a></li>
</ul>
<ul>
<li><a href="http://item.taobao.com/item.htm?id=16551116403" target="_blank" rel="noopener">http://item.taobao.com/item.htm?id=16551116403</a></li>
</ul>
<ul>
<li><a href="http://item.taobao.com/item.htm?id=14088310973" target="_blank" rel="noopener">http://item.taobao.com/item.htm?id=14088310973</a></li>
</ul>
<p>简要说明下实验设计的原则和性能测试结果的格式: 为保证结果的可靠, 每组实验重复20次, 在单次实验中, 给定相同的接口URL集合, 分别测量Classic(指经典的并发机制)和Rolling(指改进后的并发机制)两种并发机制的耗时(秒为单位), 耗时短者胜出(Winner), 并计算节省的时间(Excellence, 秒为单位)以及性能提升比例(Excel. %). 为了尽量贴近真实的请求而又保持实验的简单, 在对返回结果的处理上只是做了简单的正则表达式匹配, 而没有进行其他复杂的操作. 另外, 为了确定结果处理回调对性能对比测试结果的影响, 可以使用usleep模拟现实中比较负责的数据处理逻辑(如提取, 分词, 写入文件或数据库等).</p>
<p>性能测试中用到的回调函数为:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span><span class="params">($data, $delay)</span> </span>&#123;</span><br><span class="line">    preg_match_all(<span class="string">'/&lt;h3&gt;(.+)&lt;\/h3&gt;/iU'</span>, $data, $matches);</span><br><span class="line">    usleep($delay);</span><br><span class="line">    <span class="keyword">return</span> compact(<span class="string">'data'</span>, <span class="string">'matches'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>数据处理回调无延迟时: Rolling Curl略优, 但性能提升效果不明显.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------------------------------------------------------------------</span><br><span class="line">Delay: 0 micro seconds, equals to 0 milli seconds</span><br><span class="line">------------------------------------------------------------------------------------------------</span><br><span class="line">Counter         Classic         Rolling         Winner          Excellence      Excel. %</span><br><span class="line">------------------------------------------------------------------------------------------------</span><br><span class="line">1               0.1193          0.0390          Rolling         0.0803          67.31%</span><br><span class="line">2               0.0556          0.0477          Rolling         0.0079          14.21%</span><br><span class="line">3               0.0461          0.0588          Classic         -0.0127         -21.6%</span><br><span class="line">4               0.0464          0.0385          Rolling         0.0079          17.03%</span><br><span class="line">5               0.0534          0.0448          Rolling         0.0086          16.1%</span><br><span class="line">6               0.0540          0.0714          Classic         -0.0174         -24.37%</span><br><span class="line">7               0.0386          0.0416          Classic         -0.0030         -7.21%</span><br><span class="line">8               0.0357          0.0398          Classic         -0.0041         -10.3%</span><br><span class="line">9               0.0437          0.0442          Classic         -0.0005         -1.13%</span><br><span class="line">10              0.0319          0.0348          Classic         -0.0029         -8.33%</span><br><span class="line">11              0.0529          0.0430          Rolling         0.0099          18.71%</span><br><span class="line">12              0.0503          0.0581          Classic         -0.0078         -13.43%</span><br><span class="line">13              0.0344          0.0225          Rolling         0.0119          34.59%</span><br><span class="line">14              0.0397          0.0643          Classic         -0.0246         -38.26%</span><br><span class="line">15              0.0368          0.0489          Classic         -0.0121         -24.74%</span><br><span class="line">16              0.0502          0.0394          Rolling         0.0108          21.51%</span><br><span class="line">17              0.0592          0.0383          Rolling         0.0209          35.3%</span><br><span class="line">18              0.0302          0.0285          Rolling         0.0017          5.63%</span><br><span class="line">19              0.0248          0.0553          Classic         -0.0305         -55.15%</span><br><span class="line">20              0.0137          0.0131          Rolling         0.0006          4.38%</span><br><span class="line">------------------------------------------------------------------------------------------------</span><br><span class="line">Average         0.0458          0.0436          Rolling         0.0022          4.8%</span><br><span class="line">------------------------------------------------------------------------------------------------</span><br><span class="line">Summary: Classic wins 10 times, while Rolling wins 10 times</span><br></pre></td></tr></table></figure></p>
<p>数据处理回调延迟5毫秒: Rolling Curl完胜, 性能提升40%左右.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------------------------------------------------------------------</span><br><span class="line">Delay: 5000 micro seconds, equals to 5 milli seconds</span><br><span class="line">------------------------------------------------------------------------------------------------</span><br><span class="line">Counter         Classic         Rolling         Winner          Excellence      Excel. %</span><br><span class="line">------------------------------------------------------------------------------------------------</span><br><span class="line">1               0.0658          0.0352          Rolling         0.0306          46.5%</span><br><span class="line">2               0.0728          0.0367          Rolling         0.0361          49.59%</span><br><span class="line">3               0.0732          0.0387          Rolling         0.0345          47.13%</span><br><span class="line">4               0.0783          0.0347          Rolling         0.0436          55.68%</span><br><span class="line">5               0.0658          0.0286          Rolling         0.0372          56.53%</span><br><span class="line">6               0.0687          0.0362          Rolling         0.0325          47.31%</span><br><span class="line">7               0.0787          0.0337          Rolling         0.0450          57.18%</span><br><span class="line">8               0.0676          0.0391          Rolling         0.0285          42.16%</span><br><span class="line">9               0.0668          0.0351          Rolling         0.0317          47.46%</span><br><span class="line">10              0.0603          0.0317          Rolling         0.0286          47.43%</span><br><span class="line">11              0.0714          0.0350          Rolling         0.0364          50.98%</span><br><span class="line">12              0.0627          0.0215          Rolling         0.0412          65.71%</span><br><span class="line">13              0.0617          0.0401          Rolling         0.0216          35.01%</span><br><span class="line">14              0.0721          0.0226          Rolling         0.0495          68.65%</span><br><span class="line">15              0.0701          0.0428          Rolling         0.0273          38.94%</span><br><span class="line">16              0.0674          0.0352          Rolling         0.0322          47.77%</span><br><span class="line">17              0.0452          0.0425          Rolling         0.0027          5.97%</span><br><span class="line">18              0.0596          0.0366          Rolling         0.0230          38.59%</span><br><span class="line">19              0.0679          0.0480          Rolling         0.0199          29.31%</span><br><span class="line">20              0.0657          0.0338          Rolling         0.0319          48.55%</span><br><span class="line">------------------------------------------------------------------------------------------------</span><br><span class="line">Average         0.0671          0.0354          Rolling         0.0317          47.24%</span><br><span class="line">------------------------------------------------------------------------------------------------</span><br><span class="line">Summary: Classic wins 0 times, while Rolling wins 20 times</span><br></pre></td></tr></table></figure></p>
<p>通过上面的性能对比, 在处理URL队列并发的应用场景中Rolling cURL应该是更加的选择, 并发量非常大(1000+)时, 可以控制并发队列的最大长度, 比如20, 每当1个URL返回并处理完毕之后立即加入1个尚未请求的URL到队列中, 这样写出来的代码会更加健壮, 不至于并发数太大而卡死或崩溃. 详细的实现请参考: <a href="http://code.google.com/p/rolling-curl/" target="_blank" rel="noopener">http://code.google.com/p/rolling-curl/</a>（博主注：<a href="/uploads/2015/06/temp.zip">rolling-curl 源码下载</a>）</p>
<p><strong>5. 参考资料和延伸阅读</strong></p>
<ul>
<li>Client URL Library <a href="http://www.php.net/manual/en/book.curl.php" target="_blank" rel="noopener">http://www.php.net/manual/en/book.curl.php</a></li>
</ul>
<ul>
<li>Parallel CURL Requests with PHP <a href="http://blog.rob.cx/multi-curl" target="_blank" rel="noopener">http://blog.rob.cx/multi-curl</a></li>
</ul>
<ul>
<li>A more efficient multi-curl library for PHP (non-blocking) <a href="http://code.google.com/p/rolling-curl/" target="_blank" rel="noopener">http://code.google.com/p/rolling-curl/</a></li>
</ul>
<ul>
<li>PHP: Parallel cURL Performance <a href="http://stackoverflow.com/questions/10485199/php-parallel-curl-performance-rollingcurl-vs-parallelcurl" target="_blank" rel="noopener">http://stackoverflow.com/questions/10485199/php-parallel-curl-performance-rollingcurl-vs-parallelcurl</a></li>
</ul>
<p>转载自 <a href="http://www.searchtb.com/2012/06/rolling-curl-best-practices.html" target="_blank" rel="noopener">http://www.searchtb.com/2012/06/rolling-curl-best-practices.html</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Web-开发/">Web 开发</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2015/06/03/Rolling cURL: PHP并发最佳实践/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2015/06/02/Ubuntu 14.04 安装 QQ 7.2/"><span>Ubuntu 14.04 安装 QQ 7.2</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2015/06/02/Ubuntu 14.04 安装 QQ 7.2/" rel="bookmark">
        <time class="entry-date published" datetime="2015-06-02T05:24:27.000Z">
          2015-06-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>　　首先，添加 ppa，并安装 wine1.7。要是 apt-get update 的时候报错请参考前一篇文章《<a href="http://futa.ooo/2218.html">Ubuntu 使用 shadowsocks 科学上网</a>》。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:ubuntu-wine/ppa</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install wine1.7</span><br></pre></td></tr></table></figure></p>
<p>　　wine 1.7 安装完成后，安装一些依赖：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">winetricks riched20 gdiplus msxml4 vcrun2005 msctf mfc42 fakechinese corefonts sound=alsa</span><br></pre></td></tr></table></figure></p>
<p>　　之后，将 win 下字体文件夹（C:\Windows\Fonts）内的所有字体复制至 ~/.wine/drive_c/windows/Fonts。<br>　　打开 <a href="http://im.qq.com" target="_blank" rel="noopener">http://im.qq.com</a> 下载最新版 QQ，双击安装即可。<br>　　安装完成后，需要自行建立快捷方式：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~/桌面/QQ.desktop</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Name=腾讯QQ</span><br><span class="line">Exec=wine &quot;C:\\Program Files (x86)\\Tencent\\QQ\\bin\\QQ.exe&quot;</span><br><span class="line">Type=Application</span><br><span class="line">StartupNotify=true</span><br></pre></td></tr></table></figure>
<p>　　给快捷方式加上可执行权限：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ~/桌面/QQ.desktop</span><br></pre></td></tr></table></figure></p>
<p>　　效果如图<br><a href="/uploads/2015/06/Screenshots_2015_06_02_21_09_01.png"><img src="/uploads/2015/06/Screenshots_2015_06_02_21_09_01-300x169.png" alt="Screenshots_2015_06_02_21_09_01"></a></p>
<p>　　小 bug 还是有点的，比如图中有些字依旧是方块，不过是字体问题，找到对应字体 copy 下就行。还有，切记！千！万！不！能！最！小！化！消！息！列！表！因为没有状态栏。。。要是不小心最小化或者不见了，可以用以下命令解决问题：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">killall QQ.exe</span><br><span class="line">wine "C:\\Program Files (x86)\\Tencent\\QQ\\bin\\QQ.exe"</span><br></pre></td></tr></table></figure></p>
<p>　　你没看错。。就是重启 QQ</p>
<p>　　最后，提供几个比较好的补丁，希望各位喜欢：</p>
<ul>
<li><a href="http://www.laibude.com/blog/22.html" target="_blank" rel="noopener">QQ7.3小清新补丁</a></li>
</ul>
<ul>
<li><a href="http://www.zdfans.com/589.html" target="_blank" rel="noopener">腾讯QQ7.x 去整体安全校验补丁v3.0</a></li>
</ul>
<ul>
<li><a href="http://www.zdfans.com/583.html" target="_blank" rel="noopener">腾讯QQ7.2 正式版SVIP超级会员补丁</a></li>
</ul>
<p>　　感谢 <a href="https://www.maou.me" target="_blank" rel="noopener">(╯‵□′)╯︵┻━┻</a> 提供技术支持。</p>
<p>　　参考：</p>
<ul>
<li><a href="https://www.maou.me/20.html" target="_blank" rel="noopener">Linux 通过 Wine 来安装最新 QQ 的方法</a></li>
</ul>
<ul>
<li><a href="http://blog.aizhet.com/Windows/12172.html" target="_blank" rel="noopener">彻底消除wine中文乱码、QQ等</a></li>
</ul>
<ul>
<li><a href="http://forum.ubuntu.org.cn/viewtopic.php?f=121&amp;t=455783" target="_blank" rel="noopener">Ubuntu12.04+Wine1.7.12近完美使用QQ5.0</a></li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Linux-Desktop/">Linux Desktop</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2015/06/02/Ubuntu 14.04 安装 QQ 7.2/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2015/05/31/Ubuntu 使用 shadowsocks 科学上网/"><span>Ubuntu 使用 shadowsocks 科学上网</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2015/05/31/Ubuntu 使用 shadowsocks 科学上网/" rel="bookmark">
        <time class="entry-date published" datetime="2015-05-31T04:26:30.000Z">
          2015-05-31
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>　　不知道为什么我的系统运行有 gui 的版本会假死。。Ubuntu 14.04：<br><a href="/uploads/2015/05/2015-05-31-201021屏幕截图.png"><img src="/uploads/2015/05/2015-05-31-201021屏幕截图-300x174.png" alt="2015-05-31 20:10:21屏幕截图"></a><br>　　所以，我用了 sslocal + tsocks 实现的科学上网，chrome 需要插件 SwitchyOmega，文末提供下载链接及安装配置方法。<br>　　首先，安装 sslocal，<code>pip install shadowsocks</code></p>
<p>　　安装完成后，新建 json 配置文件，这里位置为 /etc/shadowsocks.json，文件内容大致如下：<br><a href="/uploads/2015/05/QQ截图20150531201514.png"><img src="/uploads/2015/05/QQ截图20150531201514-300x182.png" alt="QQ截图20150531201514"></a><br>　　配置完成后，运行 sslocal<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sslocal -c /etc/shadowsocks.json --pid-file /var/run/shadowsocks.pid -d start</span><br></pre></td></tr></table></figure></p>
<p>　　安装 tsocks 实现 socks5 转 http 代理：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install tsocks</span><br></pre></td></tr></table></figure></p>
<p> 　　配置 tsocks（/etc/tsocks.conf）：<br><a href="/uploads/2015/05/QQ截图20150531201836.png"><img src="/uploads/2015/05/QQ截图20150531201836-300x182.png" alt="QQ截图20150531201836"></a><br>　　使用时只需在命令前加上 tsocks 即可，比如 tsocks apt-get update</p>
<p>　　关于 chrome 的配置：<br>　　下载 <a href="/uploads/2015/05/SwitchyOmega.zip">SwitchyOmega</a>，并解压。将解压出来的 SwitchyOmega.crx 拖动至 <a href="chrome://extensions/" target="_blank" rel="noopener">chrome://extensions/</a> 安装即可。<br>　　安装完成后会自动弹出配置页，如图配置即可：<br><a href="/uploads/2015/05/2015-05-31-202554屏幕截图.png"><img src="/uploads/2015/05/2015-05-31-202554屏幕截图-300x169.png" alt="2015-05-31 20:25:54屏幕截图"></a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Linux-Desktop/">Linux Desktop</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2015/05/31/Ubuntu 使用 shadowsocks 科学上网/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2015/05/07/感觉我又恶劣了一把。。/"><span>感觉我又恶劣了一把。。</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2015/05/07/感觉我又恶劣了一把。。/" rel="bookmark">
        <time class="entry-date published" datetime="2015-05-07T04:25:07.000Z">
          2015-05-07
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>以前研究学校的 WiFi，写过一篇文章：<a href="http://futa.ooo/1988.html">纯靠点小聪明搞定学校 WiFi 该死的 web 登陆</a>，然后利用这个。。。咳咳懂的。但最近遇到点事情需要收回账号，但给出账号时已经给出了所有权限，包括修改密码的，结果只能用点特殊手段，看图。<br><a href="/uploads/2015/05/QQ图片20150507200223.png"><img src="/uploads/2015/05/QQ图片20150507200223-169x300.png" alt="QQ图片20150507200223"></a><br>输错五次密码自动锁定五分钟。。这样的话，要永久锁定不就是件很简单的事情了？只要写个程序不断模拟提交错误密码就行，但是，这里却遇到个问题：验证码。网上搜了很多资料，发现一篇很有用的文章：<a href="http://www.geekso.com/Valite2/" target="_blank" rel="noopener">http://www.geekso.com/Valite2/</a> 修改了下字模，很顺利地认出了学校 Web Portal 弱智的验证码：<br><a href="/uploads/2015/05/QQ图片20150507201318-e1431000789257.jpg"><img src="/uploads/2015/05/QQ图片20150507201318-e1431000789257-169x300.jpg" alt="QQ图片20150507201318"></a><br>2333，写完以后扔在了一部小渣机里，结果居然不卡<br><a href="/uploads/2015/05/QQ图片20150507185259.jpg"><img src="/uploads/2015/05/QQ图片20150507185259-300x169.jpg" alt="QQ图片20150507185259"></a><br><a href="/uploads/2015/05/QQ图片20150507185322.jpg"><img src="/uploads/2015/05/QQ图片20150507185322-300x162.jpg" alt="QQ图片20150507185322"></a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Web-开发/">Web 开发</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2015/05/07/感觉我又恶劣了一把。。/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2015/04/17/用.htaccess设置PHP错误显示(转)/"><span>用.htaccess设置PHP错误显示(转)</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2015/04/17/用.htaccess设置PHP错误显示(转)/" rel="bookmark">
        <time class="entry-date published" datetime="2015-04-17T06:37:32.000Z">
          2015-04-17
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>今天在网上看到使用.htaccess可以在某种程度上更改PHP的错误显示的设置，实际上相当于更改PHP.ini的参数，很是方便。将以下相应代码放到对应目录中的.htaccess文件，即可实现相应功能。</p>
<p>关闭错误显示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">php_flag display_startup_errors off</span><br><span class="line">php_flag display_errors off</span><br><span class="line">php_flag html_errors off</span><br><span class="line">php_value docref_root 0</span><br><span class="line">php_value docref_ext 0</span><br></pre></td></tr></table></figure></p>
<p>只显示PHP错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">php_flag  display_errors        on</span><br><span class="line">php_flag  display_startup_errors on</span><br><span class="line">php_value error_reporting        2047</span><br></pre></td></tr></table></figure></p>
<p>其中，“2047”为要显示的错误的级别，详细表格如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1 E_ERROR</span><br><span class="line">2 E_WARNING</span><br><span class="line">4 E_PARSE</span><br><span class="line">8 E_NOTICE</span><br><span class="line">16 E_CORE_ERROR</span><br><span class="line">32 E_CORE_WARNING</span><br><span class="line">64 E_COMPILE_ERROR</span><br><span class="line">128 E_COMPILE_WARNING</span><br><span class="line">256 E_USER_ERROR</span><br><span class="line">512 E_USER_WARNING</span><br><span class="line">1024 E_USER_NOTICE</span><br><span class="line">2047 E_ALL</span><br><span class="line">2048 E_STRICT</span><br><span class="line">4096 E_RECOVERABLE_ERROR</span><br></pre></td></tr></table></figure></p>
<p>要把错误保存到日志文件中，可以这样设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># enable PHP error logging</span><br><span class="line">php_flag  log_errors on</span><br><span class="line">php_value error_log  /home/path/public_html/domain/PHP_errors.log</span><br></pre></td></tr></table></figure></p>
<p>然后，可以设置不允许访问.log文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># prevent access to PHP error log</span><br><span class="line">&lt;Files PHP_errors.log&gt;</span><br><span class="line"> Order allow,deny</span><br><span class="line"> Deny from all</span><br><span class="line"> Satisfy All</span><br><span class="line">&lt;/Files&gt;</span><br></pre></td></tr></table></figure></p>
<p>设置错误日志的最大体积，以bytes为单位：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># general directive for</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> setting max error size</span><br><span class="line">log_errors_max_len integer</span><br></pre></td></tr></table></figure></p>
<p>综合上述，.htaccess的PHP错误显示设置汇总：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"># PHP error handling for production servers</span><br><span class="line"></span><br><span class="line"># disable display of startup errors</span><br><span class="line">php_flag display_startup_errors off</span><br><span class="line"></span><br><span class="line"># disable display of all other errors</span><br><span class="line">php_flag display_errors off</span><br><span class="line"></span><br><span class="line"># disable html markup of errors</span><br><span class="line">php_flag html_errors off</span><br><span class="line"></span><br><span class="line"># enable logging of errors</span><br><span class="line">php_flag log_errors on</span><br><span class="line"></span><br><span class="line"># disable ignoring of repeat errors</span><br><span class="line">php_flag ignore_repeated_errors off</span><br><span class="line"></span><br><span class="line"># disable ignoring of unique source errors</span><br><span class="line">php_flag ignore_repeated_source off</span><br><span class="line"></span><br><span class="line"># enable logging of php memory leaks</span><br><span class="line">php_flag report_memleaks on</span><br><span class="line"></span><br><span class="line"># preserve most recent error via php_errormsg</span><br><span class="line">php_flag track_errors on</span><br><span class="line"></span><br><span class="line"># disable formatting of error reference links</span><br><span class="line">php_value docref_root 0</span><br><span class="line"></span><br><span class="line"># disable formatting of error reference links</span><br><span class="line">php_value docref_ext 0</span><br><span class="line"></span><br><span class="line"># specify path to php error log</span><br><span class="line">php_value error_log /home/path/public_html/domain/PHP_errors.log</span><br><span class="line"></span><br><span class="line"># specify recording of all php errors</span><br><span class="line">php_value error_reporting 999999999</span><br><span class="line"></span><br><span class="line"># disable max error string length</span><br><span class="line">php_value log_errors_max_len 0</span><br><span class="line"></span><br><span class="line"># protect error log by preventing public access</span><br><span class="line">&lt;Files /home/path/public_html/domain/PHP_errors.log&gt;</span><br><span class="line"> Order allow,deny</span><br><span class="line"> Deny from all</span><br><span class="line"> Satisfy All</span><br><span class="line">&lt;/Files&gt;</span><br></pre></td></tr></table></figure></p>
<p>以下则是适合开发者应用的设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># PHP error handling for</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> development servers</span><br><span class="line">php_flag display_startup_errors on</span><br><span class="line">php_flag display_errors on</span><br><span class="line">php_flag html_errors on</span><br><span class="line">php_flag log_errors on</span><br><span class="line">php_flag ignore_repeated_errors off</span><br><span class="line">php_flag ignore_repeated_source off</span><br><span class="line">php_flag report_memleaks on</span><br><span class="line">php_flag track_errors on</span><br><span class="line">php_value docref_root 0</span><br><span class="line">php_value docref_ext 0</span><br><span class="line">php_value error_log /home/path/public_html/domain/PHP_errors.log</span><br><span class="line">php_value error_reporting 999999999</span><br><span class="line">php_value log_errors_max_len 0</span><br><span class="line"></span><br><span class="line">&lt;Files /home/path/public_html/domain/PHP_errors.log&gt;</span><br><span class="line"> Order allow,deny</span><br><span class="line"> Deny from all</span><br><span class="line"> Satisfy All</span><br><span class="line">&lt;/Files&gt;</span><br></pre></td></tr></table></figure></p>
<p>本文大部分内容参考这篇文章：<a href="http://perishablepress.com/press/2007/12/17/how-to-enable-php-error-logging-via-htaccess/" target="_blank" rel="noopener">How to Enable PHP Error Logging via htaccess</a> ，大家有兴趣的话可以阅读英文原版。</p>
<p>转载自 <a href="http://blog.slogra.com/post-79.html" target="_blank" rel="noopener">http://blog.slogra.com/post-79.html</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Web-开发/">Web 开发</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2015/04/17/用.htaccess设置PHP错误显示(转)/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2015/04/13/Shell中处理包含空格的文件名实例/"><span>Shell中处理包含空格的文件名实例</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2015/04/13/Shell中处理包含空格的文件名实例/" rel="bookmark">
        <time class="entry-date published" datetime="2015-04-13T04:24:29.000Z">
          2015-04-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>这篇文章主要介绍了Shell中处理包含空格的文件名实例,需要的朋友可以参考下</p>
<p>今天在处理文件时遇到个问题，当文件名包含空格时，for循环就出问题了。<br>例如，我在当前文件夹下建立3个文件名包含空格的文件：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">keakons-MacBook-Pro:test keakon$ touch "test 1"</span><br><span class="line">keakons-MacBook-Pro:test keakon$ touch "test 2"</span><br><span class="line">keakons-MacBook-Pro:test keakon$ touch "test 3"</span><br><span class="line">keakons-MacBook-Pro:test keakon$ ls</span><br><span class="line">test 1 test 2 test 3</span><br></pre></td></tr></table></figure></p>
<p>然后for循环输出文件名：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">keakons-MacBook-Pro:test keakon$ for file in `ls`;</span><br><span class="line"><span class="meta">&gt;</span> do echo $file;</span><br><span class="line"><span class="meta">&gt;</span> done</span><br><span class="line">test</span><br><span class="line">1</span><br><span class="line">test</span><br><span class="line">2</span><br><span class="line">test</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<p>可以看到，文件名被分开了。<br>复制操作也不行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">keakons-MacBook-Pro:test keakon$ mkdir ../bak</span><br><span class="line">keakons-MacBook-Pro:test keakon$ for file in `ls`; do cp "$file" ../bak; done</span><br><span class="line">cp: bak is a directory (not copied).</span><br><span class="line">cp: test: No such file or directory</span><br><span class="line">cp: 1: No such file or directory</span><br><span class="line">cp: test: No such file or directory</span><br><span class="line">cp: 2: No such file or directory</span><br><span class="line">cp: test: No such file or directory</span><br><span class="line">cp: 3: No such file or directory</span><br></pre></td></tr></table></figure></p>
<p>要解决这个问题，当然就要从单词分隔符着手。而bash中使用的是$IFS（Internal Field Separator）这个变量，内容为” \n\t”：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">keakons-MacBook-Pro:test keakon$ echo $IFS  </span><br><span class="line"> keakons-MacBook-Pro:test keakon$ echo "$IFS" | od -t x1</span><br><span class="line">0000000    20  09  0a  0a                                                </span><br><span class="line">0000004</span><br><span class="line">keakons-MacBook-Pro:test keakon$ echo "" | od -t x1</span><br><span class="line">0000000    0a                                                            </span><br><span class="line">0000001</span><br></pre></td></tr></table></figure></p>
<p>然后把它改成”\n\b”，记得修改前先保存一下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keakons-MacBook-Pro:test keakon$ SAVEIFS=$IFS</span><br><span class="line">keakons-MacBook-Pro:test keakon$ IFS=$(echo -en "\n\b")</span><br></pre></td></tr></table></figure></p>
<p>现在再执行上述命令就正常了：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">keakons-MacBook-Pro:test keakon$ for file in `ls`; do echo $file; done</span><br><span class="line">test 1</span><br><span class="line">test 2</span><br><span class="line">test 3</span><br><span class="line">keakons-MacBook-Pro:test keakon$ for file in `ls`; do cp "$file" ../bak; done</span><br><span class="line">keakons-MacBook-Pro:test keakon$ ls ../bak</span><br><span class="line">test 1 test 2 test 3</span><br></pre></td></tr></table></figure></p>
<p>最后，别忘了恢复$IFS：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">keakons-MacBook-Pro:test keakon$ IFS=$SAVEIFS</span><br><span class="line">keakons-MacBook-Pro:test keakon$ echo "$IFS" | od -t x1</span><br><span class="line">0000000    20  09  0a  0a                                                </span><br><span class="line">0000004</span><br><span class="line">keakons-MacBook-Pro:test keakon$ IFS=$(echo -en " \n\t")</span><br><span class="line">keakons-MacBook-Pro:test keakon$ echo "$IFS" | od -t x1</span><br><span class="line">0000000    20  0a  09  0a                                                </span><br><span class="line">0000004</span><br></pre></td></tr></table></figure></p>
<p>转载自 <a href="http://www.jb51.net/article/49797.htm" target="_blank" rel="noopener">http://www.jb51.net/article/49797.htm</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/VPS-技术/">VPS 技术</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2015/04/13/Shell中处理包含空格的文件名实例/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2015/04/07/Redbean：入门(一) - 增删改查/"><span>Redbean：入门(一) - 增删改查</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2015/04/07/Redbean：入门(一) - 增删改查/" rel="bookmark">
        <time class="entry-date published" datetime="2015-04-07T07:05:30.000Z">
          2015-04-07
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">require_once</span> <span class="string">'rb.php'</span>;</span><br><span class="line">    $tableName = <span class="string">"link"</span>;</span><br><span class="line">    <span class="comment">//链接数据库</span></span><br><span class="line">    R::setup(<span class="string">"mysql:host=localhost;dbname=hwibs_model"</span>,<span class="string">"root"</span>,<span class="string">""</span>);</span><br><span class="line">    <span class="comment">//创建一个表（也可以指为实例化一个表）</span></span><br><span class="line">    $handler = R::dispense($tableName);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">#####################################   add #####################################</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*同上[同时实例化多个表]</span></span><br><span class="line"><span class="comment">        list($handler_1,$handler_2) = R::dispenseALL("test_1,test_2");</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//对象方式给字段赋值</span></span><br><span class="line">    <span class="comment">//::注意，如果字段不存在，store方法过后，会自动添加对应的字段，并且自动根据字段值设置字段的对应字段类型</span></span><br><span class="line">    $handler-&gt;name = <span class="string">"haha"</span>;</span><br><span class="line">    $handler-&gt;url = <span class="string">"isxiugai"</span>;</span><br><span class="line">    $handler-&gt;plushtime = time() - <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">//如果有下划线的字段名，则可以使用驼峰法命名，将自动转换为下划线</span></span><br><span class="line">    $handler-&gt;isMyName = <span class="keyword">false</span>;<span class="comment">// = is_my_name</span></span><br><span class="line">    <span class="comment">//执行,此静态方法会返回添加成功后的自增id值(单个)</span></span><br><span class="line">    $inser_id = R::store($handler);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#####################################   query ####################################</span></span><br><span class="line">    <span class="comment">//获取记录句柄(参数1为表名，参数2为id值),返回值为对象集合</span></span><br><span class="line">    <span class="comment">//如果id不存在，则返回0</span></span><br><span class="line">    <span class="comment">//注意，这个获取到的句柄，可以用于删除操作</span></span><br><span class="line">    $bean  = R::load($tableName,<span class="number">4</span>);<span class="comment">//获取单个</span></span><br><span class="line">    $beans = R::loadAll($tableName,<span class="keyword">array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>));<span class="comment">//获取多个</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#####################################   update #####################################</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.注意，修改跟add的唯一区别就是id，如果id不为空，则为修改，否则则为添加!</span></span><br><span class="line">    <span class="comment">//2.如果id不存在的情况下，既不会添加，也不会修改！所以一般在修改前，需要事先用load进行判断是否存在</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">foreach</span> ($beans <span class="keyword">as</span> $k=&gt;$v)&#123;</span><br><span class="line">        $beans[$k]-&gt;url = rand(<span class="number">100</span>,<span class="number">5555</span>);<span class="comment">//测试[循环将每个记录对象中的url赋值一个随机数]</span></span><br><span class="line">    &#125;</span><br><span class="line">    R::storeAll($beans);<span class="comment">//执行修改</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">#####################################   delete #####################################</span></span><br><span class="line">    <span class="comment">//删除单个::成功或失败都是返回null</span></span><br><span class="line">    var_dump(R::trash(R::load($tableName,<span class="number">1</span>)));</span><br><span class="line">    <span class="comment">//删除多个::如果有不存在的，则会只删除存在的,成功或失败都是返回null</span></span><br><span class="line">    var_dump(R::trashAll(R::loadALL($tableName,<span class="keyword">array</span>(<span class="number">117</span>,<span class="number">118</span>))));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">#####################################   other #####################################</span></span><br><span class="line">    <span class="comment">//清除表中所有数据::相当于truncate，因为会将自增指针重置</span></span><br><span class="line">    <span class="comment">//R::wipe($tableName);</span></span><br><span class="line">    <span class="comment">//删除数据库中所有的表,[无语的功能，要这个搞毛]</span></span><br><span class="line">    <span class="comment">//var_dump(R::nuke());</span></span><br><span class="line">    <span class="comment">//关闭链接</span></span><br><span class="line">    R::close();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>转载自 <a href="http://www.cnblogs.com/shibazi/archive/2014/08/02/3887246.html" target="_blank" rel="noopener">http://www.cnblogs.com/shibazi/archive/2014/08/02/3887246.html</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Web-开发/">Web 开发</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2015/04/07/Redbean：入门(一) - 增删改查/#comment">评论</a>
        </span>
      </span>
    </div>
    
  </div>
</article>




<nav class="pagination">
  
  <a href="/page/7/" class="pagination-prev">上一页</a>
  
  
  <a href="/page/9/" class="pagination-next">下一页</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2020 403 Forbidden
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>