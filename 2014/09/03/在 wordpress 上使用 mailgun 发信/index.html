<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>在 wordpress 上使用 mailgun 发信 | 博客</title>

  
  <meta name="author" content="403 Forbidden">
  

  
  <meta name="description" content="前几天研究多说插件的评论回复邮件通知(修改多说插件，实现评论邮件通知自定义样式)的时候，发现本博客用的主机封了 fsockopen 和 pfsockopen 两个函数，导致邮件无法正常发送，同时也不能连接 smtp 服务器发送邮件，只有 curl 可用。于是，想起了以前转过的一篇文章，免费超大量邮件发送服务Mailgun提供SMTP和API支持。将其替换了 wordpress 自带的邮件模块，发现效果还不错。虽然 QQ 邮箱有时候会拒收 = =|||">
  

  
  
  <meta name="keywords" content="">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="在 wordpress 上使用 mailgun 发信"/>

  <meta property="og:site_name" content="博客"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="博客" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">博客</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>在 wordpress 上使用 mailgun 发信</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2014/09/03/在 wordpress 上使用 mailgun 发信/" rel="bookmark">
        <time class="entry-date published" datetime="2014-09-02T19:27:41.000Z">
          2014-09-03
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>前几天研究多说插件的评论回复邮件通知(<a href="http://futa.ooo/1858.html">修改多说插件，实现评论邮件通知自定义样式</a>)的时候，发现本博客用的主机封了 fsockopen 和 pfsockopen 两个函数，导致邮件无法正常发送，同时也不能连接 smtp 服务器发送邮件，只有 curl 可用。于是，想起了以前转过的一篇文章，<a href="http://futa.ooo/1787.html">免费超大量邮件发送服务Mailgun提供SMTP和API支持</a>。将其替换了 wordpress 自带的邮件模块，发现效果还不错。虽然 QQ 邮箱有时候会拒收 = =|||<br><a id="more"></a><br>首先，我用了最省力的方法，安装插件<br><a href="http://futa.ooo/wp-content/uploads/2014/09/Screenshot_2014-09-03-11-02-57.png"><img src="http://futa.ooo/wp-content/uploads/2014/09/Screenshot_2014-09-03-11-02-57-576x1024.png" alt="Screenshot_2014-09-03-11-02-57"></a><br>但是，没那么简单(如果这么简单我写这文章干嘛 = =)插件装完以后依旧无法正常发信。猜想其可能使用了 fsockopen 连接 mailgun 的邮件服务器，于是我修改了其发信模块，使用了 curl 连接 mailgun 服务器。<br>第二步，也是最后一步，将 ./wp-content/plugins/mailgun/includes/wp-mail.php 的内容替换为以下代码<br>`&lt;?php<br>/**</p>
<ul>
<li>wp_mail function to be loaded in to override the core wp_mail function</li>
<li>from wp-includes/pluggable.php<br>*</li>
<li>Based off of the core wp_mail function, but with modifications required to</li>
<li>send email using the Mailgun HTTP API<br>*</li>
<li>@param string|array $to Array or comma-separated list of email addresses to send message.</li>
<li>@param string $subject Email subject</li>
<li>@param string $message Message contents</li>
<li>@param string|array $headers Optional. Additional headers.</li>
<li>@param string|array $attachments Optional. Files to attach.</li>
<li>@return bool Whether the email contents were sent successfully.</li>
<li><p>@since 0.1<br>*/<br>function wp_mail( $to, $subject, $message, $headers = ‘’, $attachments = array() ) {<br> // Compact the input, apply the filters, and extract them back out<br> extract( apply_filters( ‘wp_mail’, compact( ‘to’, ‘subject’, ‘message’, ‘headers’, ‘attachments’ ) ) );</p>
<p> $mailgun = get_option( ‘mailgun’ );<br> $apiKey = ( defined( ‘MAILGUN_APIKEY’ ) &amp;&amp; MAILGUN_APIKEY ) ? MAILGUN_APIKEY : $mailgun[‘apiKey’];<br> $domain = ( defined( ‘MAILGUN_DOMAIN’ ) &amp;&amp; MAILGUN_DOMAIN ) ? MAILGUN_DOMAIN : $mailgun[‘domain’];</p>
<p> if ( empty( $apiKey ) || empty( $domain ) )</p>
<pre><code>return false;
</code></pre><p> if ( !is_array($attachments) )</p>
<pre><code>$attachments = explode( &quot;\n&quot;, str_replace( &quot;\r\n&quot;, &quot;\n&quot;, $attachments ) );
</code></pre><p> // Headers<br> if ( empty( $headers ) ) {</p>
<pre><code>$headers = array();
</code></pre><p> } else {</p>
<pre><code>if ( !is_array( $headers ) ) {
    // Explode the headers out, so this function can take both
    // string headers and an array of headers.
    $tempheaders = explode( &quot;\n&quot;, str_replace( &quot;\r\n&quot;, &quot;\n&quot;, $headers ) );
} else {
    $tempheaders = $headers;
}
$headers = array();
$cc = array();
$bcc = array();

// If it&apos;s actually got contents
if ( !empty( $tempheaders ) ) {
    // Iterate through the raw headers
    foreach ( (array) $tempheaders as $header ) {
        if ( strpos($header, &apos;:&apos;) === false ) {
            if ( false !== stripos( $header, &apos;boundary=&apos; ) ) {
                $parts = preg_split(&apos;/boundary=/i&apos;, trim( $header ) );
                $boundary = trim( str_replace( array( &quot;&apos;&quot;, &apos;&quot;&apos; ), &apos;&apos;, $parts[1] ) );
            }
            continue;
        }
        // Explode them out
        list( $name, $content ) = explode( &apos;:&apos;, trim( $header ), 2 );

        // Cleanup crew
        $name    = trim( $name    );
        $content = trim( $content );

        switch ( strtolower( $name ) ) {
            // Mainly for legacy -- process a From: header if it&apos;s there
            case &apos;from&apos;:
                if ( strpos($content, &apos;&lt;&apos; ) !== false ) {
                    // So... making my life hard again?
                    $from_name = substr( $content, 0, strpos( $content, &apos;&lt;&apos; ) - 1 );
                    $from_name = str_replace( &apos;&quot;&apos;, &apos;&apos;, $from_name );
                    $from_name = trim( $from_name );

                    $from_email = substr( $content, strpos( $content, &apos;&lt;&apos; ) + 1 );
                    $from_email = str_replace( &apos;&gt;&apos;, &apos;&apos;, $from_email );
                    $from_email = trim( $from_email );
                } else {
                    $from_email = trim( $content );
                }
                break;
            case &apos;content-type&apos;:
                if ( strpos( $content, &apos;;&apos; ) !== false ) {
                    list( $type, $charset ) = explode( &apos;;&apos;, $content );
                    $content_type = trim( $type );
                    if ( false !== stripos( $charset, &apos;charset=&apos; ) ) {
                        $charset = trim( str_replace( array( &apos;charset=&apos;, &apos;&quot;&apos; ), &apos;&apos;, $charset ) );
                    } elseif ( false !== stripos( $charset, &apos;boundary=&apos; ) ) {
                        $boundary = trim( str_replace( array( &apos;BOUNDARY=&apos;, &apos;boundary=&apos;, &apos;&quot;&apos; ), &apos;&apos;, $charset ) );
                        $charset = &apos;&apos;;
                    }
                } else {
                    $content_type = trim( $content );
                }
                break;
            case &apos;cc&apos;:
                $cc = array_merge( (array) $cc, explode( &apos;,&apos;, $content ) );
                break;
            case &apos;bcc&apos;:
                $bcc = array_merge( (array) $bcc, explode( &apos;,&apos;, $content ) );
                break;
            default:
                // Add it to our grand headers array
                $headers[trim( $name )] = trim( $content );
                break;
        }
    }
}
</code></pre><p> }</p>
<p> // From email and name<br> // If we don’t have a name from the input headers<br> if ( !isset( $from_name ) )</p>
<pre><code>$from_name = &apos;PostMaster&apos;;
</code></pre><p> /* If we don’t have an email from the input headers default to wordpress@$sitename</p>
<ul>
<li>Some hosts will block outgoing mail from this address if it doesn’t exist but</li>
<li>there’s no easy alternative. Defaulting to admin_email might appear to be another</li>
<li>option but some hosts may refuse to relay mail from an unknown domain. See</li>
<li><p><a href="http://trac.wordpress.org/ticket/5007" target="_blank" rel="noopener">http://trac.wordpress.org/ticket/5007</a>.<br>*/</p>
<p>if ( !isset( $from_email ) ) {<br> // Get the site domain and get rid of www.<br> $sitename = strtolower( $_SERVER[‘SERVER_NAME’] );<br> if ( substr( $sitename, 0, 4 ) == ‘www.’ ) {</p>
<pre><code>$sitename = substr( $sitename, 4 );
</code></pre><p> }</p>
<p> $from_email = ‘postmaster@’ . $sitename;<br>}</p>
<p>// Plugin authors can override the potentially troublesome default<br>$from_email = apply_filters( ‘wp_mail_from’     , $from_email );<br>$from_name  = apply_filters( ‘wp_mail_from_name’, $from_name  );</p>
<p>$body = array(<br> ‘from’ =&gt; “{$from_name} &lt;{$from_email}&gt;”,<br> ‘to’ =&gt; $to,<br> ‘subject’ =&gt; $subject,<br> ‘text’ =&gt; $message<br>);</p>
<p>$body[‘o:tracking-clicks’] = isset( $mailgun[‘track-clicks’] ) ? $mailgun[‘track-clicks’] : “no”;<br>$body[‘o:tracking-opens’] = isset( $mailgun[‘track-opens’] ) ? “yes” : “no”;</p>
<p>if ( isset( $mailgun[‘tag’] ) ){<br> $tags = explode(“,”, str_replace(“ “,””, $mailgun[‘tag’]));<br> $body[‘o:tag’] = $tags;<br>}</p>
<p>if ( isset( $mailgun[‘campaign-id’] ) ){<br> $campaigns = explode(“,”, str_replace(“ “,””, $mailgun[‘campaign-id’]));<br> $body[‘o:campaign’] = $campaigns;<br>}</p>
<p>if ( ! empty( $cc ) &amp;&amp; is_array( $cc ) )<br> $body[‘cc’] = implode( ‘, ‘, $cc );</p>
<p>if ( ! empty( $bcc ) &amp;&amp; is_array( $bcc ) )<br> $body[‘bcc’] = implode( ‘, ‘, $bcc );</p>
<p>// Set Content-Type and charset<br>// If we don’t have a content-type from the input headers<br>if ( !isset( $content_type ) )<br> $content_type = ‘text/plain’;</p>
<p>$content_type = apply_filters( ‘wp_mail_content_type’, $content_type );<br>if ( $content_type == ‘text/html’ ) {<br> $body[‘html’] = $message;<br> $body[‘text’] = strip_tags( $message );<br>}</p>
<p>// If we don’t have a charset from the input headers<br>if ( !isset( $charset ) )<br> $charset = get_bloginfo( ‘charset’ );</p>
<p>// Set the content-type and charset<br>$charset = apply_filters( ‘wp_mail_charset’, $charset );<br>if ( isset( $headers[‘Content-Type’] ) ) {<br> if ( ! strstr( $headers[‘Content-Type’], ‘charset’ ) )</p>
<pre><code>$headers[&apos;Content-Type&apos;] = rtrim( $headers[&apos;Content-Type&apos;], &apos;; &apos; ) . &quot;; charset={$charset}&quot;;
</code></pre><p>}</p>
<p>// Set custom headers<br>if ( !empty( $headers ) ) {<br> foreach( (array) $headers as $name =&gt; $content ) {</p>
<pre><code>$body[&quot;h:{$name}&quot;] = $content;
</code></pre><p> }</p>
<p> // TODO: Can we handle this?<br> //if ( false !== stripos( $content_type, ‘multipart’ ) &amp;&amp; ! empty($boundary) )<br> //    $phpmailer-&gt;AddCustomHeader( sprintf( “Content-Type: %s;\n\t boundary=\”%s\””, $content_type, $boundary ) );<br>}</p>
<p>/*</p>
</li>
<li>Deconstruct post array and create POST payload.</li>
<li>This entire routine is because wp_remote_post does</li>
<li><p>not support files directly.<br>*/</p>
<p>// First, generate a boundary for the multipart message.<br>$boundary = base_convert(uniqid(‘boundary’, true), 10, 36);</p>
<p>$payload = null;</p>
<p>// Iterate through pre-built params and build payload:<br>foreach ( $body as $key =&gt; $value ) {<br> if ( is_array( $value ) ){</p>
<pre><code>$parent_key = $key;
foreach($value as $key =&gt; $value){
    $payload .= &apos;--&apos; . $boundary;
    $payload .= &quot;\r\n&quot;;
    $payload .= &apos;Content-Disposition: form-data; name=&quot;&apos; . $parent_key . &apos;[&apos; . $key . &apos;]&quot;&apos; . &quot;\r\n\r\n&quot;;
    $payload .= $value;
    $payload .= &quot;\r\n&quot;;
}
</code></pre><p> }<br> else{</p>
<pre><code>$payload .= &apos;--&apos; . $boundary;
$payload .= &quot;\r\n&quot;;
$payload .= &apos;Content-Disposition: form-data; name=&quot;&apos; . $key . &apos;&quot;&apos; . &quot;\r\n\r\n&quot;;
$payload .= $value;
$payload .= &quot;\r\n&quot;;
</code></pre><p> }<br>}</p>
<p>// If we have attachments, add them to the payload.<br>if ( !empty( $attachments ) ){<br> $i = 0;<br> foreach ( $attachments as $attachment ) {</p>
<pre><code>if ( !empty( $attachment ) ) {
    /*$payload .= &apos;--&apos; . $boundary;
    $payload .= &quot;\r\n&quot;;
    $payload .= &apos;Content-Disposition: form-data; name=&quot;attachment[&apos; . $i . &apos;]&quot;; filename=&quot;&apos; . basename( $attachment ) . &apos;&quot;&apos; . &quot;\r\n\r\n&quot;;
    $payload .= file_get_contents( $attachment );
    $payload .= &quot;\r\n&quot;;*/
    $attachments[$i]=&quot;@&quot;.$attachment;
    $i++;
}
</code></pre><p> }<br>}</p>
<p>$payload .= ‘–’ . $boundary . ‘–’;</p>
<p>$data = array(<br> ‘body’ =&gt; $payload,<br> ‘headers’ =&gt; array(</p>
<pre><code>&apos;content-type&apos; =&gt; &apos;multipart/form-data; boundary=&apos; . $boundary)
</code></pre><p>);</p>
<p>$url = “<a href="https://api.mailgun.net/v2/{$domain}/messages&quot;" target="_blank" rel="noopener">https://api.mailgun.net/v2/{$domain}/messages&quot;</a>;<br>/*<br>// TODO: Mailgun only supports 1000 recipients per request, since we are<br>// overriding this function, let’s add looping here to handle that<br>$response = wp_remote_post( $url, $data );</p>
<p>if ( is_wp_error( $response ) )<br> return false;</p>
<p>$response_code = wp_remote_retrieve_response_code( $response );<br>if ( (int) $response_code != 200 )<br> return false;</p>
<p>// Not sure there is any additional checking that needs to be done here, but why not?<br>$response_body = json_decode( wp_remote_retrieve_body( $response ) );<br>if ( ! isset( $response_body-&gt;message ) || $response_body-&gt;message != ‘Queued. Thank you.’ )<br> return false;</p>
<p>return true;*/<br>foreach ($attachments as $k=&gt;$attachment) {<br> $body[“attachment[“.$k.”]”]=$attachment;<br>}<br> $ch = curl_init();<br> curl_setopt($ch, CURLOPT_URL, $url);<br> curl_setopt($ch, CURLOPT_USERPWD, ‘api:’.$apiKey);<br> curl_setopt($ch, CURLOPT_HEADER, 0);<br> curl_setopt($ch, CURLOPT_POST, true);<br> curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);<br> curl_setopt($ch, CURLOPT_POSTFIELDS,$body);<br> $result=curl_exec($ch);<br> curl_close($ch);<br> $result=json_decode($result,1);<br> return $result[“message”]==”Queued. Thank you.”;<br>}<br><code>`</code></p>
</li>
</ul>
</li>
</ul>
<p>实测可以解决无法发信的问题，但是并没有测试过带附件发送，不知附件那部分有没有问题，希望有大神能帮忙看下。。。谢谢</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/建站相关/">建站相关</a>
    </span>
    

    

    </div>

    
  </div>
</article>


    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2018 403 Forbidden
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>