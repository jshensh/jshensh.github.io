<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Managing Hierarchical Data in MySQL | 博客</title>

  
  <meta name="author" content="403 Forbidden">
  

  
  <meta name="description" content="引言大多数用户都曾在数据库中处理过分层数据(hierarchical data)，认为分层数据的管理不是关系数据库的目的。之所以这么认为，是因为关系数据库中的表没有层次关系，只是简单的平面化的列表；而分层数据具有父－子关系，显然关系数据库中的表不能自然地表现出其分层的特性。我们认为，分层数据是每项只">
  

  
  
  <meta name="keywords" content="">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="Managing Hierarchical Data in MySQL"/>

  <meta property="og:site_name" content="博客"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="博客" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">博客</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/about.html">关于</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>Managing Hierarchical Data in MySQL</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/03/17/Managing Hierarchical Data in MySQL/" rel="bookmark">
        <time class="entry-date published" datetime="2017-03-16T20:50:14.000Z">
          2017-03-17
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><strong>引言</strong><br>大多数用户都曾在数据库中处理过分层数据(hierarchical data)，认为分层数据的管理不是关系数据库的目的。之所以这么认为，是因为关系数据库中的表没有层次关系，只是简单的平面化的列表；而分层数据具有父－子关系，显然关系数据库中的表不能自然地表现出其分层的特性。<br>我们认为，分层数据是每项只有一个父项和零个或多个子项（根项除外，根项没有父项）的数据集合。分层数据存在于许多基于数据库的应用程序中，包括论坛和邮件列表中的分类、商业组织图表、内容管理系统的分类、产品分类。我们打算使用下面一个虚构的电子商店的产品分类：<br><a href="/uploads/2017/03/1.png"><img src="/uploads/2017/03/1.png" alt=""></a><br>这些分类层次与上面提到的一些例子中的分类层次是相类似的。在本文中我们将从传统的邻接表(adjacency list)模型出发，阐述2种在MySQL中处理分层数据的模型。</p>
<p><strong>邻接表模型</strong><br>上述例子的分类数据将被存储在下面的数据表中（我给出了全部的数据表创建、数据插入的代码，你可以跟着做）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE category(</span><br><span class="line">category_id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">name VARCHAR(20) NOT NULL,</span><br><span class="line">parent INT DEFAULT NULL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO category</span><br><span class="line">VALUES(1,&apos;ELECTRONICS&apos;,NULL),(2,&apos;TELEVISIONS&apos;,1),(3,&apos;TUBE&apos;,2),</span><br><span class="line">(4,&apos;LCD&apos;,2),(5,&apos;PLASMA&apos;,2),(6,&apos;PORTABLE ELECTRONICS&apos;,1),</span><br><span class="line">(7,&apos;MP3 PLAYERS&apos;,6),(8,&apos;FLASH&apos;,7),</span><br><span class="line">(9,&apos;CD PLAYERS&apos;,6),(10,&apos;2 WAY RADIOS&apos;,6);</span><br><span class="line"></span><br><span class="line">SELECT * FROM category ORDER BY category_id;</span><br><span class="line"></span><br><span class="line">+-------------+----------------------+--------+</span><br><span class="line">| category_id | name                 | parent |</span><br><span class="line">+-------------+----------------------+--------+</span><br><span class="line">|           1 | ELECTRONICS          |   NULL |</span><br><span class="line">|           2 | TELEVISIONS          |      1 |</span><br><span class="line">|           3 | TUBE                 |      2 |</span><br><span class="line">|           4 | LCD                  |      2 |</span><br><span class="line">|           5 | PLASMA               |      2 |</span><br><span class="line">|           6 | PORTABLE ELECTRONICS |      1 |</span><br><span class="line">|           7 | MP3 PLAYERS          |      6 |</span><br><span class="line">|           8 | FLASH                |      7 |</span><br><span class="line">|           9 | CD PLAYERS           |      6 |</span><br><span class="line">|          10 | 2 WAY RADIOS         |      6 |</span><br><span class="line">+-------------+----------------------+--------+</span><br><span class="line">10 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p>在邻接表模型中，数据表中的每项包含了指向其父项的指示器。在此例中，最上层项的父项为空值(NULL)。邻接表模型的优势在于它很简单，可以很容易地看出FLASH是MP3 PLAYERS的子项，哪个是portable electronics的子项，哪个是electronics的子项。虽然，在客户端编码中邻接表模型处理起来也相当的简单，但是如果是纯SQL编码的话，该模型会有很多问题。</p>
<p><strong>检索整树</strong><br>通常在处理分层数据时首要的任务是，以某种缩进形式来呈现一棵完整的树。为此，在纯SQL编码中通常的做法是使用自连接(self-join)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SELECT t1.name AS lev1, t2.name as lev2, t3.name as lev3, t4.name as lev4</span><br><span class="line">FROM category AS t1</span><br><span class="line">LEFT JOIN category AS t2 ON t2.parent = t1.category_id</span><br><span class="line">LEFT JOIN category AS t3 ON t3.parent = t2.category_id</span><br><span class="line">LEFT JOIN category AS t4 ON t4.parent = t3.category_id</span><br><span class="line">WHERE t1.name = &apos;ELECTRONICS&apos;;</span><br><span class="line"></span><br><span class="line">+-------------+----------------------+--------------+-------+</span><br><span class="line">| lev1        | lev2                 | lev3         | lev4  |</span><br><span class="line">+-------------+----------------------+--------------+-------+</span><br><span class="line">| ELECTRONICS | TELEVISIONS          | TUBE         | NULL  |</span><br><span class="line">| ELECTRONICS | TELEVISIONS          | LCD          | NULL  |</span><br><span class="line">| ELECTRONICS | TELEVISIONS          | PLASMA       | NULL  |</span><br><span class="line">| ELECTRONICS | PORTABLE ELECTRONICS | MP3 PLAYERS  | FLASH |</span><br><span class="line">| ELECTRONICS | PORTABLE ELECTRONICS | CD PLAYERS   | NULL  |</span><br><span class="line">| ELECTRONICS | PORTABLE ELECTRONICS | 2 WAY RADIOS | NULL  |</span><br><span class="line">+-------------+----------------------+--------------+-------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p><strong>检索所有叶子节点</strong><br>我们可以用左连接(LEFT JOIN)来检索出树中所有叶子节点(没有孩子节点的节点）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SELECT t1.name FROM</span><br><span class="line">category AS t1 LEFT JOIN category as t2</span><br><span class="line">ON t1.category_id = t2.parent</span><br><span class="line">WHERE t2.category_id IS NULL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+--------------+</span><br><span class="line">| name         |</span><br><span class="line">+--------------+</span><br><span class="line">| TUBE         |</span><br><span class="line">| LCD          |</span><br><span class="line">| PLASMA       |</span><br><span class="line">| FLASH        |</span><br><span class="line">| CD PLAYERS   |</span><br><span class="line">| 2 WAY RADIOS |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure></p>
<p><strong>检索单一路径</strong><br>通过自连接，我们也可以检索出单一路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT t1.name AS lev1, t2.name as lev2, t3.name as lev3, t4.name as lev4</span><br><span class="line">FROM category AS t1</span><br><span class="line">LEFT JOIN category AS t2 ON t2.parent = t1.category_id</span><br><span class="line">LEFT JOIN category AS t3 ON t3.parent = t2.category_id</span><br><span class="line">LEFT JOIN category AS t4 ON t4.parent = t3.category_id</span><br><span class="line">WHERE t1.name = &apos;ELECTRONICS&apos; AND t4.name = &apos;FLASH&apos;;</span><br><span class="line"></span><br><span class="line">+-------------+----------------------+-------------+-------+</span><br><span class="line">| lev1        | lev2                 | lev3        | lev4  |</span><br><span class="line">+-------------+----------------------+-------------+-------+</span><br><span class="line">| ELECTRONICS | PORTABLE ELECTRONICS | MP3 PLAYERS | FLASH |</span><br><span class="line">+-------------+----------------------+-------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure></p>
<p>这种方法的主要局限是你需要为每层数据添加一个自连接，随着层次的增加，自连接变得越来越复杂，检索的性能自然而然的也就下降了。</p>
<p><strong>邻接表模型的局限性</strong><br>用纯SQL编码实现邻接表模型有一定的难度。在我们检索某分类的路径之前，我们需要知道该分类所在的层次。另外，我们在删除节点的时候要特别小心，因为潜在的可能会孤立一棵子树（当删除portable electronics分类时，所有他的子分类都成了孤儿）。部分局限性可以通过使用客户端代码或者存储过程来解决，我们可以从树的底部开始向上迭代来获得一颗树或者单一路径，我们也可以在删除节点的时候使其子节点指向一个新的父节点，来防止孤立子树的产生。</p>
<p><strong>嵌套集合(Nested Set)模型</strong><br>我想在这篇文章中重点阐述一种不同的方法，俗称为嵌套集合模型。在嵌套集合模型中，我们将以一种新的方式来看待我们的分层数据，不再是线与点了，而是嵌套容器。我试着以嵌套容器的方式画出了electronics分类图：<br><a href="/uploads/2017/03/2.png"><img src="/uploads/2017/03/2.png" alt=""></a><br>从上图可以看出我们依旧保持了数据的层次，父分类包围了其子分类。在数据表中，我们通过使用表示节点的嵌套关系的左值(left value)和右值(right value)来表现嵌套集合模型中数据的分层特性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE nested_category (</span><br><span class="line"> category_id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line"> name VARCHAR(20) NOT NULL,</span><br><span class="line"> lft INT NOT NULL,</span><br><span class="line"> rgt INT NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO nested_category</span><br><span class="line">VALUES(1,&apos;ELECTRONICS&apos;,1,20),(2,&apos;TELEVISIONS&apos;,2,9),(3,&apos;TUBE&apos;,3,4),</span><br><span class="line">(4,&apos;LCD&apos;,5,6),(5,&apos;PLASMA&apos;,7,8),(6,&apos;PORTABLE ELECTRONICS&apos;,10,19),</span><br><span class="line">(7,&apos;MP3 PLAYERS&apos;,11,14),(8,&apos;FLASH&apos;,12,13),</span><br><span class="line">(9,&apos;CD PLAYERS&apos;,15,16),(10,&apos;2 WAY RADIOS&apos;,17,18);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT * FROM nested_category ORDER BY category_id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+-------------+----------------------+-----+-----+</span><br><span class="line">| category_id | name                 | lft | rgt |</span><br><span class="line">+-------------+----------------------+-----+-----+</span><br><span class="line">|           1 | ELECTRONICS          |   1 |  20 |</span><br><span class="line">|           2 | TELEVISIONS          |   2 |   9 |</span><br><span class="line">|           3 | TUBE                 |   3 |   4 |</span><br><span class="line">|           4 | LCD                  |   5 |   6 |</span><br><span class="line">|           5 | PLASMA               |   7 |   8 |</span><br><span class="line">|           6 | PORTABLE ELECTRONICS |  10 |  19 |</span><br><span class="line">|           7 | MP3 PLAYERS          |  11 |  14 |</span><br><span class="line">|           8 | FLASH                |  12 |  13 |</span><br><span class="line">|           9 | CD PLAYERS           |  15 |  16 |</span><br><span class="line">|          10 | 2 WAY RADIOS         |  17 |  18 |</span><br><span class="line">+-------------+----------------------+-----+-----+</span><br></pre></td></tr></table></figure></p>
<p>我们使用了lft和rgt来代替left和right，是因为在MySQL中left和right是保留字。<a href="http://dev.mysql.com/doc/mysql/en/reserved-words.html" target="_blank" rel="noopener">http://dev.mysql.com/doc/mysql/en/reserved-words.html</a>，有一份详细的MySQL保留字清单。<br>那么，我们怎样决定左值和右值呢？我们从外层节点的最左侧开始，从左到右编号：<br><a href="/uploads/2017/03/3.png"><img src="/uploads/2017/03/3.png" alt=""></a><br>这样的编号方式也同样适用于典型的树状结构：<br><a href="/uploads/2017/03/4.png"><img src="/uploads/2017/03/4.png" alt=""></a><br>当我们为树状的结构编号时，我们从左到右，一次一层，为节点赋右值前先从左到右遍历其子节点给其子节点赋左右值。这种方法被称作改进的<strong>先序遍历算法</strong>。</p>
<p><strong>检索整树</strong><br>我们可以通过自连接把父节点连接到子节点上来检索整树，是因为子节点的lft值总是在其父节点的lft值和rgt值之间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">SELECT node.name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">AND parent.name = &apos;ELECTRONICS&apos;</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+----------------------+</span><br><span class="line">| name                 |</span><br><span class="line">+----------------------+</span><br><span class="line">| ELECTRONICS          |</span><br><span class="line">| TELEVISIONS          |</span><br><span class="line">| TUBE                 |</span><br><span class="line">| LCD                  |</span><br><span class="line">| PLASMA               |</span><br><span class="line">| PORTABLE ELECTRONICS |</span><br><span class="line">| MP3 PLAYERS          |</span><br><span class="line">| FLASH                |</span><br><span class="line">| CD PLAYERS           |</span><br><span class="line">| 2 WAY RADIOS         |</span><br><span class="line">+----------------------+</span><br></pre></td></tr></table></figure></p>
<p>不像先前邻接表模型的例子，这个查询语句不管树的层次有多深都能很好的工作。在BETWEEN的子句中我们没有去关心node的rgt值，是因为使用node的rgt值得出的父节点总是和使用lft值得出的是相同的。</p>
<p><strong>检索所有叶子节点</strong><br>检索出所有的叶子节点，使用嵌套集合模型的方法比邻接表模型的LEFT JOIN方法简单多了。如果你仔细得看了nested_category表，你可能已经注意到叶子节点的左右值是连续的。要检索出叶子节点，我们只要查找满足rgt=lft+1的节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT name</span><br><span class="line">FROM nested_category</span><br><span class="line">WHERE rgt = lft + 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+--------------+</span><br><span class="line">| name         |</span><br><span class="line">+--------------+</span><br><span class="line">| TUBE         |</span><br><span class="line">| LCD          |</span><br><span class="line">| PLASMA       |</span><br><span class="line">| FLASH        |</span><br><span class="line">| CD PLAYERS   |</span><br><span class="line">| 2 WAY RADIOS |</span><br><span class="line">+--------------+</span><br></pre></td></tr></table></figure></p>
<p><strong>检索单一路径</strong><br>在嵌套集合模型中，我们可以不用多个自连接就可以检索出单一路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT parent.name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">AND node.name = &apos;FLASH&apos;</span><br><span class="line">ORDER BY parent.lft;</span><br><span class="line"></span><br><span class="line">+----------------------+</span><br><span class="line">| name                 |</span><br><span class="line">+----------------------+</span><br><span class="line">| ELECTRONICS          |</span><br><span class="line">| PORTABLE ELECTRONICS |</span><br><span class="line">| MP3 PLAYERS          |</span><br><span class="line">| FLASH                |</span><br><span class="line">+----------------------+</span><br></pre></td></tr></table></figure></p>
<p><strong>检索节点的深度</strong><br>我们已经知道怎样去呈现一棵整树，但是为了更好的标识出节点在树中所处层次，我们怎样才能检索出节点在树中的深度呢？我们可以在先前的查询语句上增加COUNT函数和GROUP BY子句来实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SELECT node.name, (COUNT(parent.name) - 1) AS depth</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">GROUP BY node.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line">+----------------------+-------+</span><br><span class="line">| name                 | depth |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| ELECTRONICS          |     0 |</span><br><span class="line">| TELEVISIONS          |     1 |</span><br><span class="line">| TUBE                 |     2 |</span><br><span class="line">| LCD                  |     2 |</span><br><span class="line">| PLASMA               |     2 |</span><br><span class="line">| PORTABLE ELECTRONICS |     1 |</span><br><span class="line">| MP3 PLAYERS          |     2 |</span><br><span class="line">| FLASH                |     3 |</span><br><span class="line">| CD PLAYERS           |     2 |</span><br><span class="line">| 2 WAY RADIOS         |     2 |</span><br><span class="line">+----------------------+-------+</span><br></pre></td></tr></table></figure></p>
<p>我们可以根据depth值来缩进分类名字，使用CONCAT和REPEAT字符串函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SELECT CONCAT( REPEAT(&apos; &apos;, COUNT(parent.name) - 1), node.name) AS name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">GROUP BY node.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line">+-----------------------+</span><br><span class="line">| name                  |</span><br><span class="line">+-----------------------+</span><br><span class="line">| ELECTRONICS           |</span><br><span class="line">|  TELEVISIONS          |</span><br><span class="line">|   TUBE                |</span><br><span class="line">|   LCD                 |</span><br><span class="line">|   PLASMA              |</span><br><span class="line">|  PORTABLE ELECTRONICS |</span><br><span class="line">|   MP3 PLAYERS         |</span><br><span class="line">|    FLASH              |</span><br><span class="line">|   CD PLAYERS          |</span><br><span class="line">|   2 WAY RADIOS        |</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure></p>
<p>当然，在客户端应用程序中你可能会用depth值来直接展示数据的层次。Web开发者会遍历该树，随着depth值的增加和减少来添加</p>
<ul>
<li>和</li>
</ul>
<p>标签。</p>
<p><strong>检索子树的深度</strong><br>当我们需要子树的深度信息时，我们不能限制自连接中的node或parent，因为这么做会打乱数据集的顺序。因此，我们添加了第三个自连接作为子查询，来得出子树新起点的深度值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">SELECT node.name, (COUNT(parent.name) - (sub_tree.depth + 1)) AS depth</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">	nested_category AS parent,</span><br><span class="line">	nested_category AS sub_parent,</span><br><span class="line">	(</span><br><span class="line">		SELECT node.name, (COUNT(parent.name) - 1) AS depth</span><br><span class="line">		FROM nested_category AS node,</span><br><span class="line">		nested_category AS parent</span><br><span class="line">		WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">		AND node.name = &apos;PORTABLE ELECTRONICS&apos;</span><br><span class="line">		GROUP BY node.name</span><br><span class="line">		ORDER BY node.lft</span><br><span class="line">	)AS sub_tree</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">	AND node.lft BETWEEN sub_parent.lft AND sub_parent.rgt</span><br><span class="line">	AND sub_parent.name = sub_tree.name</span><br><span class="line">GROUP BY node.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+----------------------+-------+</span><br><span class="line">| name                 | depth |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| PORTABLE ELECTRONICS |     0 |</span><br><span class="line">| MP3 PLAYERS          |     1 |</span><br><span class="line">| FLASH                |     2 |</span><br><span class="line">| CD PLAYERS           |     1 |</span><br><span class="line">| 2 WAY RADIOS         |     1 |</span><br><span class="line">+----------------------+-------+</span><br></pre></td></tr></table></figure></p>
<p>这个查询语句可以检索出任一节点子树的深度值，包括根节点。这里的深度值跟你指定的节点有关。</p>
<p><strong>检索节点的直接子节点</strong><br>可以想象一下，你在零售网站上呈现电子产品的分类。当用户点击分类后，你将要呈现该分类下的产品，同时也需列出该分类下的直接子分类，而不是该分类下的全部分类。为此，我们只呈现该节点及其直接子节点，不再呈现更深层次的节点。例如，当呈现PORTABLEELECTRONICS分类时，我们同时只呈现MP3 PLAYERS、CD PLAYERS和2 WAY RADIOS分类，而不呈现FLASH分类。</p>
<p>要实现它非常的简单，在先前的查询语句上添加HAVING子句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">SELECT node.name, (COUNT(parent.name) - (sub_tree.depth + 1)) AS depth</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">	nested_category AS parent,</span><br><span class="line">	nested_category AS sub_parent,</span><br><span class="line">	(</span><br><span class="line">		SELECT node.name, (COUNT(parent.name) - 1) AS depth</span><br><span class="line">		FROM nested_category AS node,</span><br><span class="line">		nested_category AS parent</span><br><span class="line">		WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">		AND node.name = &apos;PORTABLE ELECTRONICS&apos;</span><br><span class="line">		GROUP BY node.name</span><br><span class="line">		ORDER BY node.lft</span><br><span class="line">	)AS sub_tree</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">	AND node.lft BETWEEN sub_parent.lft AND sub_parent.rgt</span><br><span class="line">	AND sub_parent.name = sub_tree.name</span><br><span class="line">GROUP BY node.name</span><br><span class="line">HAVING depth &lt;= 1</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line">+----------------------+-------+</span><br><span class="line">| name                 | depth |</span><br><span class="line">+----------------------+-------+</span><br><span class="line">| PORTABLE ELECTRONICS |     0 |</span><br><span class="line">| MP3 PLAYERS          |     1 |</span><br><span class="line">| CD PLAYERS           |     1 |</span><br><span class="line">| 2 WAY RADIOS         |     1 |</span><br><span class="line">+----------------------+-------+</span><br></pre></td></tr></table></figure></p>
<p>如果你不希望呈现父节点，你可以更改<strong>HAVING depth &lt;= 1</strong>为<strong>HAVING depth = 1</strong>。</p>
<p><strong>嵌套集合模型中集合函数的应用</strong><br>让我们添加一个产品表，我们可以使用它来示例集合函数的应用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE product(</span><br><span class="line">product_id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">name VARCHAR(40),</span><br><span class="line">category_id INT NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO product(name, category_id) VALUES(&apos;20&quot; TV&apos;,3),(&apos;36&quot; TV&apos;,3),</span><br><span class="line">(&apos;Super-LCD 42&quot;&apos;,4),(&apos;Ultra-Plasma 62&quot;&apos;,5),(&apos;Value Plasma 38&quot;&apos;,5),</span><br><span class="line">(&apos;Power-MP3 5gb&apos;,7),(&apos;Super-Player 1gb&apos;,8),(&apos;Porta CD&apos;,9),(&apos;CD To go!&apos;,9),</span><br><span class="line">(&apos;Family Talk 360&apos;,10);</span><br><span class="line"></span><br><span class="line">SELECT * FROM product;</span><br><span class="line"></span><br><span class="line">+------------+-------------------+-------------+</span><br><span class="line">| product_id | name              | category_id |</span><br><span class="line">+------------+-------------------+-------------+</span><br><span class="line">|          1 | 20&quot; TV            |           3 |</span><br><span class="line">|          2 | 36&quot; TV            |           3 |</span><br><span class="line">|          3 | Super-LCD 42&quot;     |           4 |</span><br><span class="line">|          4 | Ultra-Plasma 62&quot;  |           5 |</span><br><span class="line">|          5 | Value Plasma 38&quot;  |           5 |</span><br><span class="line">|          6 | Power-MP3 128mb   |           7 |</span><br><span class="line">|          7 | Super-Shuffle 1gb |           8 |</span><br><span class="line">|          8 | Porta CD          |           9 |</span><br><span class="line">|          9 | CD To go!         |           9 |</span><br><span class="line">|         10 | Family Talk 360   |          10 |</span><br><span class="line">+------------+-------------------+-------------+</span><br></pre></td></tr></table></figure></p>
<p>现在，让我们写一个查询语句，在检索分类树的同时，计算出各分类下的产品数量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">SELECT parent.name, COUNT(product.name)</span><br><span class="line">FROM nested_category AS node ,</span><br><span class="line">nested_category AS parent,</span><br><span class="line">product</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">AND node.category_id = product.category_id</span><br><span class="line">GROUP BY parent.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+----------------------+---------------------+</span><br><span class="line">| name                 | COUNT(product.name) |</span><br><span class="line">+----------------------+---------------------+</span><br><span class="line">| ELECTRONICS          |                  10 |</span><br><span class="line">| TELEVISIONS          |                   5 |</span><br><span class="line">| TUBE                 |                   2 |</span><br><span class="line">| LCD                  |                   1 |</span><br><span class="line">| PLASMA               |                   2 |</span><br><span class="line">| PORTABLE ELECTRONICS |                   5 |</span><br><span class="line">| MP3 PLAYERS          |                   2 |</span><br><span class="line">| FLASH                |                   1 |</span><br><span class="line">| CD PLAYERS           |                   2 |</span><br><span class="line">| 2 WAY RADIOS         |                   1 |</span><br><span class="line">+----------------------+---------------------+</span><br></pre></td></tr></table></figure></p>
<p>这条查询语句在检索整树的查询语句上增加了COUNT和GROUP BY子句，同时在WHERE子句中引用了product表和一个自连接。</p>
<p><strong>新增节点</strong><br>到现在，我们已经知道了如何去查询我们的树，是时候去关注一下如何增加一个新节点来更新我们的树了。让我们再一次观察一下我们的嵌套集合图：<br><a href="/uploads/2017/03/5.png"><img src="/uploads/2017/03/5.png" alt=""></a><br>当我们想要在TELEVISIONS和PORTABLE ELECTRONICS节点之间新增一个节点，新节点的lft和rgt 的 值为10和11，所有该节点的右边节点的lft和rgt值都将加2，之后我们再添加新节点并赋相应的lft和rgt值。在MySQL 5中可以使用存储过程来完成，我假设当前大部分读者使用的是MySQL 4.1版本，因为这是最新的稳定版本。所以，我使用了锁表（LOCK TABLES）语句来隔离查询：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLE nested_category WRITE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT @myRight := rgt FROM nested_category</span><br><span class="line">WHERE name = &apos;TELEVISIONS&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UPDATE nested_category SET rgt = rgt + 2 WHERE rgt &gt; @myRight;</span><br><span class="line">UPDATE nested_category SET lft = lft + 2 WHERE lft &gt; @myRight;</span><br><span class="line"></span><br><span class="line">INSERT INTO nested_category(name, lft, rgt) VALUES(&apos;GAME CONSOLES&apos;, @myRight + 1, @myRight + 2);</span><br><span class="line"></span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure></p>
<p>我们可以检验一下新节点插入的正确性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SELECT CONCAT( REPEAT( &apos; &apos;, (COUNT(parent.name) - 1) ), node.name) AS name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">GROUP BY node.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+-----------------------+</span><br><span class="line">| name                  |</span><br><span class="line">+-----------------------+</span><br><span class="line">| ELECTRONICS           |</span><br><span class="line">|  TELEVISIONS          |</span><br><span class="line">|   TUBE                |</span><br><span class="line">|   LCD                 |</span><br><span class="line">|   PLASMA              |</span><br><span class="line">|  GAME CONSOLES        |</span><br><span class="line">|  PORTABLE ELECTRONICS |</span><br><span class="line">|   MP3 PLAYERS         |</span><br><span class="line">|    FLASH              |</span><br><span class="line">|   CD PLAYERS          |</span><br><span class="line">|   2 WAY RADIOS        |</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure></p>
<p>如果我们想要在叶子节点下增加节点，我们得稍微修改一下查询语句。让我们在2 WAYRADIOS叶子节点下添加FRS节点吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLE nested_category WRITE;</span><br><span class="line"></span><br><span class="line">SELECT @myLeft := lft FROM nested_category</span><br><span class="line"></span><br><span class="line">WHERE name = &apos;2 WAY RADIOS&apos;;</span><br><span class="line"></span><br><span class="line">UPDATE nested_category SET rgt = rgt + 2 WHERE rgt &gt; @myLeft;</span><br><span class="line">UPDATE nested_category SET lft = lft + 2 WHERE lft &gt; @myLeft;</span><br><span class="line"></span><br><span class="line">INSERT INTO nested_category(name, lft, rgt) VALUES(&apos;FRS&apos;, @myLeft + 1, @myLeft + 2);</span><br><span class="line"></span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，我们扩大了新产生的父节点(2 WAY RADIOS节点）的右值及其所有它的右边节点的左右值，之后置新增节点于新父节点之下。正如你所看到的，我们新增的节点已经完全融入了嵌套集合中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">SELECT CONCAT( REPEAT( &apos; &apos;, (COUNT(parent.name) - 1) ), node.name) AS name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">GROUP BY node.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+-----------------------+</span><br><span class="line">| name                  |</span><br><span class="line">+-----------------------+</span><br><span class="line">| ELECTRONICS           |</span><br><span class="line">|  TELEVISIONS          |</span><br><span class="line">|   TUBE                |</span><br><span class="line">|   LCD                 |</span><br><span class="line">|   PLASMA              |</span><br><span class="line">|  GAME CONSOLES        |</span><br><span class="line">|  PORTABLE ELECTRONICS |</span><br><span class="line">|   MP3 PLAYERS         |</span><br><span class="line">|    FLASH              |</span><br><span class="line">|   CD PLAYERS          |</span><br><span class="line">|   2 WAY RADIOS        |</span><br><span class="line">|    FRS                |</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure></p>
<p><strong>删除节点</strong><br>最后还有个基础任务，删除节点。删除节点的处理过程跟节点在分层数据中所处的位置有关，删除一个叶子节点比删除一个子节点要简单得多，因为删除子节点的时候，我们需要去处理孤立节点。<br>删除一个叶子节点的过程正好是新增一个叶子节点的逆过程，我们在删除节点的同时该节点右边所有节点的左右值和该父节点的右值都会减去该节点的宽度值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLE nested_category WRITE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT @myLeft := lft, @myRight := rgt, @myWidth := rgt - lft + 1</span><br><span class="line">FROM nested_category</span><br><span class="line">WHERE name = &apos;GAME CONSOLES&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELETE FROM nested_category WHERE lft BETWEEN @myLeft AND @myRight;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UPDATE nested_category SET rgt = rgt - @myWidth WHERE rgt &gt; @myRight;</span><br><span class="line">UPDATE nested_category SET lft = lft - @myWidth WHERE lft &gt; @myRight;</span><br><span class="line"></span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure></p>
<p>我们再一次检验一下节点已经成功删除,而且没有打乱数据的层次：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SELECT CONCAT( REPEAT( &apos; &apos;, (COUNT(parent.name) - 1) ), node.name) AS name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">GROUP BY node.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+-----------------------+</span><br><span class="line">| name                  |</span><br><span class="line">+-----------------------+</span><br><span class="line">| ELECTRONICS           |</span><br><span class="line">|  TELEVISIONS          |</span><br><span class="line">|   TUBE                |</span><br><span class="line">|   LCD                 |</span><br><span class="line">|   PLASMA              |</span><br><span class="line">|  PORTABLE ELECTRONICS |</span><br><span class="line">|   MP3 PLAYERS         |</span><br><span class="line">|    FLASH              |</span><br><span class="line">|   CD PLAYERS          |</span><br><span class="line">|   2 WAY RADIOS        |</span><br><span class="line">|    FRS                |</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure></p>
<p>这个方法可以完美地删除节点及其子节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLE nested_category WRITE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT @myLeft := lft, @myRight := rgt, @myWidth := rgt - lft + 1</span><br><span class="line">FROM nested_category</span><br><span class="line">WHERE name = &apos;MP3 PLAYERS&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELETE FROM nested_category WHERE lft BETWEEN @myLeft AND @myRight;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UPDATE nested_category SET rgt = rgt - @myWidth WHERE rgt &gt; @myRight;</span><br><span class="line">UPDATE nested_category SET lft = lft - @myWidth WHERE lft &gt; @myRight;</span><br><span class="line"></span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure></p>
<p>再次验证我们已经成功的删除了一棵子树：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SELECT CONCAT( REPEAT( &apos; &apos;, (COUNT(parent.name) - 1) ), node.name) AS name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">GROUP BY node.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+-----------------------+</span><br><span class="line">| name                  |</span><br><span class="line">+-----------------------+</span><br><span class="line">| ELECTRONICS           |</span><br><span class="line">|  TELEVISIONS          |</span><br><span class="line">|   TUBE                |</span><br><span class="line">|   LCD                 |</span><br><span class="line">|   PLASMA              |</span><br><span class="line">|  PORTABLE ELECTRONICS |</span><br><span class="line">|   CD PLAYERS          |</span><br><span class="line">|   2 WAY RADIOS        |</span><br><span class="line">|    FRS                |</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure></p>
<p>有时，我们只删除该节点，而不删除该节点的子节点。在一些情况下，你希望改变其名字为占位符，直到替代名字的出现，比如你开除了一个主管（需要更换主管）。在另外一些情况下，你希望子节点挂到该删除节点的父节点下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLE nested_category WRITE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT @myLeft := lft, @myRight := rgt, @myWidth := rgt - lft + 1</span><br><span class="line">FROM nested_category</span><br><span class="line">WHERE name = &apos;PORTABLE ELECTRONICS&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELETE FROM nested_category WHERE lft = @myLeft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UPDATE nested_category SET rgt = rgt - 1, lft = lft - 1 WHERE lft BETWEEN @myLeft AND @myRight;</span><br><span class="line">UPDATE nested_category SET rgt = rgt - 2 WHERE rgt &gt; @myRight;</span><br><span class="line">UPDATE nested_category SET lft = lft - 2 WHERE lft &gt; @myRight;</span><br><span class="line"></span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，我们对该节点所有右边节点的左右值都减去了2（因为不考虑其子节点，该节点的宽度为2），对该节点的子节点的左右值都减去了1（弥补由于失去父节点的左值造成的裂缝）。我们再一次确认，那些节点是否都晋升了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SELECT CONCAT( REPEAT( &apos; &apos;, (COUNT(parent.name) - 1) ), node.name) AS name</span><br><span class="line">FROM nested_category AS node,</span><br><span class="line">nested_category AS parent</span><br><span class="line">WHERE node.lft BETWEEN parent.lft AND parent.rgt</span><br><span class="line">GROUP BY node.name</span><br><span class="line">ORDER BY node.lft;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+---------------+</span><br><span class="line">| name          |</span><br><span class="line">+---------------+</span><br><span class="line">| ELECTRONICS   |</span><br><span class="line">|  TELEVISIONS  |</span><br><span class="line">|   TUBE        |</span><br><span class="line">|   LCD         |</span><br><span class="line">|   PLASMA      |</span><br><span class="line">|  CD PLAYERS   |</span><br><span class="line">|  2 WAY RADIOS |</span><br><span class="line">|   FRS         |</span><br><span class="line">+---------------+</span><br></pre></td></tr></table></figure></p>
<p>有时，当删除节点的时候，把该节点的一个子节点挂载到该节点的父节点下，而其他节点挂到该节点父节点的兄弟节点下，考虑到篇幅这种情况不在这里解说了。</p>
<p><strong>最后的思考</strong><br>我希望这篇文章对你有所帮助，SQL中的嵌套集合的观念大约有十年的历史了，在网上和一些书中都能找到许多相关信息。在我看来，讲述分层数据的管理最全面的，是来自一本名叫《Joe Celko’s Trees and Hierarchies in SQL for Smarties》的书，此书的作者是在高级SQL领域倍受尊敬的Joe Celko。Joe Celko被认为是嵌套集合模型的创造者，更是该领域内的多产作家。我把Celko的书当作无价之宝，并极力地推荐它。在这本书中涵盖了在此文中没有提及的一些高级话题，也提到了其他一些关于邻接表和嵌套集合模型下管理分层数据的方法。<br>在随后的参考书目章节中，我列出了一些网络资源，也许对你研究分层数据的管理会有所帮助，其中包括一些PHP相关的资源（处理嵌套集合的PHP库）。如果你还在使用邻接表模型，你该去试试嵌套集合模型了，在Storing Hierarchical Data in a Database 文中下方列出的一些资源链接中能找到一些样例代码，可以去试验一下。</p>
<p>转自 <a href="http://www.cnblogs.com/phaibin/archive/2009/06/09/1499687.html" target="_blank" rel="noopener">http://www.cnblogs.com/phaibin/archive/2009/06/09/1499687.html</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Web-开发/">Web 开发</a>
    </span>
    

    

    </div>

    
  </div>
</article>

  

	<section id="comment" class="comment">
	  <div id="disqus_thread">
	  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
	  </div>
	</section>

	<script type="text/javascript">
	var disqus_shortname = 'futa-ooo';
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	</script>




    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2020 403 Forbidden
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>